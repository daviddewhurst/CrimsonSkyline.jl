<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>CrimsonSkyline.jl · CrimsonSkyline.jl documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">CrimsonSkyline.jl documentation</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>CrimsonSkyline.jl</a><ul class="internal"><li><a class="tocitem" href="#trace"><span>trace</span></a></li><li><a class="tocitem" href="#io"><span>io</span></a></li><li><a class="tocitem" href="#effects"><span>effects</span></a></li><li><a class="tocitem" href="#basic-sampling-methods"><span>basic sampling methods</span></a></li><li><a class="tocitem" href="#importance"><span>importance</span></a></li><li><a class="tocitem" href="#metropolis"><span>metropolis</span></a></li><li><a class="tocitem" href="#nested"><span>nested</span></a></li><li><a class="tocitem" href="#results"><span>results</span></a></li><li><a class="tocitem" href="#online"><span>online</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>CrimsonSkyline.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>CrimsonSkyline.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com//blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="CrimsonSkyline.jl"><a class="docs-heading-anchor" href="#CrimsonSkyline.jl">CrimsonSkyline.jl</a><a id="CrimsonSkyline.jl-1"></a><a class="docs-heading-anchor-permalink" href="#CrimsonSkyline.jl" title="Permalink"></a></h1><h2 id="trace"><a class="docs-heading-anchor" href="#trace">trace</a><a id="trace-1"></a><a class="docs-heading-anchor-permalink" href="#trace" title="Permalink"></a></h2><p>To a large extent, <code>Node</code>s have local control over the behavior of inference algorithms via their  <code>interpretation</code>. There are a variety of <code>Interpretation</code>s. The type hierarchy is flat:</p><pre><code class="language-none">abstract type Interpretation end
struct Nonstandard &lt;: Interpretation end
struct Standard &lt;: Interpretation end
struct Replayed &lt;: Interpretation end
struct Conditioned &lt;: Interpretation end 
struct Blocked &lt;: Interpretation end
struct Deterministic &lt;: Interpretation end
struct Proposed &lt;: Interpretation end</code></pre><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.ParametricNode" href="#CrimsonSkyline.ParametricNode"><code>CrimsonSkyline.ParametricNode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct ParametricNode{A, D, T} &lt;: Node
    address :: A
    dist :: D
    value :: Maybe{T}
    logprob :: Float64
    logprob_sum :: Float64
    observed :: Bool
    pa :: Array{Node, 1}
    ch :: Array{Node, 1}
    interpretation :: Union{Interpretation, Vector{Interpretation}}
    last_interpretation :: Union{Interpretation, Vector{Interpretation}}
end</code></pre><p>A <code>Node</code> that can be used with arbitrary code for which <code>rand</code> and <code>Distributionss.logpdf</code> are defined.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.SampleableNode" href="#CrimsonSkyline.SampleableNode"><code>CrimsonSkyline.SampleableNode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct SampleableNode{A, T} &lt;: Node
    address :: A
    dist :: Sampleable
    value :: Maybe{T}
    logprob :: Float64
    logprob_sum :: Float64
    observed :: Bool
    pa :: Array{Node, 1}
    ch :: Array{Node, 1}
    interpretation :: Union{Interpretation, Vector{Interpretation}}
    last_interpretation :: Union{Interpretation, Vector{Interpretation}}
end</code></pre><p>A <code>Node</code> that is restricted to be used with any <code>Sampleable</code> from <code>Distributions.jl</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.Trace" href="#CrimsonSkyline.Trace"><code>CrimsonSkyline.Trace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type Trace end</code></pre><p>Base type for all traces. <code>Trace</code>s support the following <code>Base</code> methods: <code>setindex!</code>, <code>getindex</code>, <code>keys</code>, <code>values</code>, and <code>length</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.TypedTrace" href="#CrimsonSkyline.TypedTrace"><code>CrimsonSkyline.TypedTrace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct TypedTrace{A, T} &lt;: Trace
    trace :: OrderedDict{A, SampleableNode{A, T}}
    logprob_sum :: Float64
end</code></pre><p>Trace that can hold nodes of the specific address (<code>A</code>) and value (<code>T</code>) types.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.UntypedTrace" href="#CrimsonSkyline.UntypedTrace"><code>CrimsonSkyline.UntypedTrace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct UntypedTrace
    trace :: OrderedDict{Any, Node}
    logprob_sum :: Float64
end</code></pre><p>Trace that can hold nodes with all address and value types. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.aic-Tuple{Trace}" href="#CrimsonSkyline.aic-Tuple{Trace}"><code>CrimsonSkyline.aic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function aic(t :: Trace)</code></pre><p>Computes the Akaike Information Criterion for a <em>single trace</em> (thus replacing the definition) with  &quot;maximum likelihood&quot; by one with &quot;likelihood&quot;. The formula is </p><p class="math-container">\[\text{AIC}(t)/2 = |\text{params}(t)| - \ell(t),\]</p><p>where <span>$\text{params}(t)|$</span> is the number of non-observed and non-deterministic sample nodes.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.connect_pa_ch!-Tuple{Trace, Any, Any}" href="#CrimsonSkyline.connect_pa_ch!-Tuple{Trace, Any, Any}"><code>CrimsonSkyline.connect_pa_ch!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function connect_pa_ch!(t :: Trace, pa, a)</code></pre><p>Connects parent and child nodes. Adds child nodes to parent&#39;s <code>ch</code> and  parent nodes to child&#39;s <code>pa</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.input-Tuple{Trace, Any, Any}" href="#CrimsonSkyline.input-Tuple{Trace, Any, Any}"><code>CrimsonSkyline.input</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">input(t :: Trace, a, d)</code></pre><p>Track a model input. Used only in graph intermediate representation and factor  graph.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.interpret_latent!-Tuple{Trace, CrimsonSkyline.Interpretation}" href="#CrimsonSkyline.interpret_latent!-Tuple{Trace, CrimsonSkyline.Interpretation}"><code>CrimsonSkyline.interpret_latent!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function interpret_latent!(t :: Trace, i :: Interpretation)</code></pre><p>Changes the interpretation of all latent nodes in <code>t</code> to have <code>interpretation == i</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.loglikelihood-Tuple{Trace}" href="#CrimsonSkyline.loglikelihood-Tuple{Trace}"><code>CrimsonSkyline.loglikelihood</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function loglikelihood(t :: Trace)</code></pre><p>Computes and returns the log likelihood of the observed data under the model:</p><p class="math-container">\[\ell(t) = 
\sum_{a:\ [a \in \text{keys}(t)] \wedge [\text{interpretation}(a) = \text{Standard}]} 
\log p(t[a])\]</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.logprob!-Tuple{Trace}" href="#CrimsonSkyline.logprob!-Tuple{Trace}"><code>CrimsonSkyline.logprob!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function logprob!(t :: Trace)</code></pre><p>Computes the joint log probability to the trace and assigns it to <code>t.logprob_sum</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.logprob-Tuple{Trace}" href="#CrimsonSkyline.logprob-Tuple{Trace}"><code>CrimsonSkyline.logprob</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function logprob(t :: Trace)</code></pre><p>Computes and returns the joint log probability of the trace:</p><p class="math-container">\[\log p(t) = \sum_{a \in \text{keys}(t)}\log p(t[a])\]</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{Any, A, D, Bool, CrimsonSkyline.Interpretation}} where {A, D&lt;:Distributions.Sampleable}" href="#CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{Any, A, D, Bool, CrimsonSkyline.Interpretation}} where {A, D&lt;:Distributions.Sampleable}"><code>CrimsonSkyline.node</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function node(value, address :: A, dist :: D, is_obs :: Bool, i :: Interpretation) where {A, D}</code></pre><p>Outer constructor for <code>Node</code> where data is passed during construction. Data type is inferred from the passed data.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{Any, A, D, Bool, CrimsonSkyline.Interpretation}} where {A, D}" href="#CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{Any, A, D, Bool, CrimsonSkyline.Interpretation}} where {A, D}"><code>CrimsonSkyline.node</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function node(value, address :: A, dist :: D, is_obs :: Bool, i :: Interpretation) where {A, D}</code></pre><p>Outer constructor for <code>Node</code> where data is passed during construction. Data type is inferred from the passed data.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{DataType, A, D, Bool, CrimsonSkyline.Interpretation}} where {A, D&lt;:Distributions.Sampleable}" href="#CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{DataType, A, D, Bool, CrimsonSkyline.Interpretation}} where {A, D&lt;:Distributions.Sampleable}"><code>CrimsonSkyline.node</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function node(T :: DataType, address :: A, dist :: D, is_obs :: Bool, i :: Interpretation) where {A, D}</code></pre><p>Outer constructor for <code>Node</code> where no data is passed during construction. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{DataType, A, D, Bool, CrimsonSkyline.Interpretation}} where {A, D}" href="#CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{DataType, A, D, Bool, CrimsonSkyline.Interpretation}} where {A, D}"><code>CrimsonSkyline.node</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function node(T :: DataType, address :: A, dist :: D, is_obs :: Bool, i :: Interpretation) where {A, D}</code></pre><p>Outer constructor for <code>Node</code> where no data is passed during construction. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.observe-Tuple{Trace, Any, Any, Any}" href="#CrimsonSkyline.observe-Tuple{Trace, Any, Any, Any}"><code>CrimsonSkyline.observe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function observe(t :: Trace, a, d, s; pa = ())</code></pre><p>If <code>d</code> is not <code>nothing</code> an alias for calling <code>sample</code> with standard interpretation.  Otherwise, an alias for calling <code>sample</code> with nonstandard interpretation. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.pa_from_trace-Tuple{Trace, Any}" href="#CrimsonSkyline.pa_from_trace-Tuple{Trace, Any}"><code>CrimsonSkyline.pa_from_trace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function pa_from_trace(t :: Trace, pa)</code></pre><p>Collects nodes in trace corresponding to an iterable of parent addresses <code>pa</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.plate-Union{Tuple{F}, Tuple{Trace, F, Any, Any, Int64, Conditioned}} where F&lt;:Function" href="#CrimsonSkyline.plate-Union{Tuple{F}, Tuple{Trace, F, Any, Any, Int64, Conditioned}} where F&lt;:Function"><code>CrimsonSkyline.plate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function plate(t::Trace, op::F, a, d, s::Int64, i::Conditioned; pa = ()) where F&lt;:Function</code></pre><p>Plate over conditioned variables.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.plate-Union{Tuple{F}, Tuple{Trace, F, Any, Any, Int64, CrimsonSkyline.Blocked}} where F&lt;:Function" href="#CrimsonSkyline.plate-Union{Tuple{F}, Tuple{Trace, F, Any, Any, Int64, CrimsonSkyline.Blocked}} where F&lt;:Function"><code>CrimsonSkyline.plate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function plate(t::Trace, op::F, a, d, s::Int64, i::Blocked; pa = ()) where F&lt;:Function</code></pre><p>Plate over blocked variables.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.plate-Union{Tuple{F}, Tuple{Trace, F, Any, Any, Int64, Nonstandard}} where F&lt;:Function" href="#CrimsonSkyline.plate-Union{Tuple{F}, Tuple{Trace, F, Any, Any, Int64, Nonstandard}} where F&lt;:Function"><code>CrimsonSkyline.plate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function plate(t::Trace, op::F, a, d, s::Int64, i::Nonstandard; pa = ()) where F&lt;:Function</code></pre><p>Plate over latent variables.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.plate-Union{Tuple{F}, Tuple{Trace, F, Any, Any, Int64, Replayed}} where F&lt;:Function" href="#CrimsonSkyline.plate-Union{Tuple{F}, Tuple{Trace, F, Any, Any, Int64, Replayed}} where F&lt;:Function"><code>CrimsonSkyline.plate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function plate(t::Trace, op::F, a, d, s::Int64, i::Replayed; pa = ()) where F&lt;:Function</code></pre><p>Plate over replayed variables. Note that this method assumes <em>and does not check</em> that the value to be replayed <code>v</code> satisfies <code>length(v) == s</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.plate-Union{Tuple{F}, Tuple{Trace, F, Any, Any, Int64}} where F&lt;:Function" href="#CrimsonSkyline.plate-Union{Tuple{F}, Tuple{Trace, F, Any, Any, Int64}} where F&lt;:Function"><code>CrimsonSkyline.plate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function plate(t::Trace, op::F, a, d, s::Int64; pa = ()) where F&lt;:Function</code></pre><p>Sample or observe a vector of random variables at a single site instead of multiple. This can speed up inference since the number of sites in the model will no longer scale with dataset size (though numerical value computation is still linear in dataset size).</p><p>Example usage: instead of</p><pre><code class="language-none">vals = [sample(t, &quot;val $i&quot;, Geometric()) for i in 1:N]</code></pre><p>we can write </p><pre><code class="language-none">vals = plate(t, sample, &quot;val&quot;, Geometric(), N)</code></pre><p>Mathematically, this is equivalent to the product <span>$p(z) = \prod_n p(z_n)$</span> and treating it as the single object <span>$p(z)$</span> instead of the <span>$N$</span> objects <span>$p(z_n)$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.plate-Union{Tuple{F}, Tuple{T}, Tuple{Trace, F, Any, Any, Vector{T}}} where {T, F&lt;:Function}" href="#CrimsonSkyline.plate-Union{Tuple{F}, Tuple{T}, Tuple{Trace, F, Any, Any, Vector{T}}} where {T, F&lt;:Function}"><code>CrimsonSkyline.plate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function plate(t::Trace, op::F, a, d, v::Vector{T}; pa = ()) where {T, F&lt;:Function}</code></pre><p>Plate over observed variables, i.e., a plated component of model likelihood. <code>v</code> is the  vector of observations, while <code>op</code> is likely <code>observe</code>.</p><p>Example usage: instead of</p><pre><code class="language-none">for (i, d) in enumerate(data)
    observe(t, &quot;data $i&quot;, Normal(loc, scale), d)
end</code></pre><p>we can write </p><pre><code class="language-none">plate(t, observe, &quot;data&quot;, Normal(loc, scale), data)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.propose-Tuple{Trace, Any, Any}" href="#CrimsonSkyline.propose-Tuple{Trace, Any, Any}"><code>CrimsonSkyline.propose</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">propose(t :: Trace, a, d)</code></pre><p>Propose a value for the address <code>a</code> in trace <code>t</code> from the distribution <code>d</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, CrimsonSkyline.Blocked}" href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, CrimsonSkyline.Blocked}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, d, params, i :: Blocked; pa = ())</code></pre><p>Samples from <code>d</code> passing the optional arguments <code>params</code>, deletes the node stored at address <code>a</code> from trace <code>t</code>, and returns the sampled value. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, Deterministic}" href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, Deterministic}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, f, v, i :: Deterministic; pa = ())</code></pre><p>Creates a deterministic node mapping the tuple of data <code>v</code> through function <code>f</code>,  storing the value in trace <code>t</code> at address <code>a</code>.</p><ol><li>Infers input type from <code>v</code></li><li>Maps tuple of data <code>v</code> through function <code>f</code>, yielding <code>r = f(v...)</code></li><li>Creates a deterministic node and stores it in <code>t</code> at address <code>a</code></li><li>Optionally adds nodes corresponding to the addresses in <code>pa</code> as parent nodes</li><li>Returns <code>r</code></li></ol></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, Nonstandard}" href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, Nonstandard}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, d, params, i :: Nonstandard; pa = ())</code></pre><p>Samples from distribution <code>d</code> into trace <code>t</code> at address <code>a</code>.</p><ol><li>Samples a value from <code>d</code> passing the optional arguments <code>params</code></li><li>Creates a sample node</li><li>Adds the sample node to trace <code>t</code> at value <code>a</code></li><li>Optionally adds nodes corresponding to the addresses in <code>pa</code> as parent nodes</li><li>Returns the sampled value</li></ol></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, Replayed}" href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, Replayed}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, d, params, i :: Replayed; pa = ())</code></pre><p>Replays the sampled node through the trace. </p><ol><li>If <code>a</code> is not in <code>t</code>&#39;s address set, calls <code>sample(t, a, d, NONSTANDARD; pa = pa)</code>. </li><li>Creates a sample node that copies the value from the last node stored in the trace at address <code>a</code>. </li><li>Adds the sample node to trace <code>t</code> at value <code>a</code></li><li>Optionally adds nodes corresponding to the addresses in <code>pa</code> as parent nodes</li><li>Resets the node&#39;s interpretation to the original interpretation</li></ol></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, Standard}" href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, Standard}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, d, s, i :: Standard; pa = ())</code></pre><p>Scores an observed value <code>s</code> against the distribution <code>d</code>, storing the value in trace <code>t</code> at  address <code>a</code> and optionally adds nodes corresponding to the addresses in <code>pa</code> as parent nodes.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, Vector{CrimsonSkyline.Interpretation}}" href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, Vector{CrimsonSkyline.Interpretation}}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, d, params, ii :: Array{Interpretation, 1}; pa = ())</code></pre><p>Sequentially apply sample statements with interpretations as given in <code>ii</code>. This is  used to depth-first traverse the interpretation graph.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any}" href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, d, params; pa = ())</code></pre><p>If <code>a</code> is in the set of trace addresses, calls <code>sample</code> using <code>t[a]</code>&#39;s interpretation.  Otherwise, calls <code>sample</code> using nonstandard interpretation. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace, Any, Any, CrimsonSkyline.Blocked}" href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, CrimsonSkyline.Blocked}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, d, i :: Blocked; pa = ())</code></pre><p>Samples from <code>d</code>, deletes the node stored at address <code>a</code> from trace <code>t</code>, and returns the  sampled value. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace, Any, Any, Nonstandard}" href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Nonstandard}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, d, i :: Nonstandard; pa = ())</code></pre><p>Samples from distribution <code>d</code> into trace <code>t</code> at address <code>a</code>.</p><ol><li>Samples a value from <code>d</code></li><li>Creates a sample node</li><li>Adds the sample node to trace <code>t</code> at value <code>a</code></li><li>Optionally adds nodes corresponding to the addresses in <code>pa</code> as parent nodes</li><li>Returns the sampled value</li></ol></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace, Any, Any, Replayed}" href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Replayed}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, d, i :: Replayed; pa = ())</code></pre><p>Replays the sampled node through the trace. </p><ol><li>If <code>a</code> is not in <code>t</code>&#39;s address set, calls <code>sample(t, a, d, NONSTANDARD; pa = pa)</code>. </li><li>Creates a sample node that copies the value from the last node stored in the trace at address <code>a</code>. </li><li>Adds the sample node to trace <code>t</code> at value <code>a</code></li><li>Optionally adds nodes corresponding to the addresses in <code>pa</code> as parent nodes</li><li>Resets the node&#39;s interpretation to the original interpretation</li></ol></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace, Any, Any, Union{Conditioned, Standard}}" href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Union{Conditioned, Standard}}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, d, i :: Union{Standard,Conditioned}; pa = ())</code></pre><p>Scores an observed value against the distribution <code>d</code>, storing the value in trace <code>t</code> at  address <code>a</code> and optionally adds nodes corresponding to the addresses in <code>pa</code> as parent nodes.</p><p>This method is used by the <code>condition</code> effect. It will probably not be used by most  users.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace, Any, Any, Vector{CrimsonSkyline.Interpretation}}" href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Vector{CrimsonSkyline.Interpretation}}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, d, ii :: Array{Interpretation, 1}; pa = ())</code></pre><p>Sequentially apply sample statements with interpretations as given in <code>ii</code>. This is  used to depth-first traverse the interpretation graph.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace, Any, Any}" href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, d; pa = ())</code></pre><p>If <code>a</code> is in the set of trace addresses, calls <code>sample</code> using <code>t[a]</code>&#39;s interpretation.  Otherwise, calls <code>sample</code> using nonstandard interpretation. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.trace-Tuple{Any, Any}" href="#CrimsonSkyline.trace-Tuple{Any, Any}"><code>CrimsonSkyline.trace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">trace(A, T)</code></pre><p>This is the recommended way to construct a new typed trace. <code>A</code> is the address type, <code>T</code> is the value type.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.trace-Tuple{}" href="#CrimsonSkyline.trace-Tuple{}"><code>CrimsonSkyline.trace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">trace()</code></pre><p>This is the recommended way to construct a new trace.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.transform-Union{Tuple{F}, Tuple{Trace, Any, F, Any}} where F&lt;:Function" href="#CrimsonSkyline.transform-Union{Tuple{F}, Tuple{Trace, Any, F, Any}} where F&lt;:Function"><code>CrimsonSkyline.transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function transform(t :: Trace, a, f :: F, v; pa = ()) where F &lt;: Function</code></pre><p>Alias for <code>sample(t, a, f, v, DETERMINISTIC; pa = pa)</code>.</p></div></section></article><h2 id="io"><a class="docs-heading-anchor" href="#io">io</a><a id="io-1"></a><a class="docs-heading-anchor-permalink" href="#io" title="Permalink"></a></h2><p>Saving and loading traces and <code>SamplingResults</code> is possible using the <code>save</code> and <code>load</code> functions. This functionality depends on <code>JuliaDB</code>. </p><p>Examples: </p><pre><code class="language-none"># simple example model
function io_model(t::Trace, dim::Int64, data::Int64)
    z = sample(t, &quot;z&quot;, Dirichlet(ones(dim)))
    observe(t, &quot;x&quot;, Categorical(z), data)
end

# saving a trace
t = trace()
dim = 10
data = 7
io_model(t, dim, data)
testpath = joinpath(@__DIR__, &quot;TESTIO&quot;)
db_file = joinpath(testpath, &quot;test.jdb&quot;)
save(t, db_file)

# loading a trace
loaded_trace = load(db_file)

# creating and saving some results
results = mh(io_model; params = (dim, data), burn = 0, thin = 1, num_iterations=10)
results_file = joinpath(testpath, &quot;io_model.csm&quot;)
save(results, results_file)

# loading saved results and use to serve model
loaded_results = load(joinpath(testpath, &quot;io_model.csm&quot;))
updated_model = update(io_model, loaded_results)  # update effect, see effects.jl
new_t, _ = updated_model(trace(), dim, data)</code></pre><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.load-Tuple{Any}" href="#CrimsonSkyline.load-Tuple{Any}"><code>CrimsonSkyline.load</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function load(f)</code></pre><p>Load a <code>Trace</code> or <code>SamplingResults</code> object from file. The file must be saved in JuliaDB format with ending <code>.jdb</code>, which will be interpreted as a single saved trace, or must be a directory with ending <code>.csm</code>, which will be interpreted as a <code>SamplingResults</code> object.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.load_csm-Tuple{Any}" href="#CrimsonSkyline.load_csm-Tuple{Any}"><code>CrimsonSkyline.load_csm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function load_csm(f) :: SamplingResults</code></pre><p>Loads a <code>SamplingResults</code> from a directory. The directory contains <code>metadata.txt</code>, which currently stores the interpretation of the <code>SamplingResults</code> (i.e., what kind of  algorithm generated those results), and a file <code>results.jdb</code>, which is a JuliaDB table of the results.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.load_jdb-Tuple{Any}" href="#CrimsonSkyline.load_jdb-Tuple{Any}"><code>CrimsonSkyline.load_jdb</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function load_jdb(f) :: Trace</code></pre><p>Loads a serialized juliadb table from file <code>f</code> and converts it into a trace.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.save-Tuple{CrimsonSkyline.SamplingResults, Any}" href="#CrimsonSkyline.save-Tuple{CrimsonSkyline.SamplingResults, Any}"><code>CrimsonSkyline.save</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function save(r :: SamplingResults, f)</code></pre><p>Saves a <code>SamplingResults</code> to disk in the directory <code>f</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.save-Tuple{Trace, Any}" href="#CrimsonSkyline.save-Tuple{Trace, Any}"><code>CrimsonSkyline.save</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function save(t :: Trace, f)</code></pre><p>Saves a trace to disk at the filepath <code>f</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.to_table-Tuple{Trace}" href="#CrimsonSkyline.to_table-Tuple{Trace}"><code>CrimsonSkyline.to_table</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function to_table(t :: Trace)</code></pre><p>Turns a trace into a juliadb table. Does not store parent / child relationships.</p></div></section></article><h2 id="effects"><a class="docs-heading-anchor" href="#effects">effects</a><a id="effects-1"></a><a class="docs-heading-anchor-permalink" href="#effects" title="Permalink"></a></h2><p>A library of functions that change the interpretation of some or all nodes in a trace.</p><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.block-Tuple{Any, Trace}" href="#CrimsonSkyline.block-Tuple{Any, Trace}"><code>CrimsonSkyline.block</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">block(f :: F, t :: Trace) where F &lt;: Function</code></pre><p>Converts all traced randomness into untraced randomness.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.block-Union{Tuple{T}, Tuple{Any, T, Any}} where T&lt;:Trace" href="#CrimsonSkyline.block-Union{Tuple{T}, Tuple{Any, T, Any}} where T&lt;:Trace"><code>CrimsonSkyline.block</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function block(f, t :: T, addresses) where T &lt;: Trace</code></pre><p>Given a stochastic function <code>f</code>, a trace <code>t</code>, and an iterable of addresses, converts traced randomness into untraced randomness. </p><p>Returns a tuple <code>(t_new, g)</code>, where <code>t_new</code> is a trace and <code>g</code> is a function. The function signature of <code>g</code> is the same as that of <code>f</code> with the first argument removed; that is, if <code>f(t :: Trace, params...)</code>, then <code>g(params...)</code>. Computation is delayed, so each of  the latent nodes in <code>t_new</code> has <code>interpretation = BLOCKED</code>. Calling <code>g(params...)</code> executes the  computation and each latent node in <code>t_new</code> with an address in <code>addresses</code> is removed.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.condition-Tuple{Any, Dict}" href="#CrimsonSkyline.condition-Tuple{Any, Dict}"><code>CrimsonSkyline.condition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function condition(f, evidence :: Dict)</code></pre><p>Condition a trace modified by <code>f</code> on <code>evidence</code>, which maps addresses to observed  evidence associated with that address. Returns a function with call signature  identical to that of <code>f</code> and return signature <code>(t :: Trace, rtype)</code> where <code>rtype</code> is the return type of <code>f</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.replace-Tuple{Any, Dict}" href="#CrimsonSkyline.replace-Tuple{Any, Dict}"><code>CrimsonSkyline.replace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function replace(f, r :: Dict)</code></pre><p>Given a mapping <code>r</code> from addresses to distribution-like (currently <code>Distributions</code> or <code>Array{Any, 1}</code>s), replaces the current distributions at that set of addresses with this set of distributions. Returns a function <code>g</code> that has return signature  <code>(t :: Trace, rval)</code> where <code>rval</code> is a return value of <code>f</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.replace-Union{Tuple{T}, Tuple{T, Dict}} where T&lt;:Trace" href="#CrimsonSkyline.replace-Union{Tuple{T}, Tuple{T, Dict}} where T&lt;:Trace"><code>CrimsonSkyline.replace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function replace(t :: Trace, r :: Dict)</code></pre><p>Given a mapping <code>r</code> from addresses to distribution-like (currently <code>Distributions</code> or <code>Array{Any, 1}</code>s), replaces the current distributions at that set of addresses with this set of distributions. Returns the modified trace.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.replay-Union{Tuple{T}, Tuple{Any, T}} where T&lt;:Trace" href="#CrimsonSkyline.replay-Union{Tuple{T}, Tuple{Any, T}} where T&lt;:Trace"><code>CrimsonSkyline.replay</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function replay(f, t :: T) where T &lt;: Trace</code></pre><p>Given a stochastic function <code>f</code> and a trace <code>t</code>, makes <code>sample</code> calls behave as though  they had sampled the values in <code>t</code> at the corresponding addresses. </p><p>Returns a tuple <code>(t_new, g)</code>, where <code>t_new</code> is a trace and <code>g</code> is a function. The function signature of <code>g</code> is the same as that of <code>f</code> with the first argument removed; that is, if <code>f(t :: Trace, params...)</code>, then <code>g(params...)</code>. Computation is delayed, so each of the latent nodes in <code>t_new</code> has <code>interpretation = REPLAYED</code>. Calling <code>g(params...)</code> executes the computation and each latent node in <code>t_new</code> reverts to  its original interpretation. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.rewrite-Union{Tuple{T}, Tuple{Any, T, Dict}} where T&lt;:Trace" href="#CrimsonSkyline.rewrite-Union{Tuple{T}, Tuple{Any, T, Dict}} where T&lt;:Trace"><code>CrimsonSkyline.rewrite</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function rewrite(f, t :: T, r :: Dict) where T &lt;: Trace</code></pre><p>Rewrites the history of the trace to make it appear as if the values in the trace were sampled at the addresses in the keys of <code>r</code> from the corresponding distributions in the values of <code>r</code>.  Returns a function with call signature <code>g(params...)</code> that returns <code>(t :: Trace, rval)</code>, where <code>rval</code>  is the return type of <code>f</code>. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.update-Union{Tuple{I}, Tuple{Any, CrimsonSkyline.SamplingResults{I}}} where I&lt;:CrimsonSkyline.InferenceType" href="#CrimsonSkyline.update-Union{Tuple{I}, Tuple{Any, CrimsonSkyline.SamplingResults{I}}} where I&lt;:CrimsonSkyline.InferenceType"><code>CrimsonSkyline.update</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function update(f, r :: SamplingResults{I}) where I &lt;: InferenceType</code></pre><p>Given a stochastic function <code>f</code> and a <code>SamplingResults</code> <code>r</code>, update the prior  predictive to the posterior predictive by jointly replacing all latent sample sites with the joint empirical  posterior. Returns a stochastic function <code>g</code> with the same call signature as <code>f</code>. This function will modify in  place the trace passed into it as the first argument.</p></div></section></article><h2 id="basic-sampling-methods"><a class="docs-heading-anchor" href="#basic-sampling-methods">basic sampling methods</a><a id="basic-sampling-methods-1"></a><a class="docs-heading-anchor-permalink" href="#basic-sampling-methods" title="Permalink"></a></h2><p>Simple samplers such as forward and rejection sampling can be done &quot;by hand&quot;, but convenience methods are implemented to facilitate postprocessing of results.</p><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.forward_sampling-Tuple{Any}" href="#CrimsonSkyline.forward_sampling-Tuple{Any}"><code>CrimsonSkyline.forward_sampling</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function forward_sampling(f; params = (), num_iterations = 1)</code></pre><p>Draws samples from the model&#39;s joint density. Equivalent to calling <code>f</code> in a loop <code>num_iterations</code> times, but results are collected in a  <code>NonparametricSamplingResults</code> for easier postprocessing.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.rejection-Tuple{Any, Float64, Vararg{Any, N} where N}" href="#CrimsonSkyline.rejection-Tuple{Any, Float64, Vararg{Any, N} where N}"><code>CrimsonSkyline.rejection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function rejection(f, log_l :: Float64, params...)</code></pre><p>Samples from the prior with the hard likelihood constraint <span>$\log L_k &gt;$</span> <code>log_l</code>.</p><p>Args:</p><ul><li><code>f</code> stochastic function. Must have signature <code>f(t :: Trace, params...)</code></li><li><code>log_l</code>: current log likelihood threshold </li><li><code>params</code>: any additional arguments to pass to <code>f</code></li></ul></div></section></article><h2 id="importance"><a class="docs-heading-anchor" href="#importance">importance</a><a id="importance-1"></a><a class="docs-heading-anchor-permalink" href="#importance" title="Permalink"></a></h2><p>Importance sampling algorithms and utilities.  Currently the following importance sampling algorithms are implemented:</p><ul><li>Likelihood weighting</li><li>Generic user-defined proposal</li></ul><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.importance_sampling-Tuple{Any, Any, Tuple{DataType, DataType}}" href="#CrimsonSkyline.importance_sampling-Tuple{Any, Any, Tuple{DataType, DataType}}"><code>CrimsonSkyline.importance_sampling</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function importance_sampling(f, q, types::Tuple{DataType,DataType}; params = (), nsamples :: Int = 1)</code></pre><p>Given a stochastic function <code>f</code>, a proposal function <code>q</code>, and a tuple of <code>params</code> to pass to <code>f</code> and <code>q</code>, compute <code>nsamples</code> iterations of importance sampling. <code>q</code> must have the same input signature  as <code>f</code>. Returns a <code>SamplingResults</code> instance.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.importance_sampling-Tuple{Any, Any}" href="#CrimsonSkyline.importance_sampling-Tuple{Any, Any}"><code>CrimsonSkyline.importance_sampling</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function importance_sampling(f, q; params = (), nsamples :: Int = 1)</code></pre><p>Given a stochastic function <code>f</code>, a proposal function <code>q</code>, and a tuple of <code>params</code> to pass to <code>f</code> and <code>q</code>, compute <code>nsamples</code> iterations of importance sampling. <code>q</code> must have the same input signature  as <code>f</code>. Returns a <code>SamplingResults</code> instance.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.is_step-Tuple{Any, Any, Tuple{DataType, DataType}}" href="#CrimsonSkyline.is_step-Tuple{Any, Any, Tuple{DataType, DataType}}"><code>CrimsonSkyline.is_step</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function is_step(f, q, types::Tuple{DataType,DataType}; params = ())</code></pre><p>Perform one step of importance sampling – draw a single sample from the proposal <code>q</code>, replay  it through <code>f</code>, and record the log weight as <span>$\log W_n = \log p(x, z_n) - \log q(z_n)$</span>. Returns a tuple (log weight, rval, trace). </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.is_step-Tuple{Any, Any}" href="#CrimsonSkyline.is_step-Tuple{Any, Any}"><code>CrimsonSkyline.is_step</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function is_step(f, q; params = ())</code></pre><p>Perform one step of importance sampling – draw a single sample from the proposal <code>q</code>, replay  it through <code>f</code>, and record the log weight as <span>$\log W_n = \log p(x, z_n) - \log q(z_n)$</span>. Returns a tuple (log weight, rval, trace). </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.likelihood_weighting-Tuple{Any, Tuple{DataType, DataType}, Vararg{Any, N} where N}" href="#CrimsonSkyline.likelihood_weighting-Tuple{Any, Tuple{DataType, DataType}, Vararg{Any, N} where N}"><code>CrimsonSkyline.likelihood_weighting</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function likelihood_weighting(f, types::Tuple{DataType, DataType}, params...; nsamples :: Int = 1)</code></pre><p>Given a stochastic function f and arguments to the function <code>params...</code>, executes <code>nsamples</code> iterations of importance sampling by using the prior as a proposal distribution. The importance weights are given by <span>$\log W_n = \ell(t_n)$</span>. Returns an <code>SamplingResults</code> instance. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.likelihood_weighting-Tuple{Any, Vararg{Any, N} where N}" href="#CrimsonSkyline.likelihood_weighting-Tuple{Any, Vararg{Any, N} where N}"><code>CrimsonSkyline.likelihood_weighting</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function likelihood_weighting(f, params...; nsamples :: Int = 1)</code></pre><p>Given a stochastic function f and arguments to the function <code>params...</code>, executes <code>nsamples</code> iterations of importance sampling by using the prior as a proposal distribution. The importance weights are given by <span>$\log W_n = \ell(t_n)$</span>. Returns an <code>SamplingResults</code> instance. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.likelihood_weighting_results-Tuple{}" href="#CrimsonSkyline.likelihood_weighting_results-Tuple{}"><code>CrimsonSkyline.likelihood_weighting_results</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">likelihood_weighting_results()</code></pre><p>Outer constructor for <code>SamplingResults</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.log_evidence-Union{Tuple{CrimsonSkyline.SamplingResults{I}}, Tuple{I}} where I&lt;:CrimsonSkyline.Importance" href="#CrimsonSkyline.log_evidence-Union{Tuple{CrimsonSkyline.SamplingResults{I}}, Tuple{I}} where I&lt;:CrimsonSkyline.Importance"><code>CrimsonSkyline.log_evidence</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function log_evidence(r :: SamplingResults{LikelihoodWeighting})</code></pre><p>Computes the log evidence (log partition function), </p><p><span>$\log Z \equiv \log p(x) \approx -\log N_{\text{samples}} + \log \sum_{n=1}^{N_{\text{samples}}} W_n.$</span></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.lw_step-Tuple{Any, Tuple{DataType, DataType}, Vararg{Any, N} where N}" href="#CrimsonSkyline.lw_step-Tuple{Any, Tuple{DataType, DataType}, Vararg{Any, N} where N}"><code>CrimsonSkyline.lw_step</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function lw_step(f, types::Tuple{DataType, DataType}, params...)</code></pre><p>Perform one step of likelihood weighting – draw a single proposal from the prior and compute  the log weight as equal to the likelihood. Returns a tuple (log weight, rval, trace).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.lw_step-Tuple{Any, Vararg{Any, N} where N}" href="#CrimsonSkyline.lw_step-Tuple{Any, Vararg{Any, N} where N}"><code>CrimsonSkyline.lw_step</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function lw_step(f, params...)</code></pre><p>Perform one step of likelihood weighting – draw a single proposal from the prior and compute  the log weight as equal to the likelihood. Returns a tuple (log weight, rval, trace).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.normalized_weights-Union{Tuple{CrimsonSkyline.SamplingResults{I}}, Tuple{I}} where I&lt;:CrimsonSkyline.Importance" href="#CrimsonSkyline.normalized_weights-Union{Tuple{CrimsonSkyline.SamplingResults{I}}, Tuple{I}} where I&lt;:CrimsonSkyline.Importance"><code>CrimsonSkyline.normalized_weights</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function normalized_weights(r :: SamplingResults{LikelihoodWeighting})</code></pre><p>Computes the normalized weights <span>$w_n$</span> from unnormalized weights <span>$W_n$</span>:</p><p><span>$w_n = W_n / p(x) = \exp\{\ell(t_n) - \log Z\}.$</span></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Union{Tuple{I}, Tuple{CrimsonSkyline.SamplingResults{I}, Any, Int64}} where I&lt;:CrimsonSkyline.Importance" href="#CrimsonSkyline.sample-Union{Tuple{I}, Tuple{CrimsonSkyline.SamplingResults{I}, Any, Int64}} where I&lt;:CrimsonSkyline.Importance"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(r :: SamplingResults{LikelihoodWeighting}, k, n :: Int)</code></pre><p>Draws <code>n</code> samples from the empirical marginal posterior at address <code>k</code>.</p></div></section></article><h2 id="metropolis"><a class="docs-heading-anchor" href="#metropolis">metropolis</a><a id="metropolis-1"></a><a class="docs-heading-anchor-permalink" href="#metropolis" title="Permalink"></a></h2><p>Metropolis algorithm and utilities. Currently the following algorithms are implemented for both  FOPPL and HOPPL programs:</p><ul><li>Independent prior proposal</li><li>Arbitrary single- or multi-site proposal</li></ul><p>Here are two examples of inference using the arbitrary MH step interface. Consider the following generative function:</p><pre><code class="language-none">function normal_model(t :: Trace, data :: Vector{Float64})
    loc = sample(t, :loc, Normal(0.0, 10.0))
    scale = sample(t, :scale, LogNormal())
    for i in 1:length(data)
        observe(t, (:obs, i), Normal(loc, scale), data[i])
    end
end</code></pre><p>To learn an approximate posterior for <code>:loc</code> and <code>:scale</code>, we will introduce two proposal kernels:</p><pre><code class="language-none">loc_proposal(old_t :: Trace, new_t :: Trace, data) = propose(new_t, :loc, Normal(old_t[:loc].value, 0.25))
scale_proposal(old_t :: Trace, new_t :: Trace, data) = propose(new_t, :scale, truncated(Normal(old_t[:scale].value, 0.25), 0.0, Inf))</code></pre><p>Note that while <code>loc_proposal</code> is symmetric, <code>scale_proposal</code> is not. To perform inference, we pass these kernels to <code>mh_step</code> in  a loop after first drawing a random trace:</p><pre><code class="language-none">t = trace()
normal_model(t, data)
for i in 1:niter
    t = mh_step(t, normal_model, loc_proposal; params = (data,))
    t = mh_step(t, normal_model, scale_proposal; params = (data,))
end</code></pre><p>In this case, inference was fairly successful:</p><pre><code class="language-none">[ Info: True loc = 4.0
[ Info: True std = 1.0
[ Info: inferred E[loc] = 4.022688081613082
[ Info: inferred E[scale] = 0.9696559373495869
[ Info: approximate p(x) = sum_z p(x|z) = -138.63530736205144</code></pre><p>As a less trivial (but still contrived!) inference example, we can infer the posterior distribution of a latent discrete random variable in an open-universe model: </p><pre><code class="language-none">function random_sum_model(t :: Trace, data)
    n = sample(t, :n, Geometric(0.1))
    loc = 0.0
    for i in 1:(n + 1)
        loc += sample(t, (:loc, i), Normal())
    end
    obs = Array{Float64, 1}()
    for j in 1:length(data)
        o = observe(t, (:data, j), Normal(loc, 1.0), data[j])
        push!(obs, o)
    end
    obs
end</code></pre><p>(N.B.: we write the model is this form for pedagogic reasons; there is a far more efficient way to express the latent structure  of this model, namely <span>$n \sim \text{Geometric}(0.1)$</span>, <span>$\text{loc} \sim \text{Normal}(0, n)$</span>.) We are interested in learning the posterior distribution of <code>:n</code>. We introduce two proposal distributions, one for the latent discrete rv and another generic proposal for the location increments:</p><pre><code class="language-none">function random_n_proposal(old_trace, new_trace, params...)
    old_n = float(old_trace[:n].value)
    if old_n &gt; 0
        propose(new_trace, :n, Poisson(old_n))
    else
        propose(new_trace, :n, Poisson(1.0))
    end
end

gen_loc_proposal(old_trace, new_trace, ix, params...) = propose(new_trace, (:loc, ix), Normal(old_trace[(:loc, ix)].value, 0.25))</code></pre><p>We again conduct inference by simply applying proposals within a loop. This time, the number of location increment proposals we need to  construct is dependent on the sampled values of the latent random variable. We can either create these proposals on the fly as they&#39;re  needed or create what is nearly guaranteed to be enough of them before any inference is performed, e.g.,  <code>loc_proposals = [(o, n, params...) -&gt; gen_loc_proposal(o, n, i, params...) for i in 1:100]</code>. Now that we have what we need, we can conduct inference:</p><pre><code class="language-none">t = trace()
random_sum_model(t, data)
...
for i in 1:niter
    t = mh_step(t, random_sum_model, random_n_proposal; params=(data,))
    for j in 1:(t[:n].value + 1)
        t = mh_step(t, random_sum_model, loc_proposals[j]; params=(data,))
    end
    push!(ns, t[:n].value)
end</code></pre><p>Our inference results look promising:</p><pre><code class="language-none">[ Info: True :n = 9
[ Info: Posterior E[:n] = 7.581604598850287</code></pre><p>For more examples, check back soon.</p><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.accept-Tuple{Trace, Trace, Float64}" href="#CrimsonSkyline.accept-Tuple{Trace, Trace, Float64}"><code>CrimsonSkyline.accept</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function accept(t :: Trace, new_t :: Trace, log_a :: Float64)</code></pre><p>Stochastic function that either returns <code>new_t</code> if accepted or returns <code>t</code> if not accepted.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.copy_common!-Tuple{Trace, Trace}" href="#CrimsonSkyline.copy_common!-Tuple{Trace, Trace}"><code>CrimsonSkyline.copy_common!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function copy_common!(old_t :: Trace, new_t :: Trace)</code></pre><p>Copies nodes from <code>old_t</code> into <code>new_t</code> for all addresses in the intersection of their address sets. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.log_acceptance_ratio-Tuple{Trace, Trace, CrimsonSkyline.Prior}" href="#CrimsonSkyline.log_acceptance_ratio-Tuple{Trace, Trace, CrimsonSkyline.Prior}"><code>CrimsonSkyline.log_acceptance_ratio</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function log_acceptance_ratio(t :: Trace, t_proposed :: Trace, p :: Prior)</code></pre><p>Computes the log acceptance ratio of a Metropolis step when using the independent prior proposal  algorithm:</p><p><span>$\log \alpha = \ell(t_{\text{proposed}}) - \ell(t_{\text{original}})$</span></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.loglatent-Tuple{Trace}" href="#CrimsonSkyline.loglatent-Tuple{Trace}"><code>CrimsonSkyline.loglatent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function loglatent(t :: Trace)</code></pre><p>Computes the joint log probability of all latent variables in a trace, <span>$\log p(t) - \ell(t)$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.logprob-Tuple{Trace, Trace}" href="#CrimsonSkyline.logprob-Tuple{Trace, Trace}"><code>CrimsonSkyline.logprob</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function logprob(t0 :: Trace, t1 :: Trace)</code></pre><p>Computes the proposal log probability <span>$q(t_1 | t_0)$</span>.</p><p>This expression has two parts: log probability that is generated at the proposed site(s), and  log probability that is generated at the sites that are present in <code>t1</code> but not in <code>t0</code>. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.mh-Tuple{Any, Tuple{DataType, DataType}}" href="#CrimsonSkyline.mh-Tuple{Any, Tuple{DataType, DataType}}"><code>CrimsonSkyline.mh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function mh(f, types::Tuple{DataType, DataType}; params = (), burn = 1000, thin = 50, num_iterations = 10000)</code></pre><p>Generic Metropolis algorithm using draws from the prior.</p><p>Args:</p><ul><li><code>f</code>: stochastic function. Must have call signature <code>f(t :: Trace, params...)</code></li><li><code>params</code>: addditional arguments to pass to <code>f</code> and each of the proposal kernels.</li><li><code>burn</code>: number of samples to discard at beginning of markov chain</li><li><code>thin</code>: keep only every <code>thin</code>-th draw. E.g., if <code>thin = 100</code>, only every 100-th trace will be kept.</li><li><code>num_iterations</code>: total number of steps to take in the markov chain</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.mh-Tuple{Any}" href="#CrimsonSkyline.mh-Tuple{Any}"><code>CrimsonSkyline.mh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function mh(f; params = (), burn = 1000, thin = 50, num_iterations = 10000)</code></pre><p>Generic Metropolis algorithm using draws from the prior.</p><p>Args:</p><ul><li><code>f</code>: stochastic function. Must have call signature <code>f(t :: Trace, params...)</code></li><li><code>params</code>: addditional arguments to pass to <code>f</code> and each of the proposal kernels.</li><li><code>burn</code>: number of samples to discard at beginning of markov chain</li><li><code>thin</code>: keep only every <code>thin</code>-th draw. E.g., if <code>thin = 100</code>, only every 100-th trace will be kept.</li><li><code>num_iterations</code>: total number of steps to take in the markov chain</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.mh-Union{Tuple{A}, Tuple{Any, A, Tuple{DataType, DataType}}} where A&lt;:AbstractArray" href="#CrimsonSkyline.mh-Union{Tuple{A}, Tuple{Any, A, Tuple{DataType, DataType}}} where A&lt;:AbstractArray"><code>CrimsonSkyline.mh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function mh(f, qs :: A, types::Tuple{DataType,DataType}; params = (), burn = 100, thin = 10, num_iterations = 10000, inverse_verbosity = 100) where A &lt;: AbstractArray</code></pre><p>Generic Metropolis algorithm using user-defined proposal kernels.</p><p>Args:</p><ul><li><code>f</code>: stochastic function. Must have call signature <code>f(t :: Trace, params...)</code></li><li><code>qs</code>: array-like of proposal kernels. Proposal kernels are applied sequentially in the order that they appear in this array.   Proposal kernels must have the signature <code>q(old_t :: Trace, new_t :: Trace, params...)</code> where it must take in at least the same number of arguments   in <code>params</code> as <code>f</code>.</li><li><code>params</code>: addditional arguments to pass to <code>f</code> and each of the proposal kernels.</li><li><code>burn</code>: number of samples to discard at beginning of markov chain</li><li><code>thin</code>: keep only every <code>thin</code>-th draw. E.g., if <code>thin = 100</code>, only every 100-th trace will be kept.</li><li><code>num_iterations</code>: total number of steps to take in the markov chain</li><li><code>inverse_verbosity</code>: every <code>inverse_verbosity</code> iterations, a stattus report will be logged.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.mh-Union{Tuple{A}, Tuple{Any, A}} where A&lt;:AbstractArray" href="#CrimsonSkyline.mh-Union{Tuple{A}, Tuple{Any, A}} where A&lt;:AbstractArray"><code>CrimsonSkyline.mh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function mh(f, qs :: A; params = (), burn = 100, thin = 10, num_iterations = 10000, inverse_verbosity = 100) where A &lt;: AbstractArray</code></pre><p>Generic Metropolis algorithm using user-defined proposal kernels.</p><p>Args:</p><ul><li><code>f</code>: stochastic function. Must have call signature <code>f(t :: Trace, params...)</code></li><li><code>qs</code>: array-like of proposal kernels. Proposal kernels are applied sequentially in the order that they appear in this array.   Proposal kernels must have the signature <code>q(old_t :: Trace, new_t :: Trace, params...)</code> where it must take in at least the same number of arguments   in <code>params</code> as <code>f</code>.</li><li><code>params</code>: addditional arguments to pass to <code>f</code> and each of the proposal kernels.</li><li><code>burn</code>: number of samples to discard at beginning of markov chain</li><li><code>thin</code>: keep only every <code>thin</code>-th draw. E.g., if <code>thin = 100</code>, only every 100-th trace will be kept.</li><li><code>num_iterations</code>: total number of steps to take in the markov chain</li><li><code>inverse_verbosity</code>: every <code>inverse_verbosity</code> iterations, a stattus report will be logged.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.mh_step-Tuple{Trace, Any, Any, Tuple{DataType, DataType}}" href="#CrimsonSkyline.mh_step-Tuple{Trace, Any, Any, Tuple{DataType, DataType}}"><code>CrimsonSkyline.mh_step</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function mh_step(t :: Trace, f, q, types::Tuple{DataType,DataType}; params = (), return_val :: Bool = false)</code></pre><p>A generic Metropolis step using an arbitrary proposal kernel. </p><p>Given a trace <code>t</code>, a stochastic function <code>f</code> with signature <code>f(t :: Trace, params...)</code> a stochastic function  <code>q</code> with signature <code>q(old_trace :: Trace, new_trace :: Trace, params...)</code>, generates a proposal from <code>q</code> and  accepts based on the log acceptance probability:</p><p><span>$\log \alpha = \log p(t_{\text{new}}) - \log q(t_{\text{new}}|t_{\text{old}}) - [\log p(t_{\text{old}}) - \log q(t_{\text{old}} | t_{\text{new}})].$</span></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.mh_step-Tuple{Trace, Any, Any}" href="#CrimsonSkyline.mh_step-Tuple{Trace, Any, Any}"><code>CrimsonSkyline.mh_step</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function mh_step(t :: Trace, f, q; params = (), return_val :: Bool = false)</code></pre><p>A generic Metropolis step using an arbitrary proposal kernel. </p><p>Given a trace <code>t</code>, a stochastic function <code>f</code> with signature <code>f(t :: Trace, params...)</code> a stochastic function  <code>q</code> with signature <code>q(old_trace :: Trace, new_trace :: Trace, params...)</code>, generates a proposal from <code>q</code> and  accepts based on the log acceptance probability:</p><p><span>$\log \alpha = \log p(t_{\text{new}}) - \log q(t_{\text{new}}|t_{\text{old}}) - [\log p(t_{\text{old}}) - \log q(t_{\text{old}} | t_{\text{new}})].$</span></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.mh_step-Tuple{Trace, Any, Tuple{DataType, DataType}}" href="#CrimsonSkyline.mh_step-Tuple{Trace, Any, Tuple{DataType, DataType}}"><code>CrimsonSkyline.mh_step</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function mh_step(t :: Trace, f, types::Tuple{DataType, DataType}; params = (), return_val :: Bool = false)</code></pre><p>An independent prior sample Metropolis step.</p><p>Given a trace <code>t</code> and stochastic function <code>f</code> depending on <code>params...</code>, generates proposals  from prior draws and accepts based on the likelihood ratio.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.mh_step-Tuple{Trace, Any}" href="#CrimsonSkyline.mh_step-Tuple{Trace, Any}"><code>CrimsonSkyline.mh_step</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function mh_step(t :: Trace, f; params = (), return_val :: Bool = false)</code></pre><p>An independent prior sample Metropolis step.</p><p>Given a trace <code>t</code> and stochatic function <code>f</code> depending on <code>params...</code>, generates proposals  from prior draws and accepts based on the likelihood ratio.</p></div></section></article><h2 id="nested"><a class="docs-heading-anchor" href="#nested">nested</a><a id="nested-1"></a><a class="docs-heading-anchor-permalink" href="#nested" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.nested-Tuple{Any, Any}" href="#CrimsonSkyline.nested-Tuple{Any, Any}"><code>CrimsonSkyline.nested</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function nested(f, replace_fn; params = (), num_points :: Int64 = 1)</code></pre><p>Generic implementation of nested sampling (Skilling, Nested sampling for general Bayesian computation, Bayesian Analysis, 2006). The number of sampling iterations is a function of <code>num_points</code> aka <span>$N$</span>, and the empirical entropy of the sampling distribution, given at the <span>$n$</span>-th iteration by <span>$H_n \approx \sum_k \hat p_k \log \hat p_k^{-1}$</span>, where <span>$\hat p_k = L_k w_k / Z_k$</span>, <span>$L_k$</span> is the likelihood value, <span>$w_k$</span> is the difference in prior mass, and <span>$Z_k$</span> is the current estimate of the partition function. The number of sampling iterations is equal to <span>$\min_n \{n &gt; 0: n &gt; NH_n\}$</span>. </p><p>Args:</p><ul><li><code>f</code>: stochastic function. Must have signature <code>f(t :: Trace, params...)</code></li><li><code>replace_fn</code>: function that returns a tuple <code>(new_trace :: Trace, new_log_likelihood :: Float64)</code>. The input signature of this function   must be <code>replace_fn(f :: F, log_likelihood :: Float64, params...) where F &lt;: Function</code>. It must guarantee that <code>new_log_likelihood &gt; log_likelihood</code>.</li><li><code>params</code>: any parameters to pass to <code>f</code></li><li><code>num_points</code>: the number of likelihood points to keep track of</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.nested-Tuple{Any}" href="#CrimsonSkyline.nested-Tuple{Any}"><code>CrimsonSkyline.nested</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nested(f; params = (), num_points :: Int64 = 1)</code></pre><p>Run nested sampling using internal rejection method.</p></div></section></article><h2 id="results"><a class="docs-heading-anchor" href="#results">results</a><a id="results-1"></a><a class="docs-heading-anchor-permalink" href="#results" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.NonparametricSamplingResults" href="#CrimsonSkyline.NonparametricSamplingResults"><code>CrimsonSkyline.NonparametricSamplingResults</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct NonparametricSamplingResults{I} &lt;: SamplingResults{I}
    interpretation :: I
    log_weights :: Array{Float64, 1}
    return_values :: Array{Any, 1}
    traces :: Array{Trace, 1}
end</code></pre><p>Wrapper for results of sampling. Implements the following methods  from <code>Base</code>: <code>getindex</code>, <code>length</code>, <code>keys</code>. Intepretation of log weights is dependent on <code>I</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.ParametricSamplingResults" href="#CrimsonSkyline.ParametricSamplingResults"><code>CrimsonSkyline.ParametricSamplingResults</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ParametricSamplingResults{I} &lt;: SamplingResults{I}
    interpretation :: I
    log_weights :: Array{Float64, 1}
    return_values :: Array{Any, 1}
    traces :: Array{Trace, 1}
    distributions :: Dict
end</code></pre><p><code>distributions</code> maps from addresses to distributions, <span>$a \mapsto \pi^{(a)}_\psi(z)$</span>, where  <span>$\pi^{(a)}_\psi(z)$</span> solves</p><p class="math-container">\[\max_\psi E_{z \sim p(z|x)}[\log \pi^{(a)}_\psi(z)].\]</p><p>The distributions are not used to generate values but only to score sampled values; values are  still sampled from the posterior traces. Right now, the parametric approximation is very simple: values with support over the  negative orthant of  <span>$\mathbb R^D$</span> are approximated by (multivariate) normal distributions, while  values with support over only the positive orthant of <span>$\mathbb{R}^D$</span> are approximated by  (multivariate) lognormal distributions. This behavior is expected to change in the future.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.addresses-Union{Tuple{CrimsonSkyline.SamplingResults{I}}, Tuple{I}} where I&lt;:CrimsonSkyline.InferenceType" href="#CrimsonSkyline.addresses-Union{Tuple{CrimsonSkyline.SamplingResults{I}}, Tuple{I}} where I&lt;:CrimsonSkyline.InferenceType"><code>CrimsonSkyline.addresses</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function addresses(r::SamplingResults{I}) where I &lt;: InferenceType</code></pre><p>Get all addresses associated with the <code>SamplingResults</code> object, <span>$A = \bigcup_{t\in \text{traces}}\mathcal A_t$</span></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.aic-Union{Tuple{CrimsonSkyline.SamplingResults{I}}, Tuple{I}} where I&lt;:CrimsonSkyline.InferenceType" href="#CrimsonSkyline.aic-Union{Tuple{CrimsonSkyline.SamplingResults{I}}, Tuple{I}} where I&lt;:CrimsonSkyline.InferenceType"><code>CrimsonSkyline.aic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function aic(r :: SamplingResults{I}) where I &lt;: InferenceType</code></pre><p>Computes an empirical estimate of the Akaike Information Criterion from a <code>SamplingResults</code>. The formula is </p><p class="math-container">\[\text{AIC}(r)/2 = \min_{t \in \text{traces}(r)}|\text{params}(t)| - \hat\ell(t),\]</p><p>where <span>$|\text{params}(t)|$</span> is the number of non-observed and non-deterministic sample nodes and <span>$\hat\ell(t)$</span> is the empirical maximum likelihood.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Union{Tuple{I}, Tuple{Trace, Any, CrimsonSkyline.ParametricSamplingResults{I}}} where I&lt;:CrimsonSkyline.InferenceType" href="#CrimsonSkyline.sample-Union{Tuple{I}, Tuple{Trace, Any, CrimsonSkyline.ParametricSamplingResults{I}}} where I&lt;:CrimsonSkyline.InferenceType"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, r::ParametricSamplingResults{I}; pa = ()) where I &lt;: InferenceType</code></pre><p>Treat a marginal site of a <code>SamplingResults</code> as a distribution, sampling from it into a trace.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Union{Tuple{I}, Tuple{Trace, Any, NonparametricSamplingResults{I}}} where I&lt;:CrimsonSkyline.InferenceType" href="#CrimsonSkyline.sample-Union{Tuple{I}, Tuple{Trace, Any, NonparametricSamplingResults{I}}} where I&lt;:CrimsonSkyline.InferenceType"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, r :: NonparametricSamplingResults{I}; pa = ()) where I &lt;: InferenceType</code></pre><p>Treat a marginal site of a <code>SamplingResults</code> as a distribution, sampling from it into a trace.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.to_parametric-Union{Tuple{NonparametricSamplingResults{I}}, Tuple{I}} where I&lt;:CrimsonSkyline.InferenceType" href="#CrimsonSkyline.to_parametric-Union{Tuple{NonparametricSamplingResults{I}}, Tuple{I}} where I&lt;:CrimsonSkyline.InferenceType"><code>CrimsonSkyline.to_parametric</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function to_parametric(r::NonparametricSamplingResults{I}) where I&lt;:InferenceType</code></pre><p>Converts a nonparametric sampling results object into one that additionally contains a mapping from addresses to distributions. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Distributions.logpdf-Union{Tuple{A}, Tuple{A, Any}} where A&lt;:AbstractArray" href="#Distributions.logpdf-Union{Tuple{A}, Tuple{A, Any}} where A&lt;:AbstractArray"><code>Distributions.logpdf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function Distributions.logpdf(r :: A, v) where A &lt;: AbstractArray</code></pre><p>Interprets an array of objects as a delta distribution over those objects. If <code>v</code> is in the support set,  returns <span>$-log |r|$</span>. Otherwise, returns <span>$-\infty$</span>. </p></div></section></article><h2 id="online"><a class="docs-heading-anchor" href="#online">online</a><a id="online-1"></a><a class="docs-heading-anchor-permalink" href="#online" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.combine-Tuple{Any, Vector{Float64}}" href="#CrimsonSkyline.combine-Tuple{Any, Vector{Float64}}"><code>CrimsonSkyline.combine</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function combine(v, pv::Vector{Float64})</code></pre><p>Combines iterable of <code>ParametricSamplingResults</code>, <code>v</code>, into a single <code>ParametricSamplingResults</code> with mixture distribution parametric posteriors. <code>pv</code> is a weight vector (all elements &gt; 0) that assigns relative weight to the mixture components in each <code>ParametricSamplingResults</code>. Mathematically, for each address <span>$a$</span>, the resulting mixture distribution is</p><p class="math-container">\[p_a(z) = \sum_{r \in \mathtt{v}:\ a \in \mathcal{A}(r)} p^r_a(z)\  w^a_r,\]</p><p>where each <span>$p^r_a(z)$</span> is the <span>$r$</span>-th <code>ParametricSamplingResults</code>&#39;s estimated parametric posterior marginal for address <span>$a$</span>, if it exists, and  <span>$w^a_r = \mathtt{pv}_r \Big/ \left( \sum_{r \in \mathtt{v}:\ a \in \mathcal{A}(r)} \mathtt{pv}_r\right)$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.reflate!-Tuple{CrimsonSkyline.ParametricSamplingResults, Dict}" href="#CrimsonSkyline.reflate!-Tuple{CrimsonSkyline.ParametricSamplingResults, Dict}"><code>CrimsonSkyline.reflate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function reflate!(r::ParametricSamplingResults{I}, mapping::Dict) where I&lt;:InferenceType</code></pre><p>Reflates the scale parameters of the <code>distributions</code> of <code>r</code>. The inferred scale parameters  approximate the true uncertainty of the posterior distribution under the critical assumption that the data generating process (DGP) remains constant. When the DGP is nonstationary, it is necessary to intervene and increase the value of the scale parameters to properly  account for uncertainty. <code>mapping</code> is a dict of <code>address =&gt; value</code> where <code>value</code> is either a float or a positive definite matrix depending on if the distribution associated with <code>address</code> is scalar- or vector-valued. </p></div></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#CrimsonSkyline.NonparametricSamplingResults"><code>CrimsonSkyline.NonparametricSamplingResults</code></a></li><li><a href="#CrimsonSkyline.ParametricNode"><code>CrimsonSkyline.ParametricNode</code></a></li><li><a href="#CrimsonSkyline.ParametricSamplingResults"><code>CrimsonSkyline.ParametricSamplingResults</code></a></li><li><a href="#CrimsonSkyline.SampleableNode"><code>CrimsonSkyline.SampleableNode</code></a></li><li><a href="#CrimsonSkyline.Trace"><code>CrimsonSkyline.Trace</code></a></li><li><a href="#CrimsonSkyline.TypedTrace"><code>CrimsonSkyline.TypedTrace</code></a></li><li><a href="#CrimsonSkyline.UntypedTrace"><code>CrimsonSkyline.UntypedTrace</code></a></li><li><a href="#CrimsonSkyline.accept-Tuple{Trace, Trace, Float64}"><code>CrimsonSkyline.accept</code></a></li><li><a href="#CrimsonSkyline.addresses-Union{Tuple{CrimsonSkyline.SamplingResults{I}}, Tuple{I}} where I&lt;:CrimsonSkyline.InferenceType"><code>CrimsonSkyline.addresses</code></a></li><li><a href="#CrimsonSkyline.aic-Tuple{Trace}"><code>CrimsonSkyline.aic</code></a></li><li><a href="#CrimsonSkyline.aic-Union{Tuple{CrimsonSkyline.SamplingResults{I}}, Tuple{I}} where I&lt;:CrimsonSkyline.InferenceType"><code>CrimsonSkyline.aic</code></a></li><li><a href="#CrimsonSkyline.block-Tuple{Any, Trace}"><code>CrimsonSkyline.block</code></a></li><li><a href="#CrimsonSkyline.block-Union{Tuple{T}, Tuple{Any, T, Any}} where T&lt;:Trace"><code>CrimsonSkyline.block</code></a></li><li><a href="#CrimsonSkyline.combine-Tuple{Any, Vector{Float64}}"><code>CrimsonSkyline.combine</code></a></li><li><a href="#CrimsonSkyline.condition-Tuple{Any, Dict}"><code>CrimsonSkyline.condition</code></a></li><li><a href="#CrimsonSkyline.connect_pa_ch!-Tuple{Trace, Any, Any}"><code>CrimsonSkyline.connect_pa_ch!</code></a></li><li><a href="#CrimsonSkyline.copy_common!-Tuple{Trace, Trace}"><code>CrimsonSkyline.copy_common!</code></a></li><li><a href="#CrimsonSkyline.forward_sampling-Tuple{Any}"><code>CrimsonSkyline.forward_sampling</code></a></li><li><a href="#CrimsonSkyline.importance_sampling-Tuple{Any, Any, Tuple{DataType, DataType}}"><code>CrimsonSkyline.importance_sampling</code></a></li><li><a href="#CrimsonSkyline.importance_sampling-Tuple{Any, Any}"><code>CrimsonSkyline.importance_sampling</code></a></li><li><a href="#CrimsonSkyline.input-Tuple{Trace, Any, Any}"><code>CrimsonSkyline.input</code></a></li><li><a href="#CrimsonSkyline.interpret_latent!-Tuple{Trace, CrimsonSkyline.Interpretation}"><code>CrimsonSkyline.interpret_latent!</code></a></li><li><a href="#CrimsonSkyline.is_step-Tuple{Any, Any}"><code>CrimsonSkyline.is_step</code></a></li><li><a href="#CrimsonSkyline.is_step-Tuple{Any, Any, Tuple{DataType, DataType}}"><code>CrimsonSkyline.is_step</code></a></li><li><a href="#CrimsonSkyline.likelihood_weighting-Tuple{Any, Tuple{DataType, DataType}, Vararg{Any, N} where N}"><code>CrimsonSkyline.likelihood_weighting</code></a></li><li><a href="#CrimsonSkyline.likelihood_weighting-Tuple{Any, Vararg{Any, N} where N}"><code>CrimsonSkyline.likelihood_weighting</code></a></li><li><a href="#CrimsonSkyline.likelihood_weighting_results-Tuple{}"><code>CrimsonSkyline.likelihood_weighting_results</code></a></li><li><a href="#CrimsonSkyline.load-Tuple{Any}"><code>CrimsonSkyline.load</code></a></li><li><a href="#CrimsonSkyline.load_csm-Tuple{Any}"><code>CrimsonSkyline.load_csm</code></a></li><li><a href="#CrimsonSkyline.load_jdb-Tuple{Any}"><code>CrimsonSkyline.load_jdb</code></a></li><li><a href="#CrimsonSkyline.log_acceptance_ratio-Tuple{Trace, Trace, CrimsonSkyline.Prior}"><code>CrimsonSkyline.log_acceptance_ratio</code></a></li><li><a href="#CrimsonSkyline.log_evidence-Union{Tuple{CrimsonSkyline.SamplingResults{I}}, Tuple{I}} where I&lt;:CrimsonSkyline.Importance"><code>CrimsonSkyline.log_evidence</code></a></li><li><a href="#CrimsonSkyline.loglatent-Tuple{Trace}"><code>CrimsonSkyline.loglatent</code></a></li><li><a href="#CrimsonSkyline.loglikelihood-Tuple{Trace}"><code>CrimsonSkyline.loglikelihood</code></a></li><li><a href="#CrimsonSkyline.logprob-Tuple{Trace, Trace}"><code>CrimsonSkyline.logprob</code></a></li><li><a href="#CrimsonSkyline.logprob-Tuple{Trace}"><code>CrimsonSkyline.logprob</code></a></li><li><a href="#CrimsonSkyline.logprob!-Tuple{Trace}"><code>CrimsonSkyline.logprob!</code></a></li><li><a href="#CrimsonSkyline.lw_step-Tuple{Any, Tuple{DataType, DataType}, Vararg{Any, N} where N}"><code>CrimsonSkyline.lw_step</code></a></li><li><a href="#CrimsonSkyline.lw_step-Tuple{Any, Vararg{Any, N} where N}"><code>CrimsonSkyline.lw_step</code></a></li><li><a href="#CrimsonSkyline.mh-Tuple{Any}"><code>CrimsonSkyline.mh</code></a></li><li><a href="#CrimsonSkyline.mh-Union{Tuple{A}, Tuple{Any, A, Tuple{DataType, DataType}}} where A&lt;:AbstractArray"><code>CrimsonSkyline.mh</code></a></li><li><a href="#CrimsonSkyline.mh-Union{Tuple{A}, Tuple{Any, A}} where A&lt;:AbstractArray"><code>CrimsonSkyline.mh</code></a></li><li><a href="#CrimsonSkyline.mh-Tuple{Any, Tuple{DataType, DataType}}"><code>CrimsonSkyline.mh</code></a></li><li><a href="#CrimsonSkyline.mh_step-Tuple{Trace, Any, Any}"><code>CrimsonSkyline.mh_step</code></a></li><li><a href="#CrimsonSkyline.mh_step-Tuple{Trace, Any, Tuple{DataType, DataType}}"><code>CrimsonSkyline.mh_step</code></a></li><li><a href="#CrimsonSkyline.mh_step-Tuple{Trace, Any}"><code>CrimsonSkyline.mh_step</code></a></li><li><a href="#CrimsonSkyline.mh_step-Tuple{Trace, Any, Any, Tuple{DataType, DataType}}"><code>CrimsonSkyline.mh_step</code></a></li><li><a href="#CrimsonSkyline.nested-Tuple{Any}"><code>CrimsonSkyline.nested</code></a></li><li><a href="#CrimsonSkyline.nested-Tuple{Any, Any}"><code>CrimsonSkyline.nested</code></a></li><li><a href="#CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{Any, A, D, Bool, CrimsonSkyline.Interpretation}} where {A, D&lt;:Distributions.Sampleable}"><code>CrimsonSkyline.node</code></a></li><li><a href="#CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{DataType, A, D, Bool, CrimsonSkyline.Interpretation}} where {A, D}"><code>CrimsonSkyline.node</code></a></li><li><a href="#CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{DataType, A, D, Bool, CrimsonSkyline.Interpretation}} where {A, D&lt;:Distributions.Sampleable}"><code>CrimsonSkyline.node</code></a></li><li><a href="#CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{Any, A, D, Bool, CrimsonSkyline.Interpretation}} where {A, D}"><code>CrimsonSkyline.node</code></a></li><li><a href="#CrimsonSkyline.normalized_weights-Union{Tuple{CrimsonSkyline.SamplingResults{I}}, Tuple{I}} where I&lt;:CrimsonSkyline.Importance"><code>CrimsonSkyline.normalized_weights</code></a></li><li><a href="#CrimsonSkyline.observe-Tuple{Trace, Any, Any, Any}"><code>CrimsonSkyline.observe</code></a></li><li><a href="#CrimsonSkyline.pa_from_trace-Tuple{Trace, Any}"><code>CrimsonSkyline.pa_from_trace</code></a></li><li><a href="#CrimsonSkyline.plate-Union{Tuple{F}, Tuple{Trace, F, Any, Any, Int64, Replayed}} where F&lt;:Function"><code>CrimsonSkyline.plate</code></a></li><li><a href="#CrimsonSkyline.plate-Union{Tuple{F}, Tuple{Trace, F, Any, Any, Int64, Nonstandard}} where F&lt;:Function"><code>CrimsonSkyline.plate</code></a></li><li><a href="#CrimsonSkyline.plate-Union{Tuple{F}, Tuple{T}, Tuple{Trace, F, Any, Any, Vector{T}}} where {T, F&lt;:Function}"><code>CrimsonSkyline.plate</code></a></li><li><a href="#CrimsonSkyline.plate-Union{Tuple{F}, Tuple{Trace, F, Any, Any, Int64, CrimsonSkyline.Blocked}} where F&lt;:Function"><code>CrimsonSkyline.plate</code></a></li><li><a href="#CrimsonSkyline.plate-Union{Tuple{F}, Tuple{Trace, F, Any, Any, Int64, Conditioned}} where F&lt;:Function"><code>CrimsonSkyline.plate</code></a></li><li><a href="#CrimsonSkyline.plate-Union{Tuple{F}, Tuple{Trace, F, Any, Any, Int64}} where F&lt;:Function"><code>CrimsonSkyline.plate</code></a></li><li><a href="#CrimsonSkyline.propose-Tuple{Trace, Any, Any}"><code>CrimsonSkyline.propose</code></a></li><li><a href="#CrimsonSkyline.reflate!-Tuple{CrimsonSkyline.ParametricSamplingResults, Dict}"><code>CrimsonSkyline.reflate!</code></a></li><li><a href="#CrimsonSkyline.rejection-Tuple{Any, Float64, Vararg{Any, N} where N}"><code>CrimsonSkyline.rejection</code></a></li><li><a href="#CrimsonSkyline.replace-Tuple{Any, Dict}"><code>CrimsonSkyline.replace</code></a></li><li><a href="#CrimsonSkyline.replace-Union{Tuple{T}, Tuple{T, Dict}} where T&lt;:Trace"><code>CrimsonSkyline.replace</code></a></li><li><a href="#CrimsonSkyline.replay-Union{Tuple{T}, Tuple{Any, T}} where T&lt;:Trace"><code>CrimsonSkyline.replay</code></a></li><li><a href="#CrimsonSkyline.rewrite-Union{Tuple{T}, Tuple{Any, T, Dict}} where T&lt;:Trace"><code>CrimsonSkyline.rewrite</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, CrimsonSkyline.Blocked}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, Nonstandard}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, CrimsonSkyline.Blocked}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Vector{CrimsonSkyline.Interpretation}}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, Standard}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Union{Tuple{I}, Tuple{CrimsonSkyline.SamplingResults{I}, Any, Int64}} where I&lt;:CrimsonSkyline.Importance"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Union{Conditioned, Standard}}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Union{Tuple{I}, Tuple{Trace, Any, CrimsonSkyline.ParametricSamplingResults{I}}} where I&lt;:CrimsonSkyline.InferenceType"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Union{Tuple{I}, Tuple{Trace, Any, NonparametricSamplingResults{I}}} where I&lt;:CrimsonSkyline.InferenceType"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, Deterministic}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Nonstandard}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, Vector{CrimsonSkyline.Interpretation}}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Replayed}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, Replayed}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.save-Tuple{CrimsonSkyline.SamplingResults, Any}"><code>CrimsonSkyline.save</code></a></li><li><a href="#CrimsonSkyline.save-Tuple{Trace, Any}"><code>CrimsonSkyline.save</code></a></li><li><a href="#CrimsonSkyline.to_parametric-Union{Tuple{NonparametricSamplingResults{I}}, Tuple{I}} where I&lt;:CrimsonSkyline.InferenceType"><code>CrimsonSkyline.to_parametric</code></a></li><li><a href="#CrimsonSkyline.to_table-Tuple{Trace}"><code>CrimsonSkyline.to_table</code></a></li><li><a href="#CrimsonSkyline.trace-Tuple{}"><code>CrimsonSkyline.trace</code></a></li><li><a href="#CrimsonSkyline.trace-Tuple{Any, Any}"><code>CrimsonSkyline.trace</code></a></li><li><a href="#CrimsonSkyline.transform-Union{Tuple{F}, Tuple{Trace, Any, F, Any}} where F&lt;:Function"><code>CrimsonSkyline.transform</code></a></li><li><a href="#CrimsonSkyline.update-Union{Tuple{I}, Tuple{Any, CrimsonSkyline.SamplingResults{I}}} where I&lt;:CrimsonSkyline.InferenceType"><code>CrimsonSkyline.update</code></a></li><li><a href="#Distributions.logpdf-Union{Tuple{A}, Tuple{A, Any}} where A&lt;:AbstractArray"><code>Distributions.logpdf</code></a></li></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 25 May 2021 10:48">Tuesday 25 May 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
