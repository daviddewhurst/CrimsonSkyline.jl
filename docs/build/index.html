<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>CrimsonSkyline.jl · CrimsonSkyline.jl documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">CrimsonSkyline.jl documentation</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>CrimsonSkyline.jl</a><ul class="internal"><li><a class="tocitem" href="#trace"><span>trace</span></a></li><li><a class="tocitem" href="#io"><span>io</span></a></li><li><a class="tocitem" href="#effects"><span>effects</span></a></li><li><a class="tocitem" href="#graph"><span>graph</span></a></li><li><a class="tocitem" href="#cpt"><span>cpt</span></a></li><li><a class="tocitem" href="#importance"><span>importance</span></a></li><li><a class="tocitem" href="#metropolis"><span>metropolis</span></a></li><li><a class="tocitem" href="#fusion"><span>fusion</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>CrimsonSkyline.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>CrimsonSkyline.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com//blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="CrimsonSkyline.jl"><a class="docs-heading-anchor" href="#CrimsonSkyline.jl">CrimsonSkyline.jl</a><a id="CrimsonSkyline.jl-1"></a><a class="docs-heading-anchor-permalink" href="#CrimsonSkyline.jl" title="Permalink"></a></h1><h2 id="trace"><a class="docs-heading-anchor" href="#trace">trace</a><a id="trace-1"></a><a class="docs-heading-anchor-permalink" href="#trace" title="Permalink"></a></h2><p>To a large extent, <code>Node</code>s have local control over the behavior of inference algorithms via their  <code>interpretation</code>. There are a variety of <code>Interpretation</code>s. The type hierarchy is flat:</p><pre><code class="language-none">abstract type Interpretation end
struct Nonstandard &lt;: Interpretation end
struct Standard &lt;: Interpretation end
struct Replayed &lt;: Interpretation end
struct Conditioned &lt;: Interpretation end 
struct Blocked &lt;: Interpretation end
struct Deterministic &lt;: Interpretation end
struct Proposed &lt;: Interpretation end</code></pre><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.Node" href="#CrimsonSkyline.Node"><code>CrimsonSkyline.Node</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct Node{A, D, T, P}
    address :: A
    dist :: D
    value :: Maybe{T}
    logprob :: P
    logprob_sum :: Float64
    observed :: Bool
    pa :: Array{Node, 1}
    ch :: Array{Node, 1}
    interpretation :: Interpretation
    last_interpretation :: Interpretation
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.Trace" href="#CrimsonSkyline.Trace"><code>CrimsonSkyline.Trace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct Trace
    trace :: OrderedDict{Any, Node}
    logprob_sum :: Float64
end</code></pre><p><code>Trace</code>s support the following <code>Base</code> methods: <code>setindex!</code>, <code>getindex</code>, <code>keys</code>, <code>values</code>, and <code>length</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.connect_pa_ch!-Tuple{Trace,Any,Any}" href="#CrimsonSkyline.connect_pa_ch!-Tuple{Trace,Any,Any}"><code>CrimsonSkyline.connect_pa_ch!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function connect_pa_ch!(t :: Trace, pa, a)</code></pre><p>Connects parent and child nodes. Adds child nodes to parent&#39;s <code>ch</code> and  parent nodes to child&#39;s <code>pa</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.interpret_latent!-Tuple{Trace,CrimsonSkyline.Interpretation}" href="#CrimsonSkyline.interpret_latent!-Tuple{Trace,CrimsonSkyline.Interpretation}"><code>CrimsonSkyline.interpret_latent!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function interpret_latent!(t :: Trace, i :: Interpretation)</code></pre><p>Changes the interpretation of all nodes in <code>t</code> to have <code>interpretation == i</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.loglikelihood-Tuple{Trace}" href="#CrimsonSkyline.loglikelihood-Tuple{Trace}"><code>CrimsonSkyline.loglikelihood</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function loglikelihood(t :: Trace)</code></pre><p>Computes and returns the log likelihood of the observed data under the model:</p><p><span>$\ell(t) =  \sum_{a:\ [a \in \text{keys}(t)] \wedge [\text{interpretation}(a) = \text{Standard}]}  \log p(t[a])$</span></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.logprob!-Tuple{Trace}" href="#CrimsonSkyline.logprob!-Tuple{Trace}"><code>CrimsonSkyline.logprob!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function logprob!(t :: Trace)</code></pre><p>Computes the joint log probability to the trace and assigns it to <code>t.logprob_sum</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.logprob-Tuple{Trace}" href="#CrimsonSkyline.logprob-Tuple{Trace}"><code>CrimsonSkyline.logprob</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function logprob(t :: Trace)</code></pre><p>Computes and returns the joint log probability of the trace:</p><p><span>$\log p(t) = \sum_{a \in \text{keys}(t)}\log p(t[a])$</span></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{Any,A,D,Bool,CrimsonSkyline.Interpretation}} where D where A" href="#CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{Any,A,D,Bool,CrimsonSkyline.Interpretation}} where D where A"><code>CrimsonSkyline.node</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function node(value, address :: A, dist :: D, is_obs :: Bool, i :: Interpretation) where {A, D}</code></pre><p>Outer constructor for <code>Node</code> where data is passed during construction. Data type is inferred from the passed data.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{DataType,A,D,Bool,CrimsonSkyline.Interpretation}} where D where A" href="#CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{DataType,A,D,Bool,CrimsonSkyline.Interpretation}} where D where A"><code>CrimsonSkyline.node</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function node(T :: DataType, address :: A, dist :: D, is_obs :: Bool, i :: Interpretation) where {A, D}</code></pre><p>Outer constructor for <code>Node</code> where no data is passed during construction. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.node-Union{Tuple{I}, Tuple{D}, Tuple{A}, Tuple{I,A,D,Bool,CrimsonSkyline.Interpretation}} where I&lt;:AbstractArray where D where A" href="#CrimsonSkyline.node-Union{Tuple{I}, Tuple{D}, Tuple{A}, Tuple{I,A,D,Bool,CrimsonSkyline.Interpretation}} where I&lt;:AbstractArray where D where A"><code>CrimsonSkyline.node</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function node(value :: I, address :: A, dist :: D, is_obs :: Bool, i :: Interpretation) where {A, D, I &lt;: AbstractArray}</code></pre><p>Outer constructor for <code>Node</code> where data is passed during construction. Data type is inferred from the passed data.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.observe-Tuple{Trace,Any,Any,Any}" href="#CrimsonSkyline.observe-Tuple{Trace,Any,Any,Any}"><code>CrimsonSkyline.observe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function observe(t :: Trace, a, d, s; pa = ())</code></pre><p>If <code>d</code> is not <code>nothing</code> an alias for calling <code>sample</code> with standard interpretation.  Otherwise, an alias for calling <code>sample</code> with nonstandard interpretation. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.pa_from_trace-Tuple{Trace,Any}" href="#CrimsonSkyline.pa_from_trace-Tuple{Trace,Any}"><code>CrimsonSkyline.pa_from_trace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function pa_from_trace(t :: Trace, pa)</code></pre><p>Collects nodes in trace corresponding to an iterable of parent addresses <code>pa</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.prior-Union{Tuple{F}, Tuple{F,Union{Tuple, AbstractArray},Vararg{Any,N} where N}} where F&lt;:Function" href="#CrimsonSkyline.prior-Union{Tuple{F}, Tuple{F,Union{Tuple, AbstractArray},Vararg{Any,N} where N}} where F&lt;:Function"><code>CrimsonSkyline.prior</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function prior(f :: F, addresses :: Union{AbstractArray, Tuple}, params...; nsamples :: Int = 1) where F &lt;: Function</code></pre><p>Given a generative function <code>f</code>, an array-like of addresses, and a collection of parameters to pass to <code>f</code>, runs <code>nsamples</code> evaluations of the <code>f</code>, collecting the values from the <code>addresses</code> and returning a <code>Dict</code> mapping addresses to values. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any,CrimsonSkyline.Blocked}" href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any,CrimsonSkyline.Blocked}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, d, params, i :: Blocked; pa = ())</code></pre><p>Samples from <code>d</code> passing the optional arguments <code>params</code>, deletes the node stored at address <code>a</code> from trace <code>t</code>, and returns the sampled value. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any,Deterministic}" href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any,Deterministic}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, f, v, i :: Deterministic; pa = ())</code></pre><p>Creates a deterministic node mapping the tuple of data <code>v</code> through function <code>f</code>,  storing the value in trace <code>t</code> at address <code>a</code>.</p><ol><li>Infers input type from <code>v</code></li><li>Maps tuple of data <code>v</code> through function <code>f</code>, yielding <code>r = f(v...)</code></li><li>Creates a deterministic node and stores it in <code>t</code> at address <code>a</code></li><li>Optionally adds nodes corresponding to the addresses in <code>pa</code> as parent nodes</li><li>Returns <code>r</code></li></ol></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any,Nonstandard}" href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any,Nonstandard}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, d, params, i :: Nonstandard; pa = ())</code></pre><p>Samples from distribution <code>d</code> into trace <code>t</code> at address <code>a</code>.</p><ol><li>Samples a value from <code>d</code> passing the optional arguments <code>params</code></li><li>Creates a sample node</li><li>Adds the sample node to trace <code>t</code> at value <code>a</code></li><li>Optionally adds nodes corresponding to the addresses in <code>pa</code> as parent nodes</li><li>Returns the sampled value</li></ol></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any,Replayed}" href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any,Replayed}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, d, params, i :: Replayed; pa = ())</code></pre><p>Replays the sampled node through the trace. </p><ol><li>If <code>a</code> is not in <code>t</code>&#39;s address set, calls <code>sample(t, a, d, NONSTANDARD; pa = pa)</code>. </li><li>Creates a sample node that copies the value from the last node stored in the trace at address <code>a</code>. </li><li>Adds the sample node to trace <code>t</code> at value <code>a</code></li><li>Optionally adds nodes corresponding to the addresses in <code>pa</code> as parent nodes</li><li>Resets the node&#39;s interpretation to the original interpretation</li></ol></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any,Standard}" href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any,Standard}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, d, s, i :: Standard; pa = ())</code></pre><p>Scores an observed value <code>s</code> against the distribution <code>d</code>, storing the value in trace <code>t</code> at  address <code>a</code> and optionally adds nodes corresponding to the addresses in <code>pa</code> as parent nodes.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any}" href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, d, params; pa = ())</code></pre><p>If <code>a</code> is in the set of trace addresses, calls <code>sample</code> using <code>t[a]</code>&#39;s interpretation.  Otherwise, calls <code>sample</code> using nonstandard interpretation. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace,Any,Any,CrimsonSkyline.Blocked}" href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any,CrimsonSkyline.Blocked}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, d, i :: Blocked; pa = ())</code></pre><p>Samples from <code>d</code>, deletes the node stored at address <code>a</code> from trace <code>t</code>, and returns the  sampled value. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace,Any,Any,Nonstandard}" href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Nonstandard}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, d, i :: Nonstandard; pa = ())</code></pre><p>Samples from distribution <code>d</code> into trace <code>t</code> at address <code>a</code>.</p><ol><li>Samples a value from <code>d</code></li><li>Creates a sample node</li><li>Adds the sample node to trace <code>t</code> at value <code>a</code></li><li>Optionally adds nodes corresponding to the addresses in <code>pa</code> as parent nodes</li><li>Returns the sampled value</li></ol></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace,Any,Any,Replayed}" href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Replayed}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, d, i :: Replayed; pa = ())</code></pre><p>Replays the sampled node through the trace. </p><ol><li>If <code>a</code> is not in <code>t</code>&#39;s address set, calls <code>sample(t, a, d, NONSTANDARD; pa = pa)</code>. </li><li>Creates a sample node that copies the value from the last node stored in the trace at address <code>a</code>. </li><li>Adds the sample node to trace <code>t</code> at value <code>a</code></li><li>Optionally adds nodes corresponding to the addresses in <code>pa</code> as parent nodes</li><li>Resets the node&#39;s interpretation to the original interpretation</li></ol></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace,Any,Any}" href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, d; pa = ())</code></pre><p>If <code>a</code> is in the set of trace addresses, calls <code>sample</code> using <code>t[a]</code>&#39;s interpretation.  Otherwise, calls <code>sample</code> using nonstandard interpretation. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.trace-Tuple{}" href="#CrimsonSkyline.trace-Tuple{}"><code>CrimsonSkyline.trace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">trace()</code></pre><p>This is the recommended way to construct a new trace.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.transform-Union{Tuple{F}, Tuple{Trace,Any,F,Any}} where F&lt;:Function" href="#CrimsonSkyline.transform-Union{Tuple{F}, Tuple{Trace,Any,F,Any}} where F&lt;:Function"><code>CrimsonSkyline.transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function transform(t :: Trace, a, f :: F, v; pa = ()) where F &lt;: Function</code></pre><p>Alias for <code>sample(t, a, f, v, DETERMINISTIC; pa = pa)</code>.</p></div></section></article><h2 id="io"><a class="docs-heading-anchor" href="#io">io</a><a id="io-1"></a><a class="docs-heading-anchor-permalink" href="#io" title="Permalink"></a></h2><p>Saving and loading traces is possible using the <code>save</code> and <code>load</code> functions. This functionality depends on <code>JuliaDB</code>. Example usage (<code>fn</code> is a stochastic function):</p><pre><code class="language-none">t = trace()
data = randn(2)
fn(t, data)
fname = joinpath(@__DIR__, &quot;out&quot;, &quot;my_file.jdb&quot;)
f = save(t, fname)
identical_t = load(f)</code></pre><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.load-Tuple{Any}" href="#CrimsonSkyline.load-Tuple{Any}"><code>CrimsonSkyline.load</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function load(f) :: Trace</code></pre><p>Loads a serialized juliadb table from file <code>f</code> and converts it into a trace.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.save-Tuple{Trace,Any}" href="#CrimsonSkyline.save-Tuple{Trace,Any}"><code>CrimsonSkyline.save</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function save(t :: Trace, f)</code></pre><p>Saves a trace to disk as a serialized juliadb table at the filepath <code>f</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.to_table-Tuple{Trace}" href="#CrimsonSkyline.to_table-Tuple{Trace}"><code>CrimsonSkyline.to_table</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function to_table(t :: Trace)</code></pre><p>Turns a trace into a juliadb table. Does not store parent / child relationships.</p></div></section></article><h2 id="effects"><a class="docs-heading-anchor" href="#effects">effects</a><a id="effects-1"></a><a class="docs-heading-anchor-permalink" href="#effects" title="Permalink"></a></h2><p>A library of functions that change the interpretation of some or all nodes in a trace.</p><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.block-Union{Tuple{F}, Tuple{F,Trace,Any}} where F&lt;:Function" href="#CrimsonSkyline.block-Union{Tuple{F}, Tuple{F,Trace,Any}} where F&lt;:Function"><code>CrimsonSkyline.block</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function block(f :: F, t :: Trace, addresses) where F &lt;: Function</code></pre><p>Given a stoochastic function <code>f</code>, a trace <code>t</code>, and an iterable of addresses, converts traced randomness into untraced randomness. </p><p>Returns a tuple <code>(t_new, g)</code>, where <code>t_new</code> is a trace and <code>g</code> is a function. The function signature of <code>g</code> is the same as that of <code>f</code> with the first argument removed; that is, if <code>f(t :: Trace, params...)</code>, then <code>g(params...)</code>. Computation is delayed, so each of  the latent nodes in <code>t_new</code> has <code>interpretation = BLOCKED</code>. Calling <code>g(params...)</code> executes the  computation and each latent node in <code>t_new</code> with an address in <code>addresses</code> is removed.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.block-Union{Tuple{F}, Tuple{F,Trace}} where F&lt;:Function" href="#CrimsonSkyline.block-Union{Tuple{F}, Tuple{F,Trace}} where F&lt;:Function"><code>CrimsonSkyline.block</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">block(f :: F, t :: Trace) where F &lt;: Function</code></pre><p>Converts all traced randomness into untraced randomness.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.replay-Union{Tuple{F}, Tuple{F,Trace}} where F&lt;:Function" href="#CrimsonSkyline.replay-Union{Tuple{F}, Tuple{F,Trace}} where F&lt;:Function"><code>CrimsonSkyline.replay</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function replay(f :: F, t :: Trace) where F &lt;: Function</code></pre><p>Given a stochastic function <code>f</code> and a trace <code>t</code>, makes <code>sample</code> calls behave as though  they had sampled the values in <code>t</code> at the corresponding addresses. </p><p>Returns a tuple <code>(t_new, g)</code>, where <code>t_new</code> is a trace and <code>g</code> is a function. The function signature of <code>g</code> is the same as that of <code>f</code> with the first argument removed; that is, if <code>f(t :: Trace, params...)</code>, then <code>g(params...)</code>. Computation is delayed, so each of the latent nodes in <code>t_new</code> has <code>interpretation = REPLAYED</code>. Calling <code>g(params...)</code> executes the computation and each latent node in <code>t_new</code> reverts to  its original interpretation. </p></div></section></article><h2 id="graph"><a class="docs-heading-anchor" href="#graph">graph</a><a id="graph-1"></a><a class="docs-heading-anchor-permalink" href="#graph" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.Factor" href="#CrimsonSkyline.Factor"><code>CrimsonSkyline.Factor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Factor 
    info :: OrderedDict{Any, OrderedDict}
    node_to_factor :: OrderedDict
    factor_to_node :: OrderedDict
end</code></pre><p>A representation of a factor graph. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.GraphIR" href="#CrimsonSkyline.GraphIR"><code>CrimsonSkyline.GraphIR</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct GraphIR 
    info :: OrderedDict{Any, OrderedDict}
    graph :: OrderedDict
end</code></pre><p>An intermediate representation of a single trace as a directed acyclic graph (DAG) that  stores node information in <code>info</code> and DAG structure in <code>graph</code>. The keys and values of <code>graph</code> are addresses, while <code>info</code> is a mapping from addresses to results from calls to <code>node_info</code>. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.factor-Tuple{GraphIR}" href="#CrimsonSkyline.factor-Tuple{GraphIR}"><code>CrimsonSkyline.factor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function factor(g :: GraphIR)</code></pre><p>Outer constructor for a factor graph from an intermediate DAG representation. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.factor-Tuple{Trace}" href="#CrimsonSkyline.factor-Tuple{Trace}"><code>CrimsonSkyline.factor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">factor(t :: Trace)</code></pre><p>Outer constructor for a factor graph from a trace. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.graph_ir-Tuple{Trace}" href="#CrimsonSkyline.graph_ir-Tuple{Trace}"><code>CrimsonSkyline.graph_ir</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function graph_ir(t :: Trace)</code></pre><p>Outer constructor for <code>GraphIR</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.node_info-Tuple{Trace,Any}" href="#CrimsonSkyline.node_info-Tuple{Trace,Any}"><code>CrimsonSkyline.node_info</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function node_info(t :: Trace, a)</code></pre><p>Returns an <code>OrderedDict</code> containing all information about the node <code>t[a]</code> required for graph-based inference algorithms.</p><p>Keys include:</p><ul><li><code>&quot;address&quot;</code>: the address of the node in the trace</li><li><code>&quot;dist&quot;</code>: the probability distribution associated with the address</li><li><code>&quot;observed&quot;</code>: whether or not the value associated with the node was observed</li><li><code>&quot;interpretation&quot;</code>: the interpretation of the node in the trace</li><li><code>&quot;data&quot;</code> (optional): if the value associated with the node was observed, the value associated   with the node. </li><li><code>&quot;pa&quot;</code>: the parents of the node in the trace. Note that it is necessary to pass parent addresses   to one of the various sample methods in order to build a nontrivial <code>GraphIR</code>.</li></ul></div></section></article><h2 id="cpt"><a class="docs-heading-anchor" href="#cpt">cpt</a><a id="cpt-1"></a><a class="docs-heading-anchor-permalink" href="#cpt" title="Permalink"></a></h2><p>Conditional probability tables (CPT) are a work in progress. Currently there are no implemented inference algorithms that operate on CPTs. </p><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.CPT" href="#CrimsonSkyline.CPT"><code>CrimsonSkyline.CPT</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct CPT{L&lt;:AbstractDict, D&lt;:AbstractArray}
    dims :: L
    axes :: Dict{Any, Int64}
    labels :: Array{Dict, 1}
    values :: D
end</code></pre><p>A representation of an arbitrary-dimensional ragged CPT. Supports <code>Base</code> methods  <code>setindex!</code> and <code>getindex</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.cpt-Tuple{L} where L&lt;:AbstractDict" href="#CrimsonSkyline.cpt-Tuple{L} where L&lt;:AbstractDict"><code>CrimsonSkyline.cpt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function cpt(dims :: L) where L &lt;: AbstractDict</code></pre><p>Outer constructor for <code>CPT</code>. Given a <code>Dict</code> that maps names of dimensions to dimension level names, constructs a CPT with equiprobable coordinates.</p><p>Example usage:</p><pre><code class="language-none">dims = Dict(&quot;cost&quot; =&gt; [&quot;high&quot;, &quot;low&quot;], &quot;revenue&quot; =&gt; [&quot;high&quot;, &quot;medium&quot;, &quot;low&quot;])
c = cpt(dims)
c[(&quot;high&quot;, &quot;low&quot;)] = 0.4
c[(&quot;high&quot;, &quot;high&quot;)] = 0.2
c[(&quot;low&quot;, &quot;low&quot;)] = 0.3
renormalize!(c)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.renormalize!-Tuple{CPT}" href="#CrimsonSkyline.renormalize!-Tuple{CPT}"><code>CrimsonSkyline.renormalize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">renormalize!(c :: CPT)</code></pre><p>Renormalizes the possibly non-normalized factor <code>c</code> to be a proper discrete joint density.</p></div></section></article><h2 id="importance"><a class="docs-heading-anchor" href="#importance">importance</a><a id="importance-1"></a><a class="docs-heading-anchor-permalink" href="#importance" title="Permalink"></a></h2><p>Importance sampling algorithms and utilities.  Currently the following importance sampling algorithms are implemented:</p><ul><li>Likelihood weighting</li></ul><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.ImportanceResults" href="#CrimsonSkyline.ImportanceResults"><code>CrimsonSkyline.ImportanceResults</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ImportanceResults
    log_weights :: Array{Float64, 1}
    return_values :: Array{Any, 1}
    traces :: Array{Trace, 1}
end</code></pre><p>Wrapper for results of importance sampling. Implements the following methods  from <code>Base</code>: <code>getindex</code>. The log weights are unnormalized. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.importance_results-Tuple{}" href="#CrimsonSkyline.importance_results-Tuple{}"><code>CrimsonSkyline.importance_results</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">importance_results()</code></pre><p>Outer constructor for <code>ImportanceResults</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.likelihood_weighting-Union{Tuple{F}, Tuple{F,Vararg{Any,N} where N}} where F&lt;:Function" href="#CrimsonSkyline.likelihood_weighting-Union{Tuple{F}, Tuple{F,Vararg{Any,N} where N}} where F&lt;:Function"><code>CrimsonSkyline.likelihood_weighting</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function likelihood_weighting(f :: F, params...; nsamples :: Int = 1) where F &lt;: Function</code></pre><p>Given a stochastic function f and arguments to the function <code>params...</code>, executes <code>nsamples</code> iterations of importance sampling by using the prior as a proposal distribution. The importance weights are given by <span>$\log W_n = \ell(t_n)$</span>. Returns an <code>ImportanceResults</code> instance. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.log_evidence-Tuple{CrimsonSkyline.ImportanceResults}" href="#CrimsonSkyline.log_evidence-Tuple{CrimsonSkyline.ImportanceResults}"><code>CrimsonSkyline.log_evidence</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function log_evidence(r :: ImportanceResults)</code></pre><p>Computes the log evidence (log partition function), </p><p><span>$\log Z \equiv \log p(x) \approx -\log N_{\text{samples}} + \log \sum_{n=1}^{N_{\text{samples}}} W_n.$</span></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.normalized_weights-Tuple{CrimsonSkyline.ImportanceResults}" href="#CrimsonSkyline.normalized_weights-Tuple{CrimsonSkyline.ImportanceResults}"><code>CrimsonSkyline.normalized_weights</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function normalized_weights(r :: ImportanceResults)</code></pre><p>Computes the normalized weights <span>$w_n$</span> from unnormalized weights <span>$W_n$</span>:</p><p><span>$w_n = W_n / p(x) = \exp\{\ell(t_n) - \log Z\}.$</span></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{CrimsonSkyline.ImportanceResults,Any,Int64}" href="#CrimsonSkyline.sample-Tuple{CrimsonSkyline.ImportanceResults,Any,Int64}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(r :: ImportanceResults, k, n :: Int)</code></pre><p>Draws <code>n</code> samples from the empirical marginal posterior at address <code>k</code>.</p></div></section></article><h2 id="metropolis"><a class="docs-heading-anchor" href="#metropolis">metropolis</a><a id="metropolis-1"></a><a class="docs-heading-anchor-permalink" href="#metropolis" title="Permalink"></a></h2><p>Metropolis algorithm and utilities. Currently the following algorithms are implemented for both  FOPPL and HOPPL programs:</p><ul><li>Independent prior proposal</li><li>Arbitrary single- or multi-site proposal</li></ul><p>Here are two examples of inference using the arbitrary MH step interface. Consider the following generative function:</p><pre><code class="language-none">function normal_model(t :: Trace, data :: Vector{Float64})
    loc = sample(t, :loc, Normal(0.0, 10.0))
    scale = sample(t, :scale, LogNormal())
    for i in 1:length(data)
        observe(t, (:obs, i), Normal(loc, scale), data[i])
    end
end</code></pre><p>To learn an approximate posterior for <code>:loc</code> and <code>:scale</code>, we will introduce two proposal kernels:</p><pre><code class="language-none">loc_proposal(old_t :: Trace, new_t :: Trace, data) = propose(new_t, :loc, Normal(old_t[:loc].value, 0.25))
scale_proposal(old_t :: Trace, new_t :: Trace, data) = propose(new_t, :scale, truncated(Normal(old_t[:scale].value, 0.25), 0.0, Inf))</code></pre><p>Note that while <code>loc_proposal</code> is symmetric, <code>scale_proposal</code> is not. To perform inference, we pass these kernels to <code>mh_step</code> in  a loop after first drawing a random trace:</p><pre><code class="language-none">t = trace()
normal_model(t, data)
for i in 1:niter
    t = mh_step(t, normal_model, loc_proposal; params = (data,))
    t = mh_step(t, normal_model, scale_proposal; params = (data,))
end</code></pre><p>In this case, inference was fairly successful:</p><pre><code class="language-none">[ Info: True loc = 4.0
[ Info: True std = 1.0
[ Info: inferred E[loc] = 4.022688081613082
[ Info: inferred E[scale] = 0.9696559373495869
[ Info: approximate p(x) = sum_z p(x|z) = -138.63530736205144</code></pre><p>As a less trivial (but still contrived!) inference example, we can infer the posterior distribution of a latent discrete random variable in an open-universe model: </p><pre><code class="language-none">function random_sum_model(t :: Trace, data)
    n = sample(t, :n, Geometric(0.1))
    loc = 0.0
    for i in 1:(n + 1)
        loc += sample(t, (:loc, i), Normal())
    end
    obs = Array{Float64, 1}()
    for j in 1:length(data)
        o = observe(t, (:data, j), Normal(loc, 1.0), data[j])
        push!(obs, o)
    end
    obs
end</code></pre><p>(N.B.: we write the model is this form for pedagogic reasons; there is a far more efficient way to express the latent structure  of this model, namely <span>$n \sim \text{Geometric}(0.1)$</span>, <span>$\text{loc} \sim \text{Normal}(0, n)$</span>.) We are interested in learning the posterior distribution of <code>:n</code>. We introduce two proposal distributions, one for the latent discrete rv and another generic proposal for the location increments:</p><pre><code class="language-none">function random_n_proposal(old_trace, new_trace, params...)
    old_n = float(old_trace[:n].value)
    if old_n &gt; 0
        propose(new_trace, :n, Poisson(old_n))
    else
        propose(new_trace, :n, Poisson(1.0))
    end
end

gen_loc_proposal(old_trace, new_trace, ix, params...) = propose(new_trace, (:loc, ix), Normal(old_trace[(:loc, ix)].value, 0.25))</code></pre><p>We again conduct inference by simply applying proposals within a loop. This time, the number of location increment proposals we need to  construct is dependent on the sampled values of the latent random variable. We can either create these proposals on the fly as they&#39;re  needed or create what is nearly guaranteed to be enough of them before any inference is performed, e.g.,  <code>loc_proposals = [(o, n, params...) -&gt; gen_loc_proposal(o, n, i, params...) for i in 1:100]</code>. Now that we have what we need, we can conduct inference:</p><pre><code class="language-none">t = trace()
random_sum_model(t, data)
...
for i in 1:niter
    t = mh_step(t, random_sum_model, random_n_proposal; params=(data,))
    for j in 1:(t[:n].value + 1)
        t = mh_step(t, random_sum_model, loc_proposals[j]; params=(data,))
    end
    push!(ns, t[:n].value)
end</code></pre><p>Our inference results look promising:</p><pre><code class="language-none">[ Info: True :n = 9
[ Info: Posterior E[:n] = 7.581604598850287</code></pre><p>For more examples, check back soon.</p><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.accept-Tuple{Trace,Trace,Float64}" href="#CrimsonSkyline.accept-Tuple{Trace,Trace,Float64}"><code>CrimsonSkyline.accept</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function accept(t :: Trace, new_t :: Trace, log_a :: Float64)</code></pre><p>Stochastic function that either returns <code>new_t</code> if accepted or returns <code>t</code> if not accepted.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.copy_common!-Tuple{Trace,Trace}" href="#CrimsonSkyline.copy_common!-Tuple{Trace,Trace}"><code>CrimsonSkyline.copy_common!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function copy_common!(old_t :: Trace, new_t :: Trace)</code></pre><p>Copies nodes from <code>old_t</code> into <code>new_t</code> for all addresses in the intersection of their address sets. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.log_acceptance_ratio-Tuple{Trace,Trace,CrimsonSkyline.Prior}" href="#CrimsonSkyline.log_acceptance_ratio-Tuple{Trace,Trace,CrimsonSkyline.Prior}"><code>CrimsonSkyline.log_acceptance_ratio</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function log_acceptance_ratio(t :: Trace, t_proposed :: Trace, p :: Prior)</code></pre><p>Computes the log acceptance ratio of a Metropolis step when using the independent prior proposal  algorithm:</p><p><span>$\log \alpha = \ell(t_{\text{proposed}}) - \ell(t_{\text{original}})$</span></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.loglatent-Tuple{Trace}" href="#CrimsonSkyline.loglatent-Tuple{Trace}"><code>CrimsonSkyline.loglatent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function loglatent(t :: Trace)</code></pre><p>Computes the joint log probability of all latent variables in a trace, <span>$\log p(t) - \ell(t)$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.logprob-Tuple{Trace,Trace}" href="#CrimsonSkyline.logprob-Tuple{Trace,Trace}"><code>CrimsonSkyline.logprob</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function logprob(t0 :: Trace, t1 :: Trace)</code></pre><p>Computes the proposal log probability <span>$q(t_1 | t_0)$</span>.</p><p>This expression has two parts: log probability that is generated at the proposed site(s), and  log probability that is generated at the sites that are present in <code>t1</code> but not in <code>t0</code>. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.mh_step-Union{Tuple{F2}, Tuple{F1}, Tuple{Trace,F1,F2}} where F2&lt;:Function where F1&lt;:Function" href="#CrimsonSkyline.mh_step-Union{Tuple{F2}, Tuple{F1}, Tuple{Trace,F1,F2}} where F2&lt;:Function where F1&lt;:Function"><code>CrimsonSkyline.mh_step</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function mh_step(t :: Trace, f :: F1, q :: F2; params = ()) where {F1 &lt;: Function, F2 &lt;: Function}</code></pre><p>A generic Metropolis step using an arbitrary proposal kernel. </p><p>Given a trace <code>t</code>, a stochastic function <code>f</code> with signature <code>f(t :: Trace, params...)</code> a stochastic function  <code>q</code> with signature <code>q(old_trace :: Trace, new_trace :: Trace, params...)</code>, generates a proposal from <code>q</code> and  accepts based on the log acceptance probability:</p><p><span>$\log \alpha = \log p(t_{\text{new}}) - \log q(t_{\text{new}}|t_{\text{old}}) - [\log p(t_{\text{old}}) - \log q(t_{\text{old}} | t_{\text{new}})].$</span></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.mh_step-Union{Tuple{F}, Tuple{Trace,F}} where F&lt;:Function" href="#CrimsonSkyline.mh_step-Union{Tuple{F}, Tuple{Trace,F}} where F&lt;:Function"><code>CrimsonSkyline.mh_step</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function mh_step(t :: Trace, f :: F; params = ()) where F &lt;: Function</code></pre><p>An independent prior sample Metropolis step.</p><p>Given a trace <code>t</code> and stochatic function <code>f</code> depending on <code>params...</code>, generates proposals  from prior draws and accepts based on the likelihood ratio.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.propose-Tuple{Trace,Any,Any}" href="#CrimsonSkyline.propose-Tuple{Trace,Any,Any}"><code>CrimsonSkyline.propose</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">propose(t :: Trace, a, d)</code></pre><p>Propose a value for the address <code>a</code> in trace <code>t</code> from the distribution <code>d</code>.</p></div></section></article><h2 id="fusion"><a class="docs-heading-anchor" href="#fusion">fusion</a><a id="fusion-1"></a><a class="docs-heading-anchor-permalink" href="#fusion" title="Permalink"></a></h2><p>Methods to perform semi-analytical simplification and inference. </p><h3 id="fusion/distributions"><a class="docs-heading-anchor" href="#fusion/distributions">fusion/distributions</a><a id="fusion/distributions-1"></a><a class="docs-heading-anchor-permalink" href="#fusion/distributions" title="Permalink"></a></h3><p>A collection of distributions that aren&#39;t in <code>Distributions.jl</code>. These distributions are useful in their own right, but are  also arise when fusing pairs or triples of known distributions.</p><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.CSDistribution" href="#CrimsonSkyline.CSDistribution"><code>CrimsonSkyline.CSDistribution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type CSDistribution{D} end</code></pre><p>Abstract type from which all CrimsonSkyline distributions subtype. All subtypes implement the following methods from <code>Distributions.jl</code>:  <code>rand</code> and <code>logpdf</code>. Unless otherwise specified, these subtypes do <em>not</em>  implement <code>logpdf.</code>, which may change in the future.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.Lomax" href="#CrimsonSkyline.Lomax"><code>CrimsonSkyline.Lomax</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Lomax{D} &lt;: CSDistribution{D}
    α :: D
    θ :: D 
    γ :: Gamma{D}
end</code></pre><p>A Lomax distribution, which is a power-law distribution supported on <span>$[0, \infty)$</span>. It has the pdf </p><p><span>$p(x | \alpha,\ \theta) = -(\alpha + 1) [ \log(\alpha \theta) + \log(1 + x \theta) ].$</span></p><p>Sampling from this distribution is accomplished via a gamma - exponential mixture.  A value <span>$g \sim \text{Gamma}(\alpha,\ \theta)$</span> is drawn, and then  the value <span>$e \sim \text{Exponential}(g)$</span> is returned. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.Lomax-Union{Tuple{D}, Tuple{D,D}} where D&lt;:Real" href="#CrimsonSkyline.Lomax-Union{Tuple{D}, Tuple{D,D}} where D&lt;:Real"><code>CrimsonSkyline.Lomax</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function Lomax(α :: D, θ :: D) where D &lt;: Real</code></pre><p>Outer constructor for Lomax struct.</p></div></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#CrimsonSkyline.CPT"><code>CrimsonSkyline.CPT</code></a></li><li><a href="#CrimsonSkyline.CSDistribution"><code>CrimsonSkyline.CSDistribution</code></a></li><li><a href="#CrimsonSkyline.Factor"><code>CrimsonSkyline.Factor</code></a></li><li><a href="#CrimsonSkyline.GraphIR"><code>CrimsonSkyline.GraphIR</code></a></li><li><a href="#CrimsonSkyline.ImportanceResults"><code>CrimsonSkyline.ImportanceResults</code></a></li><li><a href="#CrimsonSkyline.Lomax-Union{Tuple{D}, Tuple{D,D}} where D&lt;:Real"><code>CrimsonSkyline.Lomax</code></a></li><li><a href="#CrimsonSkyline.Lomax"><code>CrimsonSkyline.Lomax</code></a></li><li><a href="#CrimsonSkyline.Node"><code>CrimsonSkyline.Node</code></a></li><li><a href="#CrimsonSkyline.Trace"><code>CrimsonSkyline.Trace</code></a></li><li><a href="#CrimsonSkyline.accept-Tuple{Trace,Trace,Float64}"><code>CrimsonSkyline.accept</code></a></li><li><a href="#CrimsonSkyline.block-Union{Tuple{F}, Tuple{F,Trace}} where F&lt;:Function"><code>CrimsonSkyline.block</code></a></li><li><a href="#CrimsonSkyline.block-Union{Tuple{F}, Tuple{F,Trace,Any}} where F&lt;:Function"><code>CrimsonSkyline.block</code></a></li><li><a href="#CrimsonSkyline.connect_pa_ch!-Tuple{Trace,Any,Any}"><code>CrimsonSkyline.connect_pa_ch!</code></a></li><li><a href="#CrimsonSkyline.copy_common!-Tuple{Trace,Trace}"><code>CrimsonSkyline.copy_common!</code></a></li><li><a href="#CrimsonSkyline.cpt-Tuple{L} where L&lt;:AbstractDict"><code>CrimsonSkyline.cpt</code></a></li><li><a href="#CrimsonSkyline.factor-Tuple{GraphIR}"><code>CrimsonSkyline.factor</code></a></li><li><a href="#CrimsonSkyline.factor-Tuple{Trace}"><code>CrimsonSkyline.factor</code></a></li><li><a href="#CrimsonSkyline.graph_ir-Tuple{Trace}"><code>CrimsonSkyline.graph_ir</code></a></li><li><a href="#CrimsonSkyline.importance_results-Tuple{}"><code>CrimsonSkyline.importance_results</code></a></li><li><a href="#CrimsonSkyline.interpret_latent!-Tuple{Trace,CrimsonSkyline.Interpretation}"><code>CrimsonSkyline.interpret_latent!</code></a></li><li><a href="#CrimsonSkyline.likelihood_weighting-Union{Tuple{F}, Tuple{F,Vararg{Any,N} where N}} where F&lt;:Function"><code>CrimsonSkyline.likelihood_weighting</code></a></li><li><a href="#CrimsonSkyline.load-Tuple{Any}"><code>CrimsonSkyline.load</code></a></li><li><a href="#CrimsonSkyline.log_acceptance_ratio-Tuple{Trace,Trace,CrimsonSkyline.Prior}"><code>CrimsonSkyline.log_acceptance_ratio</code></a></li><li><a href="#CrimsonSkyline.log_evidence-Tuple{CrimsonSkyline.ImportanceResults}"><code>CrimsonSkyline.log_evidence</code></a></li><li><a href="#CrimsonSkyline.loglatent-Tuple{Trace}"><code>CrimsonSkyline.loglatent</code></a></li><li><a href="#CrimsonSkyline.loglikelihood-Tuple{Trace}"><code>CrimsonSkyline.loglikelihood</code></a></li><li><a href="#CrimsonSkyline.logprob-Tuple{Trace}"><code>CrimsonSkyline.logprob</code></a></li><li><a href="#CrimsonSkyline.logprob-Tuple{Trace,Trace}"><code>CrimsonSkyline.logprob</code></a></li><li><a href="#CrimsonSkyline.logprob!-Tuple{Trace}"><code>CrimsonSkyline.logprob!</code></a></li><li><a href="#CrimsonSkyline.mh_step-Union{Tuple{F}, Tuple{Trace,F}} where F&lt;:Function"><code>CrimsonSkyline.mh_step</code></a></li><li><a href="#CrimsonSkyline.mh_step-Union{Tuple{F2}, Tuple{F1}, Tuple{Trace,F1,F2}} where F2&lt;:Function where F1&lt;:Function"><code>CrimsonSkyline.mh_step</code></a></li><li><a href="#CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{DataType,A,D,Bool,CrimsonSkyline.Interpretation}} where D where A"><code>CrimsonSkyline.node</code></a></li><li><a href="#CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{Any,A,D,Bool,CrimsonSkyline.Interpretation}} where D where A"><code>CrimsonSkyline.node</code></a></li><li><a href="#CrimsonSkyline.node-Union{Tuple{I}, Tuple{D}, Tuple{A}, Tuple{I,A,D,Bool,CrimsonSkyline.Interpretation}} where I&lt;:AbstractArray where D where A"><code>CrimsonSkyline.node</code></a></li><li><a href="#CrimsonSkyline.node_info-Tuple{Trace,Any}"><code>CrimsonSkyline.node_info</code></a></li><li><a href="#CrimsonSkyline.normalized_weights-Tuple{CrimsonSkyline.ImportanceResults}"><code>CrimsonSkyline.normalized_weights</code></a></li><li><a href="#CrimsonSkyline.observe-Tuple{Trace,Any,Any,Any}"><code>CrimsonSkyline.observe</code></a></li><li><a href="#CrimsonSkyline.pa_from_trace-Tuple{Trace,Any}"><code>CrimsonSkyline.pa_from_trace</code></a></li><li><a href="#CrimsonSkyline.prior-Union{Tuple{F}, Tuple{F,Union{Tuple, AbstractArray},Vararg{Any,N} where N}} where F&lt;:Function"><code>CrimsonSkyline.prior</code></a></li><li><a href="#CrimsonSkyline.propose-Tuple{Trace,Any,Any}"><code>CrimsonSkyline.propose</code></a></li><li><a href="#CrimsonSkyline.renormalize!-Tuple{CPT}"><code>CrimsonSkyline.renormalize!</code></a></li><li><a href="#CrimsonSkyline.replay-Union{Tuple{F}, Tuple{F,Trace}} where F&lt;:Function"><code>CrimsonSkyline.replay</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any,Replayed}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any,Standard}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any,Nonstandard}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Nonstandard}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{CrimsonSkyline.ImportanceResults,Any,Int64}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any,CrimsonSkyline.Blocked}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any,CrimsonSkyline.Blocked}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Replayed}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any,Deterministic}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.save-Tuple{Trace,Any}"><code>CrimsonSkyline.save</code></a></li><li><a href="#CrimsonSkyline.to_table-Tuple{Trace}"><code>CrimsonSkyline.to_table</code></a></li><li><a href="#CrimsonSkyline.trace-Tuple{}"><code>CrimsonSkyline.trace</code></a></li><li><a href="#CrimsonSkyline.transform-Union{Tuple{F}, Tuple{Trace,Any,F,Any}} where F&lt;:Function"><code>CrimsonSkyline.transform</code></a></li></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 17 April 2021 15:55">Saturday 17 April 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
