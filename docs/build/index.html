<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>CrimsonSkyline.jl · CrimsonSkyline.jl documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">CrimsonSkyline.jl documentation</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>CrimsonSkyline.jl</a><ul class="internal"><li><a class="tocitem" href="#trace"><span>trace</span></a></li><li><a class="tocitem" href="#field"><span>field</span></a></li><li><a class="tocitem" href="#io"><span>io</span></a></li><li><a class="tocitem" href="#effects"><span>effects</span></a></li><li><a class="tocitem" href="#basic-sampling-methods"><span>basic sampling methods</span></a></li><li><a class="tocitem" href="#importance"><span>importance</span></a></li><li><a class="tocitem" href="#metropolis"><span>metropolis</span></a></li><li><a class="tocitem" href="#nested"><span>nested</span></a></li><li><a class="tocitem" href="#results"><span>results</span></a></li><li><a class="tocitem" href="#statistics"><span>statistics</span></a></li><li><a class="tocitem" href="#kernel"><span>kernel</span></a></li><li><a class="tocitem" href="#inference"><span>inference</span></a></li><li><a class="tocitem" href="#db"><span>db</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>CrimsonSkyline.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>CrimsonSkyline.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com//blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="CrimsonSkyline.jl"><a class="docs-heading-anchor" href="#CrimsonSkyline.jl">CrimsonSkyline.jl</a><a id="CrimsonSkyline.jl-1"></a><a class="docs-heading-anchor-permalink" href="#CrimsonSkyline.jl" title="Permalink"></a></h1><h2 id="trace"><a class="docs-heading-anchor" href="#trace">trace</a><a id="trace-1"></a><a class="docs-heading-anchor-permalink" href="#trace" title="Permalink"></a></h2><p>To a large extent, <code>Node</code>s have local control over the behavior of inference algorithms via their  <code>interpretation</code>. There are a variety of <code>Interpretation</code>s.</p><pre><code class="language-none">abstract type Interpretation end
struct Nonstandard &lt;: Interpretation end
struct Standard &lt;: Interpretation end
struct Replayed &lt;: Interpretation end
struct Conditioned &lt;: Interpretation end 
struct Blocked &lt;: Interpretation end
struct Deterministic &lt;: Interpretation end
struct Proposed &lt;: Interpretation end</code></pre><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.ParametricNode" href="#CrimsonSkyline.ParametricNode"><code>CrimsonSkyline.ParametricNode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct ParametricNode{A, D, T} &lt;: Node
    address :: A
    dist :: D
    value :: Maybe{T}
    logprob :: Float64
    logprob_sum :: Float64
    observed :: Bool
    pa :: Array{Node, 1}
    ch :: Array{Node, 1}
    interpretation :: Union{Interpretation, Vector{Interpretation}}
    last_interpretation :: Union{Interpretation, Vector{Interpretation}}
end</code></pre><p>A <code>Node</code> that can be used with arbitrary code for which <code>rand</code> and <code>Distributionss.logpdf</code> are defined.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.SampleableNode" href="#CrimsonSkyline.SampleableNode"><code>CrimsonSkyline.SampleableNode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct SampleableNode{A, T} &lt;: Node
    address :: A
    dist :: Sampleable
    value :: Maybe{T}
    logprob :: Float64
    logprob_sum :: Float64
    observed :: Bool
    pa :: Array{Node, 1}
    ch :: Array{Node, 1}
    interpretation :: Union{Interpretation, Vector{Interpretation}}
    last_interpretation :: Union{Interpretation, Vector{Interpretation}}
end</code></pre><p>A <code>Node</code> that is restricted to be used with any <code>Sampleable</code> from <code>Distributions.jl</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.Trace" href="#CrimsonSkyline.Trace"><code>CrimsonSkyline.Trace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type Trace end</code></pre><p>Base type for all traces. <code>Trace</code>s support the following <code>Base</code> methods: <code>setindex!</code>, <code>getindex</code>, <code>keys</code>, <code>values</code>, and <code>length</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.TypedTrace" href="#CrimsonSkyline.TypedTrace"><code>CrimsonSkyline.TypedTrace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct TypedTrace{A, T} &lt;: Trace
    trace :: OrderedDict{A, SampleableNode{A, T}}
    logprob_sum :: Float64
end</code></pre><p>Trace that can hold nodes of the specific address (<code>A</code>) and value (<code>T</code>) types.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.UntypedTrace" href="#CrimsonSkyline.UntypedTrace"><code>CrimsonSkyline.UntypedTrace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct UntypedTrace
    trace :: OrderedDict{Any, Node}
    logprob_sum :: Float64
end</code></pre><p>Trace that can hold nodes with all address and value types. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.connect_pa_ch!-Tuple{Trace, Any, Any}" href="#CrimsonSkyline.connect_pa_ch!-Tuple{Trace, Any, Any}"><code>CrimsonSkyline.connect_pa_ch!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function connect_pa_ch!(t :: Trace, pa, a)</code></pre><p>Connects parent and child nodes. Adds child nodes to parent&#39;s <code>ch</code> and  parent nodes to child&#39;s <code>pa</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.input-Tuple{Trace, Any, Any}" href="#CrimsonSkyline.input-Tuple{Trace, Any, Any}"><code>CrimsonSkyline.input</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">input(t :: Trace, a, d)</code></pre><p>Track a model input.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.interpret_latent!-Tuple{Trace, Interpretation}" href="#CrimsonSkyline.interpret_latent!-Tuple{Trace, Interpretation}"><code>CrimsonSkyline.interpret_latent!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function interpret_latent!(t :: Trace, i :: Interpretation)</code></pre><p>Changes the interpretation of all latent nodes in <code>t</code> to have <code>interpretation == i</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.loglikelihood-Tuple{Trace}" href="#CrimsonSkyline.loglikelihood-Tuple{Trace}"><code>CrimsonSkyline.loglikelihood</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function loglikelihood(t :: Trace)</code></pre><p>Computes and returns the log likelihood of the observed data under the model:</p><p class="math-container">\[\ell(t) = 
\sum_{a:\ [a \in \text{keys}(t)] \wedge [\text{interpretation}(a) = \text{Standard}]} 
\log p(t[a])\]</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.logprob!-Tuple{Trace}" href="#CrimsonSkyline.logprob!-Tuple{Trace}"><code>CrimsonSkyline.logprob!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function logprob!(t :: Trace)</code></pre><p>Computes the joint log probability to the trace and assigns it to <code>t.logprob_sum</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.logprob-Tuple{Trace}" href="#CrimsonSkyline.logprob-Tuple{Trace}"><code>CrimsonSkyline.logprob</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function logprob(t :: Trace)</code></pre><p>Computes and returns the joint log probability of the trace:</p><p class="math-container">\[\log p(t) = \sum_{a \in \text{keys}(t)}\log p(t[a])\]</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{Any, A, D, Bool, Interpretation}} where {A, D&lt;:Distributions.Sampleable}" href="#CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{Any, A, D, Bool, Interpretation}} where {A, D&lt;:Distributions.Sampleable}"><code>CrimsonSkyline.node</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function node(value, address :: A, dist :: D, is_obs :: Bool, i :: Interpretation) where {A, D}</code></pre><p>Outer constructor for <code>Node</code> where data is passed during construction. Data type is inferred from the passed data.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{Any, A, D, Bool, Interpretation}} where {A, D}" href="#CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{Any, A, D, Bool, Interpretation}} where {A, D}"><code>CrimsonSkyline.node</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function node(value, address :: A, dist :: D, is_obs :: Bool, i :: Interpretation) where {A, D}</code></pre><p>Outer constructor for <code>Node</code> where data is passed during construction. Data type is inferred from the passed data.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{DataType, A, D, Bool, Interpretation}} where {A, D&lt;:Distributions.Sampleable}" href="#CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{DataType, A, D, Bool, Interpretation}} where {A, D&lt;:Distributions.Sampleable}"><code>CrimsonSkyline.node</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function node(T :: DataType, address :: A, dist :: D, is_obs :: Bool, i :: Interpretation) where {A, D}</code></pre><p>Outer constructor for <code>Node</code> where no data is passed during construction. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{DataType, A, D, Bool, Interpretation}} where {A, D}" href="#CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{DataType, A, D, Bool, Interpretation}} where {A, D}"><code>CrimsonSkyline.node</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function node(T :: DataType, address :: A, dist :: D, is_obs :: Bool, i :: Interpretation) where {A, D}</code></pre><p>Outer constructor for <code>Node</code> where no data is passed during construction. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.observe-Tuple{Trace, Any, Any, Any}" href="#CrimsonSkyline.observe-Tuple{Trace, Any, Any, Any}"><code>CrimsonSkyline.observe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function observe(t :: Trace, a, d, s; pa = ())</code></pre><p>If <code>d</code> is not <code>nothing</code> an alias for calling <code>sample</code> with standard interpretation.  Otherwise, an alias for calling <code>sample</code> with nonstandard interpretation. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.pa_from_trace-Tuple{Trace, Any}" href="#CrimsonSkyline.pa_from_trace-Tuple{Trace, Any}"><code>CrimsonSkyline.pa_from_trace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function pa_from_trace(t :: Trace, pa)</code></pre><p>Collects nodes in trace corresponding to an iterable of parent addresses <code>pa</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.plate-Union{Tuple{F}, Tuple{Trace, F, Any, Any, Int64, Conditioned}} where F&lt;:Function" href="#CrimsonSkyline.plate-Union{Tuple{F}, Tuple{Trace, F, Any, Any, Int64, Conditioned}} where F&lt;:Function"><code>CrimsonSkyline.plate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function plate(t::Trace, op::F, a, d, s::Int64, i::Conditioned; pa = ()) where F&lt;:Function</code></pre><p>Plate over conditioned variables.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.plate-Union{Tuple{F}, Tuple{Trace, F, Any, Any, Int64, CrimsonSkyline.Blocked}} where F&lt;:Function" href="#CrimsonSkyline.plate-Union{Tuple{F}, Tuple{Trace, F, Any, Any, Int64, CrimsonSkyline.Blocked}} where F&lt;:Function"><code>CrimsonSkyline.plate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function plate(t::Trace, op::F, a, d, s::Int64, i::Blocked; pa = ()) where F&lt;:Function</code></pre><p>Plate over blocked variables.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.plate-Union{Tuple{F}, Tuple{Trace, F, Any, Any, Int64, Nonstandard}} where F&lt;:Function" href="#CrimsonSkyline.plate-Union{Tuple{F}, Tuple{Trace, F, Any, Any, Int64, Nonstandard}} where F&lt;:Function"><code>CrimsonSkyline.plate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function plate(t::Trace, op::F, a, d, s::Int64, i::Nonstandard; pa = ()) where F&lt;:Function</code></pre><p>Plate over latent variables.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.plate-Union{Tuple{F}, Tuple{Trace, F, Any, Any, Int64, Replayed}} where F&lt;:Function" href="#CrimsonSkyline.plate-Union{Tuple{F}, Tuple{Trace, F, Any, Any, Int64, Replayed}} where F&lt;:Function"><code>CrimsonSkyline.plate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function plate(t::Trace, op::F, a, d, s::Int64, i::Replayed; pa = ()) where F&lt;:Function</code></pre><p>Plate over replayed variables. Note that this method assumes <em>and does not check</em> that the value to be replayed <code>v</code> satisfies <code>length(v) == s</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.plate-Union{Tuple{F}, Tuple{Trace, F, Any, Any, Int64}} where F&lt;:Function" href="#CrimsonSkyline.plate-Union{Tuple{F}, Tuple{Trace, F, Any, Any, Int64}} where F&lt;:Function"><code>CrimsonSkyline.plate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function plate(t::Trace, op::F, a, d, s::Int64; pa = ()) where F&lt;:Function</code></pre><p>Sample or observe a vector of random variables at a single site instead of multiple. This can speed up inference since the number of sites in the model will no longer scale with dataset size (though numerical value computation is still linear in dataset size).</p><p>Example usage: instead of</p><pre><code class="language-none">vals = [sample(t, &quot;val $i&quot;, Geometric()) for i in 1:N]</code></pre><p>we can write </p><pre><code class="language-none">vals = plate(t, sample, &quot;val&quot;, Geometric(), N)</code></pre><p>Mathematically, this is equivalent to the product <span>$p(z) = \prod_n p(z_n)$</span> and treating it as the single object <span>$p(z)$</span> instead of the <span>$N$</span> objects <span>$p(z_n)$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.plate-Union{Tuple{F}, Tuple{T}, Tuple{Trace, F, Any, Any, Vector{T}, Any}} where {T, F&lt;:Function}" href="#CrimsonSkyline.plate-Union{Tuple{F}, Tuple{T}, Tuple{Trace, F, Any, Any, Vector{T}, Any}} where {T, F&lt;:Function}"><code>CrimsonSkyline.plate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function plate(t::Trace, op::F, a, d, v::Vector{T}, params; pa = ()) where {T, F&lt;:Function}</code></pre><p>Plate over observed variables with different values but identical distribution, i.e., <span>$p(x|z) = \prod_n p(x_n | z_n)$</span>. This is as opposed to <code>plate(t::Trace, op::F, a, d, v::Vector{T}; pa = ())</code>, which is equivalent to <span>$p(x|z) = \prod_n p(x_n | z)$</span>.</p><p><code>params</code> must have the same length as <code>v</code>. Each element of <code>params</code> corresponds to a vector of that  particular component of the <code>params</code>, i.e., <span>$z = (z_1, ..., z_D)$</span> where each <span>$z_d$</span> has length <span>$N$</span>, the number of observed datapoints, and <span>$D$</span> is the cardinality of the parameterization of the  distribution.</p><p>E.g., replace </p><pre><code class="language-none">locs = sample(t, &quot;locs&quot;, MvNormal(D, 1.0))
for (i, (loc, d)) in enumerate(zip(locs, data))
    observe(t, &quot;data $i&quot;, Normal(loc, 1.0), d)
end</code></pre><p>with </p><pre><code class="language-none">locs = sample(t, &quot;locs&quot;, MvNormal(D, 1.0))
plate(t, observe, &quot;data&quot;, Normal, data, (locs, ones(D)))</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.plate-Union{Tuple{F}, Tuple{T}, Tuple{Trace, F, Any, Any, Vector{T}}} where {T, F&lt;:Function}" href="#CrimsonSkyline.plate-Union{Tuple{F}, Tuple{T}, Tuple{Trace, F, Any, Any, Vector{T}}} where {T, F&lt;:Function}"><code>CrimsonSkyline.plate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function plate(t::Trace, op::F, a, d, v::Vector{T}; pa = ()) where {T, F&lt;:Function}</code></pre><p>Plate over observed variables, i.e., a plated component of model likelihood. <code>v</code> is the  vector of observations, while <code>op</code> is likely <code>observe</code>.</p><p>Example usage: instead of</p><pre><code class="language-none">for (i, d) in enumerate(data)
    observe(t, &quot;data $i&quot;, Normal(loc, scale), d)
end</code></pre><p>we can write </p><pre><code class="language-none">plate(t, observe, &quot;data&quot;, Normal(loc, scale), data)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.propose-Tuple{Trace, Any, Any}" href="#CrimsonSkyline.propose-Tuple{Trace, Any, Any}"><code>CrimsonSkyline.propose</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">propose(t :: Trace, a, d)</code></pre><p>Propose a value for the address <code>a</code> in trace <code>t</code> from the distribution <code>d</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, CrimsonSkyline.Blocked}" href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, CrimsonSkyline.Blocked}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, d, params, i :: Blocked; pa = ())</code></pre><p>Samples from <code>d</code> passing the optional arguments <code>params</code>, deletes the node stored at address <code>a</code> from trace <code>t</code>, and returns the sampled value. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, Deterministic}" href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, Deterministic}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, f, v, i :: Deterministic; pa = ())</code></pre><p>Creates a deterministic node mapping the tuple of data <code>v</code> through function <code>f</code>,  storing the value in trace <code>t</code> at address <code>a</code>.</p><ol><li>Maps tuple of data <code>v</code> through function <code>f</code>, yielding <code>r = f(v...)</code></li><li>Creates a deterministic node and stores it in <code>t</code> at address <code>a</code></li><li>Optionally adds nodes corresponding to the addresses in <code>pa</code> as parent nodes</li><li>Returns <code>r</code></li></ol></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, Nonstandard}" href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, Nonstandard}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, d, params, i :: Nonstandard; pa = ())</code></pre><p>Samples from distribution <code>d</code> into trace <code>t</code> at address <code>a</code>.</p><ol><li>Samples a value from <code>d</code> passing the optional arguments <code>params</code></li><li>Creates a sample node</li><li>Adds the sample node to trace <code>t</code> at value <code>a</code></li><li>Optionally adds nodes corresponding to the addresses in <code>pa</code> as parent nodes</li><li>Returns the sampled value</li></ol></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, Replayed}" href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, Replayed}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, d, params, i :: Replayed; pa = ())</code></pre><p>Replays the sampled node through the trace. </p><ol><li>If <code>a</code> is not in <code>t</code>&#39;s address set, calls <code>sample(t, a, d, NONSTANDARD; pa = pa)</code>. </li><li>Creates a sample node that copies the value from the last node stored in the trace at address <code>a</code>. </li><li>Adds the sample node to trace <code>t</code> at value <code>a</code></li><li>Optionally adds nodes corresponding to the addresses in <code>pa</code> as parent nodes</li><li>Resets the node&#39;s interpretation to the original interpretation</li></ol></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, Standard}" href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, Standard}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, d, s, i :: Standard; pa = ())</code></pre><p>Scores an observed value <code>s</code> against the distribution <code>d</code>, storing the value in trace <code>t</code> at  address <code>a</code> and optionally adds nodes corresponding to the addresses in <code>pa</code> as parent nodes.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, Vector{Interpretation}}" href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, Vector{Interpretation}}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, d, params, ii :: Array{Interpretation, 1}; pa = ())</code></pre><p>Sequentially apply sample statements with interpretations as given in <code>ii</code>. This is  used to depth-first traverse the interpretation graph.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any}" href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, d, params; pa = ())</code></pre><p>If <code>a</code> is in the set of trace addresses, calls <code>sample</code> using <code>t[a]</code>&#39;s interpretation.  Otherwise, calls <code>sample</code> using nonstandard interpretation. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace, Any, Any, CrimsonSkyline.Blocked}" href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, CrimsonSkyline.Blocked}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, d, i :: Blocked; pa = ())</code></pre><p>Samples from <code>d</code>, deletes the node stored at address <code>a</code> from trace <code>t</code>, and returns the  sampled value. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace, Any, Any, Nonstandard}" href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Nonstandard}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, d, i :: Nonstandard; pa = ())</code></pre><p>Samples from distribution <code>d</code> into trace <code>t</code> at address <code>a</code>.</p><ol><li>Samples a value from <code>d</code></li><li>Creates a sample node</li><li>Adds the sample node to trace <code>t</code> at value <code>a</code></li><li>Optionally adds nodes corresponding to the addresses in <code>pa</code> as parent nodes</li><li>Returns the sampled value</li></ol></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace, Any, Any, Replayed}" href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Replayed}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, d, i :: Replayed; pa = ())</code></pre><p>Replays the sampled node through the trace. </p><ol><li>If <code>a</code> is not in <code>t</code>&#39;s address set, calls <code>sample(t, a, d, NONSTANDARD; pa = pa)</code>. </li><li>Creates a sample node that copies the value from the last node stored in the trace at address <code>a</code>. </li><li>Adds the sample node to trace <code>t</code> at value <code>a</code></li><li>Optionally adds nodes corresponding to the addresses in <code>pa</code> as parent nodes</li><li>Resets the node&#39;s interpretation to the original interpretation</li></ol></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace, Any, Any, Union{Conditioned, Standard}}" href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Union{Conditioned, Standard}}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, d, i :: Union{Standard,Conditioned}; pa = ())</code></pre><p>Scores an observed value against the distribution <code>d</code>, storing the value in trace <code>t</code> at  address <code>a</code> and optionally adds nodes corresponding to the addresses in <code>pa</code> as parent nodes.</p><p>This method is used by the <code>condition</code> effect. It will probably not be used by most  users.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace, Any, Any, Vector{Interpretation}}" href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Vector{Interpretation}}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, d, ii :: Array{Interpretation, 1}; pa = ())</code></pre><p>Sequentially apply sample statements with interpretations as given in <code>ii</code>. This is  used to depth-first traverse the interpretation graph.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace, Any, Any}" href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, d; pa = ())</code></pre><p>If <code>a</code> is in the set of trace addresses, calls <code>sample</code> using <code>t[a]</code>&#39;s interpretation.  Otherwise, calls <code>sample</code> using nonstandard interpretation. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.trace-Tuple{Any, Any}" href="#CrimsonSkyline.trace-Tuple{Any, Any}"><code>CrimsonSkyline.trace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">trace(A, T)</code></pre><p>This is the recommended way to construct a new typed trace. <code>A</code> is the address type, <code>T</code> is the value type.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.trace-Tuple{}" href="#CrimsonSkyline.trace-Tuple{}"><code>CrimsonSkyline.trace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">trace()</code></pre><p>This is the recommended way to construct a new trace.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.transform-Union{Tuple{F}, Tuple{Trace, Any, F, Any}} where F&lt;:Function" href="#CrimsonSkyline.transform-Union{Tuple{F}, Tuple{Trace, Any, F, Any}} where F&lt;:Function"><code>CrimsonSkyline.transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function transform(t :: Trace, a, f :: F, v; pa = ()) where F &lt;: Function</code></pre><p>Alias for <code>sample(t, a, f, v, DETERMINISTIC; pa = pa)</code>.</p></div></section></article><h2 id="field"><a class="docs-heading-anchor" href="#field">field</a><a id="field-1"></a><a class="docs-heading-anchor-permalink" href="#field" title="Permalink"></a></h2><p><code>CrimsonSkyline</code> also includes methods for sampling from undirected models.</p><h3 id="Using-Metropolis-Hastings"><a class="docs-heading-anchor" href="#Using-Metropolis-Hastings">Using Metropolis-Hastings</a><a id="Using-Metropolis-Hastings-1"></a><a class="docs-heading-anchor-permalink" href="#Using-Metropolis-Hastings" title="Permalink"></a></h3><p>Here is an example (taken directly from the tests!). Suppose we have three variables <span>$a$</span>, <span>$b$</span>, and <span>$c$</span>,  with field structure <code>a - b - c</code>  and continuous factors  <span>$\psi_{a,b}(a, b) = \mathrm{MvNormal}(0, \Sigma_{a,b})$</span> with <span>$\Sigma_{a,b} = \begin{pmatrix} 1.0 &amp; 0.5 \\ 0.5 &amp; 1.0 \end{pmatrix}$</span> and <span>$\psi_{b,c}(b, c) = \mathrm{MvNormal}(\begin{pmatrix} 2.0 &amp; 2.0 \end{pmatrix}, \Sigma_{b,c})$</span> with  <span>$\Sigma_{b,c} = \begin{pmatrix} 2.0 &amp; -1.0 \\ -1.0 &amp; 2.0 \end{pmatrix}$</span>. We can construct the factors using two ordinary functions:</p><pre><code class="language-none">factor_ab(x) = logpdf(MvNormal(PDMat([1.0 0.5; 0.5 1.0])), x)
factor_bc(x) = logpdf(MvNormal([2.0, 2.0], PDMat([2.0 -1.0; -1.0 2.0])), x)</code></pre><p>Suppose that we observe the data <code>b = 3.0</code>.  We can instantiate the <code>RandomField</code> object with the factors and this evidence as follows:</p><pre><code class="language-none">factors = Dict([&quot;a&quot;, &quot;b&quot;] =&gt; factor_ab, [&quot;b&quot;, &quot;c&quot;] =&gt; factor_bc)
evidence = Dict(&quot;b&quot; =&gt; 3.0)
field = RandomField(factors, evidence)</code></pre><p>In general one cannot sample from random fields directly and instead must use a method  such as belief propagation or approximate inference methods.  Here we use Metropolis Hastings. We define a proposal kernel that can (a) propose new values and (b) score those values in comparison with old sampled values.  This functionality can be implemented as a function, but we will implement a struct to capture some proposal kernel state (namely, the standard deviation of a  proposal distribution).  We define the proposal kernel as follows:</p><pre><code class="language-none">struct FactorProposal
    addresses :: Vector{String}
    last :: Vector{String}
    std :: Float64
end
FactorProposal(addresses) = FactorProposal(addresses, [addresses[1]], 0.5)
function (fp::FactorProposal)(x::Dict)
    new = deepcopy(x)
    address = rand(fp.addresses)
    new[address] = randn() * fp.std + new[address]
    fp.last[1] = address
    new
end
function (fp::FactorProposal)(x_prime::Dict, x::Dict)
    address = fp.last[1]
    logpdf(Normal(x[address], fp.std), x_prime[address]) - log(length(fp.addresses))
end</code></pre><p>This is pretty straighforward: calling <code>fp(x)</code> generates a proposal <code>x_prime</code> i.e., <span>$x&#39; \sim q(x)$</span> (which in this case is just a random walk step away from the  current point) and calling <code>fp(x_prime, x)</code> computes the transition  probability <span>$q(x&#39; | x)$</span>.  Once we have the proposal in hand, we can sample from the posterior  <span>$p(a, c | b = 3.0)$</span> by calling <code>mh(...)</code> just as in the case of trace-based models:</p><pre><code class="language-none">addresses = [&quot;a&quot;, &quot;c&quot;]
proposal = FactorProposal(addresses)
initial_values = Dict(&quot;a&quot; =&gt; 0.0, &quot;b&quot; =&gt; 3.0, &quot;c&quot; =&gt; 0.0)
samples = mh(field, [proposal], initial_values; burn=1000, thin=100, num_iterations=11000)</code></pre><p>Because <code>RandomField</code>s aren&#39;t generative models, we have to seed the MH algorithm with an  initial value for each address. (In this case, the value used to seed <code>&quot;b&quot;</code> isn&#39;t used  by <code>mh</code> because we&#39;ve posted evidence to that address; if we just wanted to sample from  <span>$p(a, b, c)$</span> without posting evidence, the initiaizer <code>&quot;b&quot; =&gt; 3.0</code> would be used.) We can visualize the marginal posteriors <span>$p(a|b=3.0)$</span> and <span>$p(c | b = 3.0)$</span> below (using the built-in <code>plot_marginal</code>): <img src="../../test/out/factor-marginal-a.png" alt="marginal factor a"/> <img src="../../test/out/factor-marginal-c.png" alt="marginal factor c"/></p><p>In combination with a proposal kernel and MH initialization point, random fields can be used in <code>CrimsonSkyline</code>&#39;s trace-based PPL. There is convenience wrapper  to bundle these components together called <code>GenerativeField</code>. Here is an example of using it in the trace-based PPL:</p><pre><code class="language-none">t = trace()
upstream_value = sample(t, &quot;a&quot;, Normal())
# to pass upstream values as parameters to the random field
# just post them as evidence
field = RandomField(factors, Dict(&quot;a&quot; =&gt; upstream_value))
proposal = FactorProposal([&quot;b&quot;, &quot;c&quot;])
init = Dict(&quot;a&quot; =&gt; 0.0, &quot;b&quot; =&gt; 0.0, &quot;c&quot; =&gt; 0.0)
gf = GenerativeField(field, proposal, init)
sample(t, &quot;field&quot;, gf)</code></pre><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.GenerativeField" href="#CrimsonSkyline.GenerativeField"><code>CrimsonSkyline.GenerativeField</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct GenerativeField{T}
    field::RandomField
    proposal::T
    val::Dict
    ...
end</code></pre><p>A generative field is a three-tuple of a random field <code>field</code>, a proposal kernel <code>proposal</code>, and an initialization value <code>val</code> used to start MH sampling. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.RandomField" href="#CrimsonSkyline.RandomField"><code>CrimsonSkyline.RandomField</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct RandomField 
    names::Set{String}
    factors::Dict{Vector{String},Function}
    evidence::Dict{String,Any}
end</code></pre><p>A representation of a random field by a collection of factors:  <span>$\log p(x) = \sum_{f \in \mathcal F} \log \psi_f(x_f)$</span>, where  <span>$\mathcal F$</span> is the set of (log) factors and <span>$x_f$</span> is the set of variables incident on that (log) factor. <code>factors</code> should be properly normalized <em>log</em> mass or density functions. There is no restriction on the state space of the variables involved as long as the factor functions can evaluate the log probability of the variables. For example, </p><pre><code class="language-none">factor_ab(x) = logpdf(MvNormal(PDMat([1.0 0.5; 0.5 1.0])), x)
factor_bc(x) = logpdf(MvNormal([2.0, 2.0], PDMat([2.0 -1.0; -1.0 2.0])), x)</code></pre><p>are two valid (log) factor functions – the first corresponding to the factor <span>$\log \psi_{a,b}(x_a,x_b)$</span> and the second corresponding to the factor <span>$\log \psi_{b,c}(x_b, x_c)$</span>. Posting evidence is done using a dictionary mapping an address to value,  e.g., <code>evidence = Dict(&quot;b&quot; =&gt; 3.0)</code>.</p><p>Calling a random field corresponds to evaluating its log probability with the passed argument, e.g., </p><pre><code class="language-none">my_rf = RandomField(...)
x = Dict(&quot;a&quot; =&gt; 1.0, &quot;b&quot; =&gt; -2.1)
my_lp = my_rf(x)  # corresponds to logprob(my_rf, x)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.RandomField-Tuple{Dict{Vector{String}, Function}, Dict}" href="#CrimsonSkyline.RandomField-Tuple{Dict{Vector{String}, Function}, Dict}"><code>CrimsonSkyline.RandomField</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function RandomField(factors::Dict{Vector{String},Function}, evidence::Dict)</code></pre><p>Outer constructor for <code>RandomField</code> that requires a dict of factors and allows posting evidence when the field is created (instead of manually doing so later).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.RandomField-Tuple{Dict{Vector{String}, Function}}" href="#CrimsonSkyline.RandomField-Tuple{Dict{Vector{String}, Function}}"><code>CrimsonSkyline.RandomField</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function RandomField(factors::Dict{Vector{String},Function})</code></pre><p>Outer constuctor for <code>RandomField</code> that requires only a dict of factors.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.rand-Tuple{GenerativeField}" href="#Base.rand-Tuple{GenerativeField}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function Distributions.rand(gf::GenerativeField; num_iterations=2500)</code></pre><p>Sample from a generative fied using <code>num_iterations</code> of MH sampling. The value generated by MH at the end of <code>num_iterations</code> of sampling is returned. To customize burn-in, you can just overload this function, e.g. <code>rand(gf::GenerativeField) = rand(gf; num_iterations=10000)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.logprob-Tuple{RandomField, Dict}" href="#CrimsonSkyline.logprob-Tuple{RandomField, Dict}"><code>CrimsonSkyline.logprob</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function logprob(rf::RandomField, x::Dict)</code></pre><p>Evaluates the log probability of a set of values against the density described by the random field <code>rf</code>. The values <code>x</code> should have the format <code>address =&gt; value</code>.</p></div></section></article><h2 id="io"><a class="docs-heading-anchor" href="#io">io</a><a id="io-1"></a><a class="docs-heading-anchor-permalink" href="#io" title="Permalink"></a></h2><p>Saving and loading traces and <code>SamplingResults</code> is possible using the <code>save</code> and <code>load</code> functions. This functionality depends on <code>JuliaDB</code>. </p><p>Examples: </p><pre><code class="language-none"># simple example model
function io_model(t::Trace, dim::Int64, data::Int64)
    z = sample(t, &quot;z&quot;, Dirichlet(ones(dim)))
    observe(t, &quot;x&quot;, Categorical(z), data)
end

# saving a trace
t = trace()
dim = 10
data = 7
io_model(t, dim, data)
testpath = joinpath(@__DIR__, &quot;TESTIO&quot;)
db_file = joinpath(testpath, &quot;test.jdb&quot;)
save(t, db_file)

# loading a trace
loaded_trace = load(db_file)

# creating and saving some results
results = mh(io_model; params = (dim, data), burn = 0, thin = 1, num_iterations=10)
results_file = joinpath(testpath, &quot;io_model.csm&quot;)
save(results, results_file)

# loading saved results and use to serve model
loaded_results = load(joinpath(testpath, &quot;io_model.csm&quot;))
updated_model = update(io_model, loaded_results)  # update effect, see effects.jl
new_t, _ = updated_model(trace(), dim, data)</code></pre><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.load-Tuple{Any}" href="#CrimsonSkyline.load-Tuple{Any}"><code>CrimsonSkyline.load</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function load(f)</code></pre><p>Load a <code>Trace</code> or <code>SamplingResults</code> object from file. The file must be saved in JuliaDB format with ending <code>.jdb</code>, which will be interpreted as a single saved trace, or must be a directory with ending <code>.csm</code>, which will be interpreted as a <code>SamplingResults</code> object.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.load_csm-Tuple{Any}" href="#CrimsonSkyline.load_csm-Tuple{Any}"><code>CrimsonSkyline.load_csm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function load_csm(f) :: SamplingResults</code></pre><p>Loads a <code>SamplingResults</code> from a directory. The directory contains <code>metadata.txt</code>, which currently stores the interpretation of the <code>SamplingResults</code> (i.e., what kind of  algorithm generated those results), and a file <code>results.jdb</code>, which is a JuliaDB table of the results.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.load_jdb-Tuple{Any}" href="#CrimsonSkyline.load_jdb-Tuple{Any}"><code>CrimsonSkyline.load_jdb</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function load_jdb(f) :: Trace</code></pre><p>Loads a serialized juliadb table from file <code>f</code> and converts it into a trace.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.save-Tuple{CrimsonSkyline.SamplingResults, Any}" href="#CrimsonSkyline.save-Tuple{CrimsonSkyline.SamplingResults, Any}"><code>CrimsonSkyline.save</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function save(r :: SamplingResults, f)</code></pre><p>Saves a <code>SamplingResults</code> to disk in the directory <code>f</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.save-Tuple{Trace, Any}" href="#CrimsonSkyline.save-Tuple{Trace, Any}"><code>CrimsonSkyline.save</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function save(t :: Trace, f)</code></pre><p>Saves a trace to disk at the filepath <code>f</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.to_table-Tuple{Trace}" href="#CrimsonSkyline.to_table-Tuple{Trace}"><code>CrimsonSkyline.to_table</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function to_table(t :: Trace)</code></pre><p>Turns a trace into a juliadb table. Does not store parent / child relationships.</p></div></section></article><h2 id="effects"><a class="docs-heading-anchor" href="#effects">effects</a><a id="effects-1"></a><a class="docs-heading-anchor-permalink" href="#effects" title="Permalink"></a></h2><p>A library of functions that change the interpretation of some or all nodes in a trace.</p><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.block-Tuple{Any, Trace}" href="#CrimsonSkyline.block-Tuple{Any, Trace}"><code>CrimsonSkyline.block</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">block(f :: F, t :: Trace) where F &lt;: Function</code></pre><p>Converts all traced randomness into untraced randomness.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.block-Union{Tuple{T}, Tuple{Any, T, Any}} where T&lt;:Trace" href="#CrimsonSkyline.block-Union{Tuple{T}, Tuple{Any, T, Any}} where T&lt;:Trace"><code>CrimsonSkyline.block</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function block(f, t :: T, addresses) where T &lt;: Trace</code></pre><p>Given a stochastic function <code>f</code>, a trace <code>t</code>, and an iterable of addresses, converts traced randomness into untraced randomness. </p><p>Returns a tuple <code>(t_new, g)</code>, where <code>t_new</code> is a trace and <code>g</code> is a function. The function signature of <code>g</code> is the same as that of <code>f</code> with the first argument removed; that is, if <code>f(t :: Trace, params...)</code>, then <code>g(params...)</code>. Computation is delayed, so each of  the latent nodes in <code>t_new</code> has <code>interpretation = BLOCKED</code>. Calling <code>g(params...)</code> executes the  computation and each latent node in <code>t_new</code> with an address in <code>addresses</code> is removed.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.condition-Tuple{Any, Dict}" href="#CrimsonSkyline.condition-Tuple{Any, Dict}"><code>CrimsonSkyline.condition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function condition(f, evidence :: Dict)</code></pre><p>Condition a trace modified by <code>f</code> on <code>evidence</code>, which maps addresses to observed  evidence associated with that address. Returns a function with call signature  identical to that of <code>f</code> and return signature <code>(t :: Trace, rtype)</code> where <code>rtype</code> is the return type of <code>f</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.replace-Tuple{Any, Dict}" href="#CrimsonSkyline.replace-Tuple{Any, Dict}"><code>CrimsonSkyline.replace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function replace(f, r :: Dict)</code></pre><p>Given a mapping <code>r</code> from addresses to distribution-like (currently <code>Distributions</code> or <code>Array{Any, 1}</code>s), replaces the current distributions at that set of addresses with this set of distributions. Returns a function <code>g</code> that has return signature  <code>(t :: Trace, rval)</code> where <code>rval</code> is a return value of <code>f</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.replace-Union{Tuple{T}, Tuple{T, Dict}} where T&lt;:Trace" href="#CrimsonSkyline.replace-Union{Tuple{T}, Tuple{T, Dict}} where T&lt;:Trace"><code>CrimsonSkyline.replace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function replace(t :: Trace, r :: Dict)</code></pre><p>Given a mapping <code>r</code> from addresses to distribution-like (currently <code>Distributions</code> or <code>Array{Any, 1}</code>s), replaces the current distributions at that set of addresses with this set of distributions. Returns the modified trace.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.replay-Union{Tuple{T}, Tuple{Any, T}} where T&lt;:Trace" href="#CrimsonSkyline.replay-Union{Tuple{T}, Tuple{Any, T}} where T&lt;:Trace"><code>CrimsonSkyline.replay</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function replay(f, t :: T) where T &lt;: Trace</code></pre><p>Given a stochastic function <code>f</code> and a trace <code>t</code>, makes <code>sample</code> calls behave as though  they had sampled the values in <code>t</code> at the corresponding addresses. </p><p>Returns a tuple <code>(t_new, g)</code>, where <code>t_new</code> is a trace and <code>g</code> is a function. The function signature of <code>g</code> is the same as that of <code>f</code> with the first argument removed; that is, if <code>f(t :: Trace, params...)</code>, then <code>g(params...)</code>. Computation is delayed, so each of the latent nodes in <code>t_new</code> has <code>interpretation = REPLAYED</code>. Calling <code>g(params...)</code> executes the computation and each latent node in <code>t_new</code> reverts to  its original interpretation. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.rewrite-Union{Tuple{T}, Tuple{Any, T, Dict}} where T&lt;:Trace" href="#CrimsonSkyline.rewrite-Union{Tuple{T}, Tuple{Any, T, Dict}} where T&lt;:Trace"><code>CrimsonSkyline.rewrite</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function rewrite(f, t :: T, r :: Dict) where T &lt;: Trace</code></pre><p>Rewrites the history of the trace to make it appear as if the values in the trace were sampled at the addresses in the keys of <code>r</code> from the corresponding distributions in the values of <code>r</code>.  Returns a function with call signature <code>g(params...)</code> that returns <code>(t :: Trace, rval)</code>, where <code>rval</code>  is the return type of <code>f</code>. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.update-Union{Tuple{I}, Tuple{Any, CrimsonSkyline.SamplingResults{I}}} where I&lt;:CrimsonSkyline.InferenceType" href="#CrimsonSkyline.update-Union{Tuple{I}, Tuple{Any, CrimsonSkyline.SamplingResults{I}}} where I&lt;:CrimsonSkyline.InferenceType"><code>CrimsonSkyline.update</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function update(f, r :: SamplingResults{I}) where I &lt;: InferenceType</code></pre><p>Given a stochastic function <code>f</code> and a <code>SamplingResults</code> <code>r</code>, update the prior  predictive to the posterior predictive by jointly replacing all latent sample sites with the joint empirical  posterior. Returns a stochastic function <code>g</code> with the same call signature as <code>f</code>. This function will modify in  place the trace passed into it as the first argument.</p></div></section></article><h2 id="basic-sampling-methods"><a class="docs-heading-anchor" href="#basic-sampling-methods">basic sampling methods</a><a id="basic-sampling-methods-1"></a><a class="docs-heading-anchor-permalink" href="#basic-sampling-methods" title="Permalink"></a></h2><p>Simple samplers such as forward and rejection sampling can be done &quot;by hand&quot;, but convenience methods are implemented to facilitate postprocessing of results.</p><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.forward_sampling-Tuple{Any}" href="#CrimsonSkyline.forward_sampling-Tuple{Any}"><code>CrimsonSkyline.forward_sampling</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function forward_sampling(f; params = (), num_iterations = 1)</code></pre><p>Draws samples from the model&#39;s joint density. Equivalent to calling <code>f</code> in a loop <code>num_iterations</code> times, but results are collected in a  <code>NonparametricSamplingResults</code> for easier postprocessing.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.rejection-Tuple{Any, Float64, Vararg{Any, N} where N}" href="#CrimsonSkyline.rejection-Tuple{Any, Float64, Vararg{Any, N} where N}"><code>CrimsonSkyline.rejection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function rejection(f, log_l :: Float64, params...)</code></pre><p>Samples from the prior with the hard likelihood constraint <span>$\log L_k &gt;$</span> <code>log_l</code>.</p><p>Args:</p><ul><li><code>f</code> stochastic function. Must have signature <code>f(t :: Trace, params...)</code></li><li><code>log_l</code>: current log likelihood threshold </li><li><code>params</code>: any additional arguments to pass to <code>f</code></li></ul></div></section></article><h2 id="importance"><a class="docs-heading-anchor" href="#importance">importance</a><a id="importance-1"></a><a class="docs-heading-anchor-permalink" href="#importance" title="Permalink"></a></h2><p>Importance sampling algorithms and utilities.  Currently the following importance sampling algorithms are implemented:</p><ul><li>Likelihood weighting</li><li>Generic user-defined proposal</li></ul><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.importance_sampling-Tuple{Any, Any, Tuple{DataType, DataType}}" href="#CrimsonSkyline.importance_sampling-Tuple{Any, Any, Tuple{DataType, DataType}}"><code>CrimsonSkyline.importance_sampling</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function importance_sampling(f, q, types::Tuple{DataType,DataType}; params = (), nsamples :: Int = 1)</code></pre><p>Given a stochastic function <code>f</code>, a proposal function <code>q</code>, and a tuple of <code>params</code> to pass to <code>f</code> and <code>q</code>, compute <code>nsamples</code> iterations of importance sampling. <code>q</code> must have the same input signature  as <code>f</code>. Returns a <code>SamplingResults</code> instance.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.importance_sampling-Tuple{Any, Any}" href="#CrimsonSkyline.importance_sampling-Tuple{Any, Any}"><code>CrimsonSkyline.importance_sampling</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function importance_sampling(f, q; params = (), nsamples :: Int = 1)</code></pre><p>Given a stochastic function <code>f</code>, a proposal function <code>q</code>, and a tuple of <code>params</code> to pass to <code>f</code> and <code>q</code>, compute <code>nsamples</code> iterations of importance sampling. <code>q</code> must have the same input signature  as <code>f</code>. Returns a <code>SamplingResults</code> instance.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.is_step-Tuple{Any, Any, Tuple{DataType, DataType}}" href="#CrimsonSkyline.is_step-Tuple{Any, Any, Tuple{DataType, DataType}}"><code>CrimsonSkyline.is_step</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function is_step(f, q, types::Tuple{DataType,DataType}; params = ())</code></pre><p>Perform one step of importance sampling – draw a single sample from the proposal <code>q</code>, replay  it through <code>f</code>, and record the log weight as <span>$\log W_n = \log p(x, z_n) - \log q(z_n)$</span>. Returns a tuple (log weight, rval, trace). </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.is_step-Tuple{Any, Any}" href="#CrimsonSkyline.is_step-Tuple{Any, Any}"><code>CrimsonSkyline.is_step</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function is_step(f, q; params = ())</code></pre><p>Perform one step of importance sampling – draw a single sample from the proposal <code>q</code>, replay  it through <code>f</code>, and record the log weight as <span>$\log W_n = \log p(x, z_n) - \log q(z_n)$</span>. Returns a tuple (log weight, rval, trace). </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.likelihood_weighting-Tuple{Any, Tuple{DataType, DataType}, Vararg{Any, N} where N}" href="#CrimsonSkyline.likelihood_weighting-Tuple{Any, Tuple{DataType, DataType}, Vararg{Any, N} where N}"><code>CrimsonSkyline.likelihood_weighting</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function likelihood_weighting(f, types::Tuple{DataType, DataType}, params...; nsamples :: Int = 1)</code></pre><p>Given a stochastic function f and arguments to the function <code>params...</code>, executes <code>nsamples</code> iterations of importance sampling by using the prior as a proposal distribution. The importance weights are given by <span>$\log W_n = \ell(t_n)$</span>. Returns an <code>SamplingResults</code> instance. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.likelihood_weighting-Tuple{Any, Vararg{Any, N} where N}" href="#CrimsonSkyline.likelihood_weighting-Tuple{Any, Vararg{Any, N} where N}"><code>CrimsonSkyline.likelihood_weighting</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function likelihood_weighting(f, params...; nsamples :: Int = 1)</code></pre><p>Given a stochastic function f and arguments to the function <code>params...</code>, executes <code>nsamples</code> iterations of importance sampling by using the prior as a proposal distribution. The importance weights are given by <span>$\log W_n = \ell(t_n)$</span>. Returns an <code>SamplingResults</code> instance. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.likelihood_weighting_results-Tuple{}" href="#CrimsonSkyline.likelihood_weighting_results-Tuple{}"><code>CrimsonSkyline.likelihood_weighting_results</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">likelihood_weighting_results()</code></pre><p>Outer constructor for <code>SamplingResults</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.log_evidence-Union{Tuple{CrimsonSkyline.SamplingResults{I}}, Tuple{I}} where I&lt;:CrimsonSkyline.Importance" href="#CrimsonSkyline.log_evidence-Union{Tuple{CrimsonSkyline.SamplingResults{I}}, Tuple{I}} where I&lt;:CrimsonSkyline.Importance"><code>CrimsonSkyline.log_evidence</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function log_evidence(r :: SamplingResults{LikelihoodWeighting})</code></pre><p>Computes the log evidence (log partition function), </p><p><span>$\log Z \equiv \log p(x) \approx -\log N_{\text{samples}} + \log \sum_{n=1}^{N_{\text{samples}}} W_n.$</span></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.lw_step-Tuple{Any, Tuple{DataType, DataType}, Vararg{Any, N} where N}" href="#CrimsonSkyline.lw_step-Tuple{Any, Tuple{DataType, DataType}, Vararg{Any, N} where N}"><code>CrimsonSkyline.lw_step</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function lw_step(f, types::Tuple{DataType, DataType}, params...)</code></pre><p>Perform one step of likelihood weighting – draw a single proposal from the prior and compute  the log weight as equal to the likelihood. Returns a tuple (log weight, rval, trace).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.lw_step-Tuple{Any, Vararg{Any, N} where N}" href="#CrimsonSkyline.lw_step-Tuple{Any, Vararg{Any, N} where N}"><code>CrimsonSkyline.lw_step</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function lw_step(f, params...)</code></pre><p>Perform one step of likelihood weighting – draw a single proposal from the prior and compute  the log weight as equal to the likelihood. Returns a tuple (log weight, rval, trace).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.normalized_weights-Union{Tuple{CrimsonSkyline.SamplingResults{I}}, Tuple{I}} where I&lt;:CrimsonSkyline.Importance" href="#CrimsonSkyline.normalized_weights-Union{Tuple{CrimsonSkyline.SamplingResults{I}}, Tuple{I}} where I&lt;:CrimsonSkyline.Importance"><code>CrimsonSkyline.normalized_weights</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function normalized_weights(r :: SamplingResults{LikelihoodWeighting})</code></pre><p>Computes the normalized weights <span>$w_n$</span> from unnormalized weights <span>$W_n$</span>:</p><p><span>$w_n = W_n / p(x) = \exp\{\ell(t_n) - \log Z\}.$</span></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Union{Tuple{I}, Tuple{CrimsonSkyline.SamplingResults{I}, Any, Int64}} where I&lt;:CrimsonSkyline.Importance" href="#CrimsonSkyline.sample-Union{Tuple{I}, Tuple{CrimsonSkyline.SamplingResults{I}, Any, Int64}} where I&lt;:CrimsonSkyline.Importance"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(r :: SamplingResults{LikelihoodWeighting}, k, n :: Int)</code></pre><p>Draws <code>n</code> samples from the empirical marginal posterior at address <code>k</code>.</p></div></section></article><h2 id="metropolis"><a class="docs-heading-anchor" href="#metropolis">metropolis</a><a id="metropolis-1"></a><a class="docs-heading-anchor-permalink" href="#metropolis" title="Permalink"></a></h2><p>Metropolis algorithm and utilities. Currently the following algorithms are implemented for both  FOPPL and HOPPL programs:</p><ul><li>Independent prior proposal</li><li>Arbitrary single- or multi-site proposal</li></ul><p>Here are two examples of inference using the arbitrary MH step interface. Consider the following generative function:</p><pre><code class="language-none">function normal_model(t :: Trace, data :: Vector{Float64})
    loc = sample(t, :loc, Normal(0.0, 10.0))
    scale = sample(t, :scale, LogNormal())
    for i in 1:length(data)
        observe(t, (:obs, i), Normal(loc, scale), data[i])
    end
end</code></pre><p>To learn an approximate posterior for <code>:loc</code> and <code>:scale</code>, we will introduce two proposal kernels:</p><pre><code class="language-none">loc_proposal(old_t :: Trace, new_t :: Trace, data) = propose(new_t, :loc, Normal(old_t[:loc].value, 0.25))
scale_proposal(old_t :: Trace, new_t :: Trace, data) = propose(new_t, :scale, truncated(Normal(old_t[:scale].value, 0.25), 0.0, Inf))</code></pre><p>Note that while <code>loc_proposal</code> is symmetric, <code>scale_proposal</code> is not. To perform inference, we pass these kernels to <code>mh_step</code> in  a loop after first drawing a random trace:</p><pre><code class="language-none">t = trace()
normal_model(t, data)
for i in 1:niter
    t = mh_step(t, normal_model, loc_proposal; params = (data,))
    t = mh_step(t, normal_model, scale_proposal; params = (data,))
end</code></pre><p>In this case, inference was fairly successful:</p><pre><code class="language-none">[ Info: True loc = 4.0
[ Info: True std = 1.0
[ Info: inferred E[loc] = 4.022688081613082
[ Info: inferred E[scale] = 0.9696559373495869
[ Info: approximate p(x) = sum_z p(x|z) = -138.63530736205144</code></pre><p>As a less trivial (but still contrived!) inference example, we can infer the posterior distribution of a latent discrete random variable in an open-universe model: </p><pre><code class="language-none">function random_sum_model(t :: Trace, data)
    n = sample(t, :n, Geometric(0.1))
    loc = 0.0
    for i in 1:(n + 1)
        loc += sample(t, (:loc, i), Normal())
    end
    obs = Array{Float64, 1}()
    for j in 1:length(data)
        o = observe(t, (:data, j), Normal(loc, 1.0), data[j])
        push!(obs, o)
    end
    obs
end</code></pre><p>(N.B.: we write the model is this form for pedagogic reasons; there is a far more efficient way to express the latent structure  of this model, namely <span>$n \sim \text{Geometric}(0.1)$</span>, <span>$\text{loc} \sim \text{Normal}(0, n)$</span>.) We are interested in learning the posterior distribution of <code>:n</code>. We introduce two proposal distributions, one for the latent discrete rv and another generic proposal for the location increments:</p><pre><code class="language-none">function random_n_proposal(old_trace, new_trace, params...)
    old_n = float(old_trace[:n].value)
    if old_n &gt; 0
        propose(new_trace, :n, Poisson(old_n))
    else
        propose(new_trace, :n, Poisson(1.0))
    end
end

gen_loc_proposal(old_trace, new_trace, ix, params...) = propose(new_trace, (:loc, ix), Normal(old_trace[(:loc, ix)].value, 0.25))</code></pre><p>We again conduct inference by simply applying proposals within a loop. This time, the number of location increment proposals we need to  construct is dependent on the sampled values of the latent random variable. We can either create these proposals on the fly as they&#39;re  needed or create what is nearly guaranteed to be enough of them before any inference is performed, e.g.,  <code>loc_proposals = [(o, n, params...) -&gt; gen_loc_proposal(o, n, i, params...) for i in 1:100]</code>. Now that we have what we need, we can conduct inference:</p><pre><code class="language-none">t = trace()
random_sum_model(t, data)
...
for i in 1:niter
    t = mh_step(t, random_sum_model, random_n_proposal; params=(data,))
    for j in 1:(t[:n].value + 1)
        t = mh_step(t, random_sum_model, loc_proposals[j]; params=(data,))
    end
    push!(ns, t[:n].value)
end</code></pre><p>Our inference results look promising:</p><pre><code class="language-none">[ Info: True :n = 9
[ Info: Posterior E[:n] = 7.581604598850287</code></pre><p>For more examples, check back soon.</p><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.accept-Tuple{Trace, Trace, Float64}" href="#CrimsonSkyline.accept-Tuple{Trace, Trace, Float64}"><code>CrimsonSkyline.accept</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function accept(t :: Trace, new_t :: Trace, log_a :: Float64)</code></pre><p>Stochastic function that either returns <code>new_t</code> if accepted or returns <code>t</code> if not accepted.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.copy_common!-Tuple{Trace, Trace}" href="#CrimsonSkyline.copy_common!-Tuple{Trace, Trace}"><code>CrimsonSkyline.copy_common!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function copy_common!(old_t :: Trace, new_t :: Trace)</code></pre><p>Copies nodes from <code>old_t</code> into <code>new_t</code> for all addresses in the intersection of their address sets. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.log_acceptance_ratio-Tuple{Trace, Trace, CrimsonSkyline.Prior}" href="#CrimsonSkyline.log_acceptance_ratio-Tuple{Trace, Trace, CrimsonSkyline.Prior}"><code>CrimsonSkyline.log_acceptance_ratio</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function log_acceptance_ratio(t :: Trace, t_proposed :: Trace, p :: Prior)</code></pre><p>Computes the log acceptance ratio of a Metropolis step when using the independent prior proposal  algorithm:</p><p><span>$\log \alpha = \ell(t_{\text{proposed}}) - \ell(t_{\text{original}})$</span></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.loglatent-Tuple{Trace}" href="#CrimsonSkyline.loglatent-Tuple{Trace}"><code>CrimsonSkyline.loglatent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function loglatent(t :: Trace)</code></pre><p>Computes the joint log probability of all latent variables in a trace, <span>$\log p(t) - \ell(t)$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.logprob-Tuple{Trace, Trace}" href="#CrimsonSkyline.logprob-Tuple{Trace, Trace}"><code>CrimsonSkyline.logprob</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function logprob(t0 :: Trace, t1 :: Trace)</code></pre><p>Computes the proposal log probability <span>$q(t_1 | t_0)$</span>.</p><p>This expression has two parts: log probability that is generated at the proposed site(s), and  log probability that is generated at the sites that are present in <code>t1</code> but not in <code>t0</code>. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.mh-Tuple{Any, Tuple{DataType, DataType}}" href="#CrimsonSkyline.mh-Tuple{Any, Tuple{DataType, DataType}}"><code>CrimsonSkyline.mh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function mh(f, types::Tuple{DataType, DataType}; params = (), burn = 1000, thin = 50, num_iterations = 10000)</code></pre><p>Generic Metropolis algorithm using draws from the prior.</p><p>Args:</p><ul><li><code>f</code>: stochastic function. Must have call signature <code>f(t :: Trace, params...)</code></li><li><code>params</code>: addditional arguments to pass to <code>f</code> and each of the proposal kernels.</li><li><code>burn</code>: number of samples to discard at beginning of markov chain</li><li><code>thin</code>: keep only every <code>thin</code>-th draw. E.g., if <code>thin = 100</code>, only every 100-th trace will be kept.</li><li><code>num_iterations</code>: total number of steps to take in the markov chain</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.mh-Tuple{Any}" href="#CrimsonSkyline.mh-Tuple{Any}"><code>CrimsonSkyline.mh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function mh(f; params = (), burn = 1000, thin = 50, num_iterations = 10000)</code></pre><p>Generic Metropolis algorithm using draws from the prior.</p><p>Args:</p><ul><li><code>f</code>: stochastic function. Must have call signature <code>f(t :: Trace, params...)</code></li><li><code>params</code>: addditional arguments to pass to <code>f</code> and each of the proposal kernels.</li><li><code>burn</code>: number of samples to discard at beginning of markov chain</li><li><code>thin</code>: keep only every <code>thin</code>-th draw. E.g., if <code>thin = 100</code>, only every 100-th trace will be kept.</li><li><code>num_iterations</code>: total number of steps to take in the markov chain</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.mh-Union{Tuple{A}, Tuple{Any, A, Any}} where A&lt;:AbstractArray" href="#CrimsonSkyline.mh-Union{Tuple{A}, Tuple{Any, A, Any}} where A&lt;:AbstractArray"><code>CrimsonSkyline.mh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function mh(f, qs :: A, addresses; params = (), burn = 100, thin = 10, num_iterations = 10000, inverse_verbosity = 100) where A &lt;: AbstractArray</code></pre><p>Generic Metropolis algorithm using user-defined proposal kernels, returning only a requested subset of  addresses. </p><p>Args:</p><ul><li><code>f</code>: stochastic function. Must have call signature <code>f(t :: Trace, params...)</code></li><li><code>qs</code>: array-like of proposal kernels. Proposal kernels are applied sequentially in the order that they appear in this array.   Proposal kernels must have the signature <code>q(old_t :: Trace, new_t :: Trace, params...)</code> where it must take in at least the same number of arguments   in <code>params</code> as <code>f</code>.</li><li><code>addresses</code>: <em>only</em> values sampled at these addresses will be saved in the <code>values</code> field of the   <code>BareResults</code> struct returned.</li><li><code>params</code>: addditional arguments to pass to <code>f</code> and each of the proposal kernels.</li><li><code>burn</code>: number of samples to discard at beginning of markov chain</li><li><code>thin</code>: keep only every <code>thin</code>-th draw. E.g., if <code>thin = 100</code>, only every 100-th trace will be kept.</li><li><code>num_iterations</code>: total number of steps to take in the markov chain</li><li><code>inverse_verbosity</code>: every <code>inverse_verbosity</code> iterations, a stattus report will be logged.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.mh-Union{Tuple{A}, Tuple{Any, A, Tuple{DataType, DataType}}} where A&lt;:AbstractArray" href="#CrimsonSkyline.mh-Union{Tuple{A}, Tuple{Any, A, Tuple{DataType, DataType}}} where A&lt;:AbstractArray"><code>CrimsonSkyline.mh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function mh(f, qs :: A, types::Tuple{DataType,DataType}; params = (), burn = 100, thin = 10, num_iterations = 10000, inverse_verbosity = 100) where A &lt;: AbstractArray</code></pre><p>Generic Metropolis algorithm using user-defined proposal kernels.</p><p>Args:</p><ul><li><code>f</code>: stochastic function. Must have call signature <code>f(t :: Trace, params...)</code></li><li><code>qs</code>: array-like of proposal kernels. Proposal kernels are applied sequentially in the order that they appear in this array.   Proposal kernels must have the signature <code>q(old_t :: Trace, new_t :: Trace, params...)</code> where it must take in at least the same number of arguments   in <code>params</code> as <code>f</code>.</li><li><code>params</code>: addditional arguments to pass to <code>f</code> and each of the proposal kernels.</li><li><code>burn</code>: number of samples to discard at beginning of markov chain</li><li><code>thin</code>: keep only every <code>thin</code>-th draw. E.g., if <code>thin = 100</code>, only every 100-th trace will be kept.</li><li><code>num_iterations</code>: total number of steps to take in the markov chain</li><li><code>inverse_verbosity</code>: every <code>inverse_verbosity</code> iterations, a stattus report will be logged.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.mh-Union{Tuple{A}, Tuple{Any, A}} where A&lt;:AbstractArray" href="#CrimsonSkyline.mh-Union{Tuple{A}, Tuple{Any, A}} where A&lt;:AbstractArray"><code>CrimsonSkyline.mh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function mh(f, qs :: A; params = (), burn = 100, thin = 10, num_iterations = 10000, inverse_verbosity = 100) where A &lt;: AbstractArray</code></pre><p>Generic Metropolis algorithm using user-defined proposal kernels.</p><p>Args:</p><ul><li><code>f</code>: stochastic function. Must have call signature <code>f(t :: Trace, params...)</code></li><li><code>qs</code>: array-like of proposal kernels. Proposal kernels are applied sequentially in the order that they appear in this array.   Proposal kernels must have the signature <code>q(old_t :: Trace, new_t :: Trace, params...)</code> where it must take in at least the same number of arguments   in <code>params</code> as <code>f</code>.</li><li><code>params</code>: addditional arguments to pass to <code>f</code> and each of the proposal kernels.</li><li><code>burn</code>: number of samples to discard at beginning of markov chain</li><li><code>thin</code>: keep only every <code>thin</code>-th draw. E.g., if <code>thin = 100</code>, only every 100-th trace will be kept.</li><li><code>num_iterations</code>: total number of steps to take in the markov chain</li><li><code>inverse_verbosity</code>: every <code>inverse_verbosity</code> iterations, a stattus report will be logged.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.mh-Union{Tuple{T}, Tuple{RandomField, Vector{T}, Any}} where T" href="#CrimsonSkyline.mh-Union{Tuple{T}, Tuple{RandomField, Vector{T}, Any}} where T"><code>CrimsonSkyline.mh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function mh(rf::RandomField, qs::Vector{T}, val; burn=1000, thin=100, num_iterations=11000) where T</code></pre><p>Metropolis Hastings algorithm for sampling from a random field using arbitrary proposal kernels.</p><p>Args: </p><ul><li><code>rf</code>: the random field from which to sample</li><li><code>qs</code>: vector of proposal kernel callables; see documentation of <code>mh_step</code> for specification of proposal kernels</li><li><code>val</code>: initial guess with which to initialize MH, must be a dict with format <code>address =&gt; value</code>.</li><li><code>burn</code>: number of samples to discard at beginning of markov chain</li><li><code>thin</code>: keep only every <code>thin</code>-th draw. E.g., if <code>thin = 100</code>, only every 100-th trace will be kept.</li><li><code>num_iterations</code>: total number of steps to take in the markov chain</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.mh_step-Tuple{RandomField, Any, Any, Any}" href="#CrimsonSkyline.mh_step-Tuple{RandomField, Any, Any, Any}"><code>CrimsonSkyline.mh_step</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function mh_step(rf::RandomField, q, x, log_prob_rf_x)</code></pre><p>A Metropolis step to sample from a random field using an arbitrary proposal kernel.</p><p>Args:</p><ul><li><p><code>rf</code>: a <code>RandomField</code> from which to sample</p></li><li><p><code>q</code>: a proposal kernel. This must be a callable that satisfies the following   requirements:</p><ul><li><code>q(x)</code> returns a new value <code>x_prime</code> that is generated using the input parameters   <code>x</code>, i.e., <span>$x&#39; \sim q(x&#39;|x)$</span>. For example, <code>q(x) = rand(Normal(x, 0.25))</code></li><li><code>q(x_prime, x)</code> scores (computes the log probability of) <code>x_prime</code> against <code>x</code>, i.e.,   computes <span>$\log q(x&#39; | x)$</span></li></ul></li><li><p><code>x</code>: a dict with format <code>address =&gt; value</code>, the current sampled value.</p></li><li><p><code>log_prob_rf_x</code>: the log probability of <code>x</code> under the random field.</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.mh_step-Tuple{Trace, Any, Any, Tuple{DataType, DataType}}" href="#CrimsonSkyline.mh_step-Tuple{Trace, Any, Any, Tuple{DataType, DataType}}"><code>CrimsonSkyline.mh_step</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function mh_step(t :: Trace, f, q, types::Tuple{DataType,DataType}; params = (), return_val :: Bool = false)</code></pre><p>A generic Metropolis step using an arbitrary proposal kernel. </p><p>Given a trace <code>t</code>, a stochastic function <code>f</code> with signature <code>f(t :: Trace, params...)</code> a stochastic function  <code>q</code> with signature <code>q(old_trace :: Trace, new_trace :: Trace, params...)</code>, generates a proposal from <code>q</code> and  accepts based on the log acceptance probability:</p><p><span>$\log \alpha = \log p(t_{\text{new}}) - \log q(t_{\text{new}}|t_{\text{old}}) - [\log p(t_{\text{old}}) - \log q(t_{\text{old}} | t_{\text{new}})].$</span></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.mh_step-Tuple{Trace, Any, Any}" href="#CrimsonSkyline.mh_step-Tuple{Trace, Any, Any}"><code>CrimsonSkyline.mh_step</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function mh_step(t :: Trace, f, q; params = (), return_val :: Bool = false)</code></pre><p>A generic Metropolis step using an arbitrary proposal kernel. </p><p>Given a trace <code>t</code>, a stochastic function <code>f</code> with signature <code>f(t :: Trace, params...)</code> a stochastic function  <code>q</code> with signature <code>q(old_trace :: Trace, new_trace :: Trace, params...)</code>, generates a proposal from <code>q</code> and  accepts based on the log acceptance probability:</p><p><span>$\log \alpha = \log p(t_{\text{new}}) - \log q(t_{\text{new}}|t_{\text{old}}) - [\log p(t_{\text{old}}) - \log q(t_{\text{old}} | t_{\text{new}})].$</span></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.mh_step-Tuple{Trace, Any, Tuple{DataType, DataType}}" href="#CrimsonSkyline.mh_step-Tuple{Trace, Any, Tuple{DataType, DataType}}"><code>CrimsonSkyline.mh_step</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function mh_step(t :: Trace, f, types::Tuple{DataType, DataType}; params = (), return_val :: Bool = false)</code></pre><p>An independent prior sample Metropolis step.</p><p>Given a trace <code>t</code> and stochastic function <code>f</code> depending on <code>params...</code>, generates proposals  from prior draws and accepts based on the likelihood ratio.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.mh_step-Tuple{Trace, Any}" href="#CrimsonSkyline.mh_step-Tuple{Trace, Any}"><code>CrimsonSkyline.mh_step</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function mh_step(t :: Trace, f; params = (), return_val :: Bool = false)</code></pre><p>An independent prior sample Metropolis step.</p><p>Given a trace <code>t</code> and stochatic function <code>f</code> depending on <code>params...</code>, generates proposals  from prior draws and accepts based on the likelihood ratio.</p></div></section></article><h2 id="nested"><a class="docs-heading-anchor" href="#nested">nested</a><a id="nested-1"></a><a class="docs-heading-anchor-permalink" href="#nested" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.nested-Tuple{Any, Any}" href="#CrimsonSkyline.nested-Tuple{Any, Any}"><code>CrimsonSkyline.nested</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function nested(f, replace_fn; params = (), num_points :: Int64 = 1)</code></pre><p>Generic implementation of nested sampling (Skilling, Nested sampling for general Bayesian computation, Bayesian Analysis, 2006). The number of sampling iterations is a function of <code>num_points</code> aka <span>$N$</span>, and the empirical entropy of the sampling distribution, given at the <span>$n$</span>-th iteration by <span>$H_n \approx \sum_k \hat p_k \log \hat p_k^{-1}$</span>, where <span>$\hat p_k = L_k w_k / Z_k$</span>, <span>$L_k$</span> is the likelihood value, <span>$w_k$</span> is the difference in prior mass, and <span>$Z_k$</span> is the current estimate of the partition function. The number of sampling iterations is equal to <span>$\min_n \{n &gt; 0: n &gt; NH_n\}$</span>. </p><p>Args:</p><ul><li><code>f</code>: stochastic function. Must have signature <code>f(t :: Trace, params...)</code></li><li><code>replace_fn</code>: function that returns a tuple <code>(new_trace :: Trace, new_log_likelihood :: Float64)</code>. The input signature of this function   must be <code>replace_fn(f :: F, log_likelihood :: Float64, params...) where F &lt;: Function</code>. It must guarantee that <code>new_log_likelihood &gt; log_likelihood</code>.</li><li><code>params</code>: any parameters to pass to <code>f</code></li><li><code>num_points</code>: the number of likelihood points to keep track of</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.nested-Tuple{Any}" href="#CrimsonSkyline.nested-Tuple{Any}"><code>CrimsonSkyline.nested</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nested(f; params = (), num_points :: Int64 = 1)</code></pre><p>Run nested sampling using internal rejection method.</p></div></section></article><h2 id="results"><a class="docs-heading-anchor" href="#results">results</a><a id="results-1"></a><a class="docs-heading-anchor-permalink" href="#results" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.NonparametricSamplingResults" href="#CrimsonSkyline.NonparametricSamplingResults"><code>CrimsonSkyline.NonparametricSamplingResults</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct NonparametricSamplingResults{I} &lt;: SamplingResults{I}
    interpretation :: I
    log_weights :: Array{Float64, 1}
    return_values :: Array{Any, 1}
    traces :: Array{Trace, 1}
end</code></pre><p>Wrapper for results of sampling. Implements the following methods  from <code>Base</code>: <code>getindex</code>, <code>length</code>, <code>keys</code>. Intepretation of log weights is dependent on <code>I</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.ParametricSamplingResults" href="#CrimsonSkyline.ParametricSamplingResults"><code>CrimsonSkyline.ParametricSamplingResults</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ParametricSamplingResults{I} &lt;: SamplingResults{I}
    interpretation :: I
    log_weights :: Array{Float64, 1}
    return_values :: Array{Any, 1}
    traces :: Array{Trace, 1}
    distributions :: Dict
end</code></pre><p><code>distributions</code> maps from addresses to distributions, <span>$a \mapsto \pi^{(a)}_\psi(z)$</span>, where  <span>$\pi^{(a)}_\psi(z)$</span> solves</p><p class="math-container">\[\max_\psi E_{z \sim p(z|x)}[\log \pi^{(a)}_\psi(z)].\]</p><p>The distributions are not used to generate values but only to score sampled values; values are  still sampled from the posterior traces. Right now, the parametric approximation is very simple: values with support over the  negative orthant of  <span>$\mathbb R^D$</span> are approximated by (multivariate) normal distributions, while  values with support over only the positive orthant of <span>$\mathbb{R}^D$</span> are approximated by  (multivariate) lognormal distributions. This behavior is expected to change in the future.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.addresses-Union{Tuple{NonparametricSamplingResults{I}}, Tuple{I}} where I&lt;:CrimsonSkyline.InferenceType" href="#CrimsonSkyline.addresses-Union{Tuple{NonparametricSamplingResults{I}}, Tuple{I}} where I&lt;:CrimsonSkyline.InferenceType"><code>CrimsonSkyline.addresses</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function addresses(r::NonparametricSamplingResults{I}) where I &lt;: InferenceType</code></pre><p>Get all addresses associated with the <code>SamplingResults</code> object, <span>$A = \bigcup_{t\in \text{traces}}\mathcal A_t$</span></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.addresses-Union{Tuple{ParametricSamplingResults{I}}, Tuple{I}} where I&lt;:CrimsonSkyline.InferenceType" href="#CrimsonSkyline.addresses-Union{Tuple{ParametricSamplingResults{I}}, Tuple{I}} where I&lt;:CrimsonSkyline.InferenceType"><code>CrimsonSkyline.addresses</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function addresses(r::ParametricSamplingResults{I}) where I &lt;: InferenceType</code></pre><p>Get all addresses associated with the <code>SamplingResults</code> object, <span>$A = \bigcup_{t\in \text{traces}}\mathcal A_t$</span></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Union{Tuple{I}, Tuple{Trace, Any, NonparametricSamplingResults{I}}} where I&lt;:CrimsonSkyline.InferenceType" href="#CrimsonSkyline.sample-Union{Tuple{I}, Tuple{Trace, Any, NonparametricSamplingResults{I}}} where I&lt;:CrimsonSkyline.InferenceType"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, r :: NonparametricSamplingResults{I}; pa = ()) where I &lt;: InferenceType</code></pre><p>Treat a marginal site of a <code>SamplingResults</code> as a distribution, sampling from it into a trace.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Union{Tuple{I}, Tuple{Trace, Any, ParametricSamplingResults{I}}} where I&lt;:CrimsonSkyline.InferenceType" href="#CrimsonSkyline.sample-Union{Tuple{I}, Tuple{Trace, Any, ParametricSamplingResults{I}}} where I&lt;:CrimsonSkyline.InferenceType"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, r::ParametricSamplingResults{I}; pa = ()) where I &lt;: InferenceType</code></pre><p>Treat a marginal site of a <code>SamplingResults</code> as a distribution, sampling from it into a trace.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.to_parametric-Union{Tuple{NonparametricSamplingResults{I}}, Tuple{I}} where I&lt;:CrimsonSkyline.InferenceType" href="#CrimsonSkyline.to_parametric-Union{Tuple{NonparametricSamplingResults{I}}, Tuple{I}} where I&lt;:CrimsonSkyline.InferenceType"><code>CrimsonSkyline.to_parametric</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function to_parametric(r::NonparametricSamplingResults{I}) where I&lt;:InferenceType</code></pre><p>Converts a nonparametric sampling results object into one that additionally contains a mapping from addresses to distributions. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Distributions.logpdf-Union{Tuple{A}, Tuple{A, Any}} where A&lt;:AbstractArray" href="#Distributions.logpdf-Union{Tuple{A}, Tuple{A, Any}} where A&lt;:AbstractArray"><code>Distributions.logpdf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function Distributions.logpdf(r :: A, v) where A &lt;: AbstractArray</code></pre><p>Interprets an array of objects as a delta distribution over those objects. If <code>v</code> is in the support set,  returns <span>$-log |r|$</span>. Otherwise, returns <span>$-\infty$</span>. </p></div></section></article><h2 id="statistics"><a class="docs-heading-anchor" href="#statistics">statistics</a><a id="statistics-1"></a><a class="docs-heading-anchor-permalink" href="#statistics" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.aic-Tuple{Trace}" href="#CrimsonSkyline.aic-Tuple{Trace}"><code>CrimsonSkyline.aic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function aic(t :: Trace)</code></pre><p>Computes the Akaike Information Criterion for a <em>single trace</em> (thus replacing the definition) with  &quot;maximum likelihood&quot; by one with &quot;likelihood&quot;. The formula is </p><p class="math-container">\[\text{AIC}(t)/2 = |\text{params}(t)| - \ell(t),\]</p><p>where <span>$\text{params}(t)|$</span> is the sum of the dimensionalities of non-observed  and non-deterministic sample nodes.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.aic-Union{Tuple{CrimsonSkyline.SamplingResults{I}}, Tuple{I}} where I&lt;:CrimsonSkyline.InferenceType" href="#CrimsonSkyline.aic-Union{Tuple{CrimsonSkyline.SamplingResults{I}}, Tuple{I}} where I&lt;:CrimsonSkyline.InferenceType"><code>CrimsonSkyline.aic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function aic(r :: SamplingResults{I}) where I &lt;: InferenceType</code></pre><p>Computes an empirical estimate of the Akaike Information Criterion from a <code>SamplingResults</code>. The formula is </p><p class="math-container">\[\text{AIC}(r)/2 = \min_{t \in \text{traces}(r)}|\text{params}(t)| - \hat\ell(t),\]</p><p>where <span>$\text{params}(t)|$</span> is the sum of the dimensionalities of non-observed  and non-deterministic sample nodes and <span>$\hat\ell(t)$</span> is the empirical maximum likelihood.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.hpdi-Union{Tuple{T}, Tuple{I}, Tuple{CrimsonSkyline.SamplingResults{I}, Float64, AbstractArray{T, N} where N}} where {I&lt;:CrimsonSkyline.InferenceType, T}" href="#CrimsonSkyline.hpdi-Union{Tuple{T}, Tuple{I}, Tuple{CrimsonSkyline.SamplingResults{I}, Float64, AbstractArray{T, N} where N}} where {I&lt;:CrimsonSkyline.InferenceType, T}"><code>CrimsonSkyline.hpdi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function hpdi(r::SamplingResults{I}, pct::Float64, addresses::AbstractArray{T}) where {I &lt;: InferenceType, T}</code></pre><p>Computes the highest posterior density interval(s) for a univariate variable. Does <em>not</em> check that the  data corresponding to each address in <code>addresses</code> is actually univariate; if in doubt, use <code>hpds</code> instead.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.hpds-Union{Tuple{I}, Tuple{CrimsonSkyline.SamplingResults{I}, Float64}} where I&lt;:CrimsonSkyline.InferenceType" href="#CrimsonSkyline.hpds-Union{Tuple{I}, Tuple{CrimsonSkyline.SamplingResults{I}, Float64}} where I&lt;:CrimsonSkyline.InferenceType"><code>CrimsonSkyline.hpds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function hpds(r::SamplingResults{I}, pct::Float64) where I &lt;: InferenceType</code></pre><p>Computes the highest posterior density set (HPDS) of the <code>SamplingResults</code> object. Let <span>$\mathcal T$</span> be the set of traces. The <span>$100\times Q \%$</span>-percentile HPDS is defined as the  set that satisfies <span>$\sum_{t \in \mathrm{HPDS}} p(t) = Q$</span> and, for all <span>$t \in \mathrm{HPDS}$</span>, <span>$p(t) &gt; p(s)$</span> for every <span>$s \in \mathcal T  - \mathrm{HPDS}$</span>. It is possible to compute the HPDS using the full joint density <span>$p(t) \equiv p(x, z)$</span>, where <span>$x$</span> is the  set of observed rvs and <span>$z$</span> is the set of latent rvs, since <span>$p(z|x) \propto p(x, z)$</span>. </p><p><code>pct</code> should be a float in (0.0, 1.0). E.g., <code>pct = 0.95</code> returns the 95% HPDS.</p></div></section></article><h2 id="kernel"><a class="docs-heading-anchor" href="#kernel">kernel</a><a id="kernel-1"></a><a class="docs-heading-anchor-permalink" href="#kernel" title="Permalink"></a></h2><p>There are methods to automatically generate proposal kernels.</p><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.make_kernel-Union{Tuple{D}, Tuple{N}, Tuple{Any, N, D}} where {N&lt;:Node, D&lt;:Distributions.Distribution{Distributions.Multivariate, Distributions.Continuous}}" href="#CrimsonSkyline.make_kernel-Union{Tuple{D}, Tuple{N}, Tuple{Any, N, D}} where {N&lt;:Node, D&lt;:Distributions.Distribution{Distributions.Multivariate, Distributions.Continuous}}"><code>CrimsonSkyline.make_kernel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function make_kernel(f, node::N, d::D) where {N&lt;:Node, D&lt;:ContinuousMultivariateDistribution}</code></pre><p>Creates a single site proposal kernel for <code>node</code> that has an associated continuous multivariate distribution.  Assumes that this site is <em>unconstrained</em> in <span>$\mathbb{R}^N$</span>; using this method will result in inference runtime errors if the site is constrained. The resulting proposal kernel is a multivariate normal, <span>$z&#39; | z \sim \mathrm{MultivariateNormal}(z, 1 / \sqrt{|D|})$</span> where <span>$D$</span> is the dimensionality of the site. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.make_kernel-Union{Tuple{D}, Tuple{N}, Tuple{Any, N, D}} where {N&lt;:Node, D&lt;:Distributions.Distribution{Distributions.Univariate, Distributions.Continuous}}" href="#CrimsonSkyline.make_kernel-Union{Tuple{D}, Tuple{N}, Tuple{Any, N, D}} where {N&lt;:Node, D&lt;:Distributions.Distribution{Distributions.Univariate, Distributions.Continuous}}"><code>CrimsonSkyline.make_kernel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function make_kernel(f, node::N, d::D) where {N&lt;:Node, D&lt;:ContinuousUnivariateDistribution}</code></pre><p>Creates a single site proposal kernel for <code>node</code> that has an associated continuous univariate distribution. The resulting proposal kernel is a normal distribution, <span>$z&#39; | z \sim \mathrm{Normal}(z, (0.5 \sigma)^2)$</span> where <span>$\sigma$</span> is the standard deviation of the node&#39;s distribution.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.make_kernel-Union{Tuple{D}, Tuple{N}, Tuple{Any, N, D}} where {N&lt;:Node, D&lt;:Distributions.Distribution{Distributions.Univariate, Distributions.Discrete}}" href="#CrimsonSkyline.make_kernel-Union{Tuple{D}, Tuple{N}, Tuple{Any, N, D}} where {N&lt;:Node, D&lt;:Distributions.Distribution{Distributions.Univariate, Distributions.Discrete}}"><code>CrimsonSkyline.make_kernel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function make_kernel(f, node::N, d::D) where {N&lt;:Node, D&lt;:DiscreteUnivariateDistribution}</code></pre><p>Creates a single site proposal kernel for <code>node</code> that has an associated discrete univariate distribution. This method assumes that the distribution is defined over some subset of the integers; a support that does not meet  this criteria <em>may</em> result in runtime inference errors. The resulting proposal kernel is a discrete nonparametric  distribution, <span>$z&#39; | z \sim \mathrm{DiscreteNonParametric}([z - 1, z, z + 1])$</span> if <span>$z$</span> is not on the boundary of  the distribution&#39;s support; or <span>$z&#39; | z \sim \mathrm{DiscreteNonParametric}([z \pm 1, z])$</span> if <span>$z$</span> is on the  boundary of the distribution&#39;s support, with the sign depending on the left or right of the support.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.make_kernel-Union{Tuple{N}, Tuple{Any, N, Any}} where N&lt;:Node" href="#CrimsonSkyline.make_kernel-Union{Tuple{N}, Tuple{Any, N, Any}} where N&lt;:Node"><code>CrimsonSkyline.make_kernel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function make_kernel(f, node::N, d) where {N&lt;:Node}</code></pre><p>Create a single site proposal kernel for an arbitrary site. This method draws from the prior site distribution and is therefore inefficient (both computationally and statistically). </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.make_kernels-Tuple{Any}" href="#CrimsonSkyline.make_kernels-Tuple{Any}"><code>CrimsonSkyline.make_kernels</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function make_kernels(f; params = ())</code></pre><p>Create a vector of single-site proposal functions for the stochastic function <code>f</code>.  This method assumes static model structure and generates a proposal kernel for each model site. The tuple of params are any necessary parameters needed to execute <code>f</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.make_kernels-Union{Tuple{T}, Tuple{Any, Trace, Vector{T}}} where T" href="#CrimsonSkyline.make_kernels-Union{Tuple{T}, Tuple{Any, Trace, Vector{T}}} where T"><code>CrimsonSkyline.make_kernels</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function make_kernels(f, t::Trace, addresses::Vector{T}; params = (), include::Bool=true) where T</code></pre><p>Create a vector of single-site proposal functions for the stochastic function <code>f</code>.  This method assumes static model structure and generates a proposal either for each site in <code>addresses</code> (<code>include = true</code>) or for each site <em>not</em> in <code>addresses</code> (<code>include = false</code>). The tuple of params are any necessary parameters needed to execute <code>f</code>.</p></div></section></article><h2 id="inference"><a class="docs-heading-anchor" href="#inference">inference</a><a id="inference-1"></a><a class="docs-heading-anchor-permalink" href="#inference" title="Permalink"></a></h2><p>There is a high-level uniform interface to built-in inference algorithms.</p><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.inference-Tuple{Any, CrimsonSkyline.Nested}" href="#CrimsonSkyline.inference-Tuple{Any, CrimsonSkyline.Nested}"><code>CrimsonSkyline.inference</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function inference(f, method::Nested; params = (), inference_params = Dict())</code></pre><p>No additional arguments.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.inference-Tuple{Any, Forward}" href="#CrimsonSkyline.inference-Tuple{Any, Forward}"><code>CrimsonSkyline.inference</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function inference(f, method::Forward; params = (), inference_params = Dict())</code></pre><p>No additional arguments.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.inference-Tuple{Any, ImportanceSampling}" href="#CrimsonSkyline.inference-Tuple{Any, ImportanceSampling}"><code>CrimsonSkyline.inference</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function inference(f, method::ImportanceSampling; params = (), inference_params = Dict())</code></pre><p>Additional arguments: <code>inference_params[&quot;kernel&quot;] = q</code>  where <code>q</code> is a proposal kernel for importance sampling</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.inference-Tuple{Any, LikelihoodWeighting}" href="#CrimsonSkyline.inference-Tuple{Any, LikelihoodWeighting}"><code>CrimsonSkyline.inference</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function inference(f, method::LikelihoodWeighting; params = (), inference_params = Dict())</code></pre><p>No additional arguments.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.inference-Tuple{Any, Metropolis}" href="#CrimsonSkyline.inference-Tuple{Any, Metropolis}"><code>CrimsonSkyline.inference</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function inference(f, method::Metropolis; params = (), inference_params = Dict())</code></pre><p>Additional arguments: <code>inference_params[&quot;kernels&quot;]</code>  which is a vector of &gt;= 1 proposal kernels. If this is not passed, this method uses  ancestor MH sampling.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.inference-Tuple{Any}" href="#CrimsonSkyline.inference-Tuple{Any}"><code>CrimsonSkyline.inference</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inference(f; params = (), inference_params = Dict())</code></pre><p>Do inference on the stochastic function <code>f</code>, passing as arguments to the inference algorithm  the tuple of <code>params</code> and any additional arguments to the inference algorithm in <code>inference_params</code>. To specify a particular inference algorithm pass an <code>InferenceType</code> as the second argument to the function, i.e.,  <code>inference(f, i::InferenceType; params = (), inference_params = Dict())</code>. All methods accept <code>inference_params[&quot;num_iterations&quot;]::Int64</code> as the number of iterations of inference to perform; the interpretation of that is inference algorithm-dependent. <strong>This default method performs inference using <code>LikelihoodWeighting()</code>.</strong></p></div></section></article><h2 id="db"><a class="docs-heading-anchor" href="#db">db</a><a id="db-1"></a><a class="docs-heading-anchor-permalink" href="#db" title="Permalink"></a></h2><p>To facilitate high-level probabilistic reasoning, it is possible to treat stochastic functions as database tables  and query them using a dialect of SQL (SQLite).</p><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.SQLModel" href="#CrimsonSkyline.SQLModel"><code>CrimsonSkyline.SQLModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct SQLModel{F} &lt;: TabularModel{F}
    f::F
    db::SQLite.DB
end</code></pre><p>A representation of the model <code>f</code> as a SQL table.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.SQLModel-Tuple{F} where F" href="#CrimsonSkyline.SQLModel-Tuple{F} where F"><code>CrimsonSkyline.SQLModel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function SQLModel(f::F; params = (), num_iterations = 100, method::InferenceType = FORWARD, inference_params = Dict(), name = nothing) where F</code></pre><p>Create a representation of the model <code>f</code> as a database table which can be queried using SQL (SQLite, specifically). This method works by first conducting inference on the model (including forward sampling if the user just wants to query the prior),  and then collecting sampled values in a table. The resulting table is titled <code>&lt;name&gt;_results</code> and includes a column for each address (titled <code>a</code>) that occurs in the union of all sampled traces and a corresponding column for each address&#39;s log probability (titled <code>a_logprob</code>).</p><p>This methood <em>does</em> work with open-universe structured models; traces (rows in the table) that do not include address <code>a</code> have a  <code>NULL</code> in columns <code>a</code> and <code>a_logprob</code> in that row.</p><ul><li><code>params</code>: additional parameters to pass to the model during inference</li><li><code>num_iterations</code>: number of iterations of inference to complete; the meaning is dependent on the inference algorithm used</li><li><code>method</code>: an <code>InferenceType</code>, defaults to <code>Forward()</code> for forward sampling.</li><li><code>inference_params</code>: a dict of parameters to pass to the inference method. </li><li><code>name</code>: a name to use instead of the model&#39;s name, which is used by default.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.query-Tuple{SQLModel, String}" href="#CrimsonSkyline.query-Tuple{SQLModel, String}"><code>CrimsonSkyline.query</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function query(sqm::SQLModel, q::String)</code></pre><p>Execute the SQLite query <code>q</code> against the <code>SQLModel</code> and return results as a <code>DataFrame</code>.</p></div></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#CrimsonSkyline.GenerativeField"><code>CrimsonSkyline.GenerativeField</code></a></li><li><a href="#CrimsonSkyline.NonparametricSamplingResults"><code>CrimsonSkyline.NonparametricSamplingResults</code></a></li><li><a href="#CrimsonSkyline.ParametricNode"><code>CrimsonSkyline.ParametricNode</code></a></li><li><a href="#CrimsonSkyline.ParametricSamplingResults"><code>CrimsonSkyline.ParametricSamplingResults</code></a></li><li><a href="#CrimsonSkyline.RandomField"><code>CrimsonSkyline.RandomField</code></a></li><li><a href="#CrimsonSkyline.RandomField-Tuple{Dict{Vector{String}, Function}}"><code>CrimsonSkyline.RandomField</code></a></li><li><a href="#CrimsonSkyline.RandomField-Tuple{Dict{Vector{String}, Function}, Dict}"><code>CrimsonSkyline.RandomField</code></a></li><li><a href="#CrimsonSkyline.SQLModel"><code>CrimsonSkyline.SQLModel</code></a></li><li><a href="#CrimsonSkyline.SQLModel-Tuple{F} where F"><code>CrimsonSkyline.SQLModel</code></a></li><li><a href="#CrimsonSkyline.SampleableNode"><code>CrimsonSkyline.SampleableNode</code></a></li><li><a href="#CrimsonSkyline.Trace"><code>CrimsonSkyline.Trace</code></a></li><li><a href="#CrimsonSkyline.TypedTrace"><code>CrimsonSkyline.TypedTrace</code></a></li><li><a href="#CrimsonSkyline.UntypedTrace"><code>CrimsonSkyline.UntypedTrace</code></a></li><li><a href="#Base.rand-Tuple{GenerativeField}"><code>Base.rand</code></a></li><li><a href="#CrimsonSkyline.accept-Tuple{Trace, Trace, Float64}"><code>CrimsonSkyline.accept</code></a></li><li><a href="#CrimsonSkyline.addresses-Union{Tuple{NonparametricSamplingResults{I}}, Tuple{I}} where I&lt;:CrimsonSkyline.InferenceType"><code>CrimsonSkyline.addresses</code></a></li><li><a href="#CrimsonSkyline.addresses-Union{Tuple{ParametricSamplingResults{I}}, Tuple{I}} where I&lt;:CrimsonSkyline.InferenceType"><code>CrimsonSkyline.addresses</code></a></li><li><a href="#CrimsonSkyline.aic-Union{Tuple{CrimsonSkyline.SamplingResults{I}}, Tuple{I}} where I&lt;:CrimsonSkyline.InferenceType"><code>CrimsonSkyline.aic</code></a></li><li><a href="#CrimsonSkyline.aic-Tuple{Trace}"><code>CrimsonSkyline.aic</code></a></li><li><a href="#CrimsonSkyline.block-Union{Tuple{T}, Tuple{Any, T, Any}} where T&lt;:Trace"><code>CrimsonSkyline.block</code></a></li><li><a href="#CrimsonSkyline.block-Tuple{Any, Trace}"><code>CrimsonSkyline.block</code></a></li><li><a href="#CrimsonSkyline.condition-Tuple{Any, Dict}"><code>CrimsonSkyline.condition</code></a></li><li><a href="#CrimsonSkyline.connect_pa_ch!-Tuple{Trace, Any, Any}"><code>CrimsonSkyline.connect_pa_ch!</code></a></li><li><a href="#CrimsonSkyline.copy_common!-Tuple{Trace, Trace}"><code>CrimsonSkyline.copy_common!</code></a></li><li><a href="#CrimsonSkyline.forward_sampling-Tuple{Any}"><code>CrimsonSkyline.forward_sampling</code></a></li><li><a href="#CrimsonSkyline.hpdi-Union{Tuple{T}, Tuple{I}, Tuple{CrimsonSkyline.SamplingResults{I}, Float64, AbstractArray{T, N} where N}} where {I&lt;:CrimsonSkyline.InferenceType, T}"><code>CrimsonSkyline.hpdi</code></a></li><li><a href="#CrimsonSkyline.hpds-Union{Tuple{I}, Tuple{CrimsonSkyline.SamplingResults{I}, Float64}} where I&lt;:CrimsonSkyline.InferenceType"><code>CrimsonSkyline.hpds</code></a></li><li><a href="#CrimsonSkyline.importance_sampling-Tuple{Any, Any}"><code>CrimsonSkyline.importance_sampling</code></a></li><li><a href="#CrimsonSkyline.importance_sampling-Tuple{Any, Any, Tuple{DataType, DataType}}"><code>CrimsonSkyline.importance_sampling</code></a></li><li><a href="#CrimsonSkyline.inference-Tuple{Any, Forward}"><code>CrimsonSkyline.inference</code></a></li><li><a href="#CrimsonSkyline.inference-Tuple{Any, LikelihoodWeighting}"><code>CrimsonSkyline.inference</code></a></li><li><a href="#CrimsonSkyline.inference-Tuple{Any, ImportanceSampling}"><code>CrimsonSkyline.inference</code></a></li><li><a href="#CrimsonSkyline.inference-Tuple{Any, Metropolis}"><code>CrimsonSkyline.inference</code></a></li><li><a href="#CrimsonSkyline.inference-Tuple{Any}"><code>CrimsonSkyline.inference</code></a></li><li><a href="#CrimsonSkyline.inference-Tuple{Any, CrimsonSkyline.Nested}"><code>CrimsonSkyline.inference</code></a></li><li><a href="#CrimsonSkyline.input-Tuple{Trace, Any, Any}"><code>CrimsonSkyline.input</code></a></li><li><a href="#CrimsonSkyline.interpret_latent!-Tuple{Trace, Interpretation}"><code>CrimsonSkyline.interpret_latent!</code></a></li><li><a href="#CrimsonSkyline.is_step-Tuple{Any, Any}"><code>CrimsonSkyline.is_step</code></a></li><li><a href="#CrimsonSkyline.is_step-Tuple{Any, Any, Tuple{DataType, DataType}}"><code>CrimsonSkyline.is_step</code></a></li><li><a href="#CrimsonSkyline.likelihood_weighting-Tuple{Any, Vararg{Any, N} where N}"><code>CrimsonSkyline.likelihood_weighting</code></a></li><li><a href="#CrimsonSkyline.likelihood_weighting-Tuple{Any, Tuple{DataType, DataType}, Vararg{Any, N} where N}"><code>CrimsonSkyline.likelihood_weighting</code></a></li><li><a href="#CrimsonSkyline.likelihood_weighting_results-Tuple{}"><code>CrimsonSkyline.likelihood_weighting_results</code></a></li><li><a href="#CrimsonSkyline.load-Tuple{Any}"><code>CrimsonSkyline.load</code></a></li><li><a href="#CrimsonSkyline.load_csm-Tuple{Any}"><code>CrimsonSkyline.load_csm</code></a></li><li><a href="#CrimsonSkyline.load_jdb-Tuple{Any}"><code>CrimsonSkyline.load_jdb</code></a></li><li><a href="#CrimsonSkyline.log_acceptance_ratio-Tuple{Trace, Trace, CrimsonSkyline.Prior}"><code>CrimsonSkyline.log_acceptance_ratio</code></a></li><li><a href="#CrimsonSkyline.log_evidence-Union{Tuple{CrimsonSkyline.SamplingResults{I}}, Tuple{I}} where I&lt;:CrimsonSkyline.Importance"><code>CrimsonSkyline.log_evidence</code></a></li><li><a href="#CrimsonSkyline.loglatent-Tuple{Trace}"><code>CrimsonSkyline.loglatent</code></a></li><li><a href="#CrimsonSkyline.loglikelihood-Tuple{Trace}"><code>CrimsonSkyline.loglikelihood</code></a></li><li><a href="#CrimsonSkyline.logprob-Tuple{Trace, Trace}"><code>CrimsonSkyline.logprob</code></a></li><li><a href="#CrimsonSkyline.logprob-Tuple{RandomField, Dict}"><code>CrimsonSkyline.logprob</code></a></li><li><a href="#CrimsonSkyline.logprob-Tuple{Trace}"><code>CrimsonSkyline.logprob</code></a></li><li><a href="#CrimsonSkyline.logprob!-Tuple{Trace}"><code>CrimsonSkyline.logprob!</code></a></li><li><a href="#CrimsonSkyline.lw_step-Tuple{Any, Vararg{Any, N} where N}"><code>CrimsonSkyline.lw_step</code></a></li><li><a href="#CrimsonSkyline.lw_step-Tuple{Any, Tuple{DataType, DataType}, Vararg{Any, N} where N}"><code>CrimsonSkyline.lw_step</code></a></li><li><a href="#CrimsonSkyline.make_kernel-Union{Tuple{D}, Tuple{N}, Tuple{Any, N, D}} where {N&lt;:Node, D&lt;:Distributions.Distribution{Distributions.Univariate, Distributions.Continuous}}"><code>CrimsonSkyline.make_kernel</code></a></li><li><a href="#CrimsonSkyline.make_kernel-Union{Tuple{D}, Tuple{N}, Tuple{Any, N, D}} where {N&lt;:Node, D&lt;:Distributions.Distribution{Distributions.Univariate, Distributions.Discrete}}"><code>CrimsonSkyline.make_kernel</code></a></li><li><a href="#CrimsonSkyline.make_kernel-Union{Tuple{N}, Tuple{Any, N, Any}} where N&lt;:Node"><code>CrimsonSkyline.make_kernel</code></a></li><li><a href="#CrimsonSkyline.make_kernel-Union{Tuple{D}, Tuple{N}, Tuple{Any, N, D}} where {N&lt;:Node, D&lt;:Distributions.Distribution{Distributions.Multivariate, Distributions.Continuous}}"><code>CrimsonSkyline.make_kernel</code></a></li><li><a href="#CrimsonSkyline.make_kernels-Union{Tuple{T}, Tuple{Any, Trace, Vector{T}}} where T"><code>CrimsonSkyline.make_kernels</code></a></li><li><a href="#CrimsonSkyline.make_kernels-Tuple{Any}"><code>CrimsonSkyline.make_kernels</code></a></li><li><a href="#CrimsonSkyline.mh-Union{Tuple{A}, Tuple{Any, A, Any}} where A&lt;:AbstractArray"><code>CrimsonSkyline.mh</code></a></li><li><a href="#CrimsonSkyline.mh-Union{Tuple{T}, Tuple{RandomField, Vector{T}, Any}} where T"><code>CrimsonSkyline.mh</code></a></li><li><a href="#CrimsonSkyline.mh-Tuple{Any}"><code>CrimsonSkyline.mh</code></a></li><li><a href="#CrimsonSkyline.mh-Union{Tuple{A}, Tuple{Any, A, Tuple{DataType, DataType}}} where A&lt;:AbstractArray"><code>CrimsonSkyline.mh</code></a></li><li><a href="#CrimsonSkyline.mh-Union{Tuple{A}, Tuple{Any, A}} where A&lt;:AbstractArray"><code>CrimsonSkyline.mh</code></a></li><li><a href="#CrimsonSkyline.mh-Tuple{Any, Tuple{DataType, DataType}}"><code>CrimsonSkyline.mh</code></a></li><li><a href="#CrimsonSkyline.mh_step-Tuple{Trace, Any}"><code>CrimsonSkyline.mh_step</code></a></li><li><a href="#CrimsonSkyline.mh_step-Tuple{RandomField, Any, Any, Any}"><code>CrimsonSkyline.mh_step</code></a></li><li><a href="#CrimsonSkyline.mh_step-Tuple{Trace, Any, Tuple{DataType, DataType}}"><code>CrimsonSkyline.mh_step</code></a></li><li><a href="#CrimsonSkyline.mh_step-Tuple{Trace, Any, Any}"><code>CrimsonSkyline.mh_step</code></a></li><li><a href="#CrimsonSkyline.mh_step-Tuple{Trace, Any, Any, Tuple{DataType, DataType}}"><code>CrimsonSkyline.mh_step</code></a></li><li><a href="#CrimsonSkyline.nested-Tuple{Any}"><code>CrimsonSkyline.nested</code></a></li><li><a href="#CrimsonSkyline.nested-Tuple{Any, Any}"><code>CrimsonSkyline.nested</code></a></li><li><a href="#CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{Any, A, D, Bool, Interpretation}} where {A, D&lt;:Distributions.Sampleable}"><code>CrimsonSkyline.node</code></a></li><li><a href="#CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{DataType, A, D, Bool, Interpretation}} where {A, D&lt;:Distributions.Sampleable}"><code>CrimsonSkyline.node</code></a></li><li><a href="#CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{DataType, A, D, Bool, Interpretation}} where {A, D}"><code>CrimsonSkyline.node</code></a></li><li><a href="#CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{Any, A, D, Bool, Interpretation}} where {A, D}"><code>CrimsonSkyline.node</code></a></li><li><a href="#CrimsonSkyline.normalized_weights-Union{Tuple{CrimsonSkyline.SamplingResults{I}}, Tuple{I}} where I&lt;:CrimsonSkyline.Importance"><code>CrimsonSkyline.normalized_weights</code></a></li><li><a href="#CrimsonSkyline.observe-Tuple{Trace, Any, Any, Any}"><code>CrimsonSkyline.observe</code></a></li><li><a href="#CrimsonSkyline.pa_from_trace-Tuple{Trace, Any}"><code>CrimsonSkyline.pa_from_trace</code></a></li><li><a href="#CrimsonSkyline.plate-Union{Tuple{F}, Tuple{T}, Tuple{Trace, F, Any, Any, Vector{T}, Any}} where {T, F&lt;:Function}"><code>CrimsonSkyline.plate</code></a></li><li><a href="#CrimsonSkyline.plate-Union{Tuple{F}, Tuple{Trace, F, Any, Any, Int64, CrimsonSkyline.Blocked}} where F&lt;:Function"><code>CrimsonSkyline.plate</code></a></li><li><a href="#CrimsonSkyline.plate-Union{Tuple{F}, Tuple{T}, Tuple{Trace, F, Any, Any, Vector{T}}} where {T, F&lt;:Function}"><code>CrimsonSkyline.plate</code></a></li><li><a href="#CrimsonSkyline.plate-Union{Tuple{F}, Tuple{Trace, F, Any, Any, Int64, Conditioned}} where F&lt;:Function"><code>CrimsonSkyline.plate</code></a></li><li><a href="#CrimsonSkyline.plate-Union{Tuple{F}, Tuple{Trace, F, Any, Any, Int64}} where F&lt;:Function"><code>CrimsonSkyline.plate</code></a></li><li><a href="#CrimsonSkyline.plate-Union{Tuple{F}, Tuple{Trace, F, Any, Any, Int64, Replayed}} where F&lt;:Function"><code>CrimsonSkyline.plate</code></a></li><li><a href="#CrimsonSkyline.plate-Union{Tuple{F}, Tuple{Trace, F, Any, Any, Int64, Nonstandard}} where F&lt;:Function"><code>CrimsonSkyline.plate</code></a></li><li><a href="#CrimsonSkyline.propose-Tuple{Trace, Any, Any}"><code>CrimsonSkyline.propose</code></a></li><li><a href="#CrimsonSkyline.query-Tuple{SQLModel, String}"><code>CrimsonSkyline.query</code></a></li><li><a href="#CrimsonSkyline.rejection-Tuple{Any, Float64, Vararg{Any, N} where N}"><code>CrimsonSkyline.rejection</code></a></li><li><a href="#CrimsonSkyline.replace-Tuple{Any, Dict}"><code>CrimsonSkyline.replace</code></a></li><li><a href="#CrimsonSkyline.replace-Union{Tuple{T}, Tuple{T, Dict}} where T&lt;:Trace"><code>CrimsonSkyline.replace</code></a></li><li><a href="#CrimsonSkyline.replay-Union{Tuple{T}, Tuple{Any, T}} where T&lt;:Trace"><code>CrimsonSkyline.replay</code></a></li><li><a href="#CrimsonSkyline.rewrite-Union{Tuple{T}, Tuple{Any, T, Dict}} where T&lt;:Trace"><code>CrimsonSkyline.rewrite</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, Replayed}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, CrimsonSkyline.Blocked}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Union{Tuple{I}, Tuple{CrimsonSkyline.SamplingResults{I}, Any, Int64}} where I&lt;:CrimsonSkyline.Importance"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, CrimsonSkyline.Blocked}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, Nonstandard}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Nonstandard}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, Deterministic}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Vector{Interpretation}}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Union{Conditioned, Standard}}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Union{Tuple{I}, Tuple{Trace, Any, NonparametricSamplingResults{I}}} where I&lt;:CrimsonSkyline.InferenceType"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Replayed}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, Vector{Interpretation}}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, Standard}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Union{Tuple{I}, Tuple{Trace, Any, ParametricSamplingResults{I}}} where I&lt;:CrimsonSkyline.InferenceType"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.save-Tuple{Trace, Any}"><code>CrimsonSkyline.save</code></a></li><li><a href="#CrimsonSkyline.save-Tuple{CrimsonSkyline.SamplingResults, Any}"><code>CrimsonSkyline.save</code></a></li><li><a href="#CrimsonSkyline.to_parametric-Union{Tuple{NonparametricSamplingResults{I}}, Tuple{I}} where I&lt;:CrimsonSkyline.InferenceType"><code>CrimsonSkyline.to_parametric</code></a></li><li><a href="#CrimsonSkyline.to_table-Tuple{Trace}"><code>CrimsonSkyline.to_table</code></a></li><li><a href="#CrimsonSkyline.trace-Tuple{}"><code>CrimsonSkyline.trace</code></a></li><li><a href="#CrimsonSkyline.trace-Tuple{Any, Any}"><code>CrimsonSkyline.trace</code></a></li><li><a href="#CrimsonSkyline.transform-Union{Tuple{F}, Tuple{Trace, Any, F, Any}} where F&lt;:Function"><code>CrimsonSkyline.transform</code></a></li><li><a href="#CrimsonSkyline.update-Union{Tuple{I}, Tuple{Any, CrimsonSkyline.SamplingResults{I}}} where I&lt;:CrimsonSkyline.InferenceType"><code>CrimsonSkyline.update</code></a></li><li><a href="#Distributions.logpdf-Union{Tuple{A}, Tuple{A, Any}} where A&lt;:AbstractArray"><code>Distributions.logpdf</code></a></li></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 22 August 2021 10:51">Sunday 22 August 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
