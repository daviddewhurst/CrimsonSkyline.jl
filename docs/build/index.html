<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>CrimsonSkyline.jl · CrimsonSkyline.jl documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">CrimsonSkyline.jl documentation</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>CrimsonSkyline.jl</a><ul class="internal"><li><a class="tocitem" href="#trace"><span>trace</span></a></li><li><a class="tocitem" href="#io"><span>io</span></a></li><li><a class="tocitem" href="#effects"><span>effects</span></a></li><li><a class="tocitem" href="#graph"><span>graph</span></a></li><li><a class="tocitem" href="#cpt"><span>cpt</span></a></li><li><a class="tocitem" href="#importance"><span>importance</span></a></li><li><a class="tocitem" href="#metropolis"><span>metropolis</span></a></li><li><a class="tocitem" href="#results"><span>results</span></a></li><li><a class="tocitem" href="#fusion"><span>fusion</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>CrimsonSkyline.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>CrimsonSkyline.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com//blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="CrimsonSkyline.jl"><a class="docs-heading-anchor" href="#CrimsonSkyline.jl">CrimsonSkyline.jl</a><a id="CrimsonSkyline.jl-1"></a><a class="docs-heading-anchor-permalink" href="#CrimsonSkyline.jl" title="Permalink"></a></h1><h2 id="trace"><a class="docs-heading-anchor" href="#trace">trace</a><a id="trace-1"></a><a class="docs-heading-anchor-permalink" href="#trace" title="Permalink"></a></h2><p>To a large extent, <code>Node</code>s have local control over the behavior of inference algorithms via their  <code>interpretation</code>. There are a variety of <code>Interpretation</code>s. The type hierarchy is flat:</p><pre><code class="language-none">abstract type Interpretation end
struct Nonstandard &lt;: Interpretation end
struct Standard &lt;: Interpretation end
struct Replayed &lt;: Interpretation end
struct Conditioned &lt;: Interpretation end 
struct Blocked &lt;: Interpretation end
struct Deterministic &lt;: Interpretation end
struct Proposed &lt;: Interpretation end</code></pre><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.Node" href="#CrimsonSkyline.Node"><code>CrimsonSkyline.Node</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct Node{A, D, T, P}
    address :: A
    dist :: D
    value :: Maybe{T}
    logprob :: P
    logprob_sum :: Float64
    observed :: Bool
    pa :: Array{Node, 1}
    ch :: Array{Node, 1}
    interpretation :: Interpretation
    last_interpretation :: Interpretation
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.Trace" href="#CrimsonSkyline.Trace"><code>CrimsonSkyline.Trace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct Trace
    trace :: OrderedDict{Any, Node}
    logprob_sum :: Float64
end</code></pre><p><code>Trace</code>s support the following <code>Base</code> methods: <code>setindex!</code>, <code>getindex</code>, <code>keys</code>, <code>values</code>, and <code>length</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.aic-Tuple{Trace}" href="#CrimsonSkyline.aic-Tuple{Trace}"><code>CrimsonSkyline.aic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function aic(t :: Trace)</code></pre><p>Computes the Akaike Information Criterion for a <em>single trace</em> (thus replacing the definition) with  &quot;maximum likelihood&quot; by one with &quot;likelihood&quot;. The formula is </p><p class="math-container">\[\text{AIC}(t)/2 = |\text{params}(t)| - \ell(t),\]</p><p>where <span>$\text{params}(t)|$</span> is the number of non-observed and non-deterministic sample nodes.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.connect_pa_ch!-Tuple{Trace,Any,Any}" href="#CrimsonSkyline.connect_pa_ch!-Tuple{Trace,Any,Any}"><code>CrimsonSkyline.connect_pa_ch!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function connect_pa_ch!(t :: Trace, pa, a)</code></pre><p>Connects parent and child nodes. Adds child nodes to parent&#39;s <code>ch</code> and  parent nodes to child&#39;s <code>pa</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.interpret_latent!-Tuple{Trace,CrimsonSkyline.Interpretation}" href="#CrimsonSkyline.interpret_latent!-Tuple{Trace,CrimsonSkyline.Interpretation}"><code>CrimsonSkyline.interpret_latent!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function interpret_latent!(t :: Trace, i :: Interpretation)</code></pre><p>Changes the interpretation of all nodes in <code>t</code> to have <code>interpretation == i</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.loglikelihood-Tuple{Trace}" href="#CrimsonSkyline.loglikelihood-Tuple{Trace}"><code>CrimsonSkyline.loglikelihood</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function loglikelihood(t :: Trace)</code></pre><p>Computes and returns the log likelihood of the observed data under the model:</p><p class="math-container">\[\ell(t) = 
\sum_{a:\ [a \in \text{keys}(t)] \wedge [\text{interpretation}(a) = \text{Standard}]} 
\log p(t[a])\]</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.logprob!-Tuple{Trace}" href="#CrimsonSkyline.logprob!-Tuple{Trace}"><code>CrimsonSkyline.logprob!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function logprob!(t :: Trace)</code></pre><p>Computes the joint log probability to the trace and assigns it to <code>t.logprob_sum</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.logprob-Tuple{Trace}" href="#CrimsonSkyline.logprob-Tuple{Trace}"><code>CrimsonSkyline.logprob</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function logprob(t :: Trace)</code></pre><p>Computes and returns the joint log probability of the trace:</p><p class="math-container">\[\log p(t) = \sum_{a \in \text{keys}(t)}\log p(t[a])\]</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{Any,A,D,Bool,CrimsonSkyline.Interpretation}} where D where A" href="#CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{Any,A,D,Bool,CrimsonSkyline.Interpretation}} where D where A"><code>CrimsonSkyline.node</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function node(value, address :: A, dist :: D, is_obs :: Bool, i :: Interpretation) where {A, D}</code></pre><p>Outer constructor for <code>Node</code> where data is passed during construction. Data type is inferred from the passed data.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{DataType,A,D,Bool,CrimsonSkyline.Interpretation}} where D where A" href="#CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{DataType,A,D,Bool,CrimsonSkyline.Interpretation}} where D where A"><code>CrimsonSkyline.node</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function node(T :: DataType, address :: A, dist :: D, is_obs :: Bool, i :: Interpretation) where {A, D}</code></pre><p>Outer constructor for <code>Node</code> where no data is passed during construction. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.observe-Tuple{Trace,Any,Any,Any}" href="#CrimsonSkyline.observe-Tuple{Trace,Any,Any,Any}"><code>CrimsonSkyline.observe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function observe(t :: Trace, a, d, s; pa = ())</code></pre><p>If <code>d</code> is not <code>nothing</code> an alias for calling <code>sample</code> with standard interpretation.  Otherwise, an alias for calling <code>sample</code> with nonstandard interpretation. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.pa_from_trace-Tuple{Trace,Any}" href="#CrimsonSkyline.pa_from_trace-Tuple{Trace,Any}"><code>CrimsonSkyline.pa_from_trace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function pa_from_trace(t :: Trace, pa)</code></pre><p>Collects nodes in trace corresponding to an iterable of parent addresses <code>pa</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.prior-Union{Tuple{F}, Tuple{F,Union{Tuple, AbstractArray},Vararg{Any,N} where N}} where F&lt;:Function" href="#CrimsonSkyline.prior-Union{Tuple{F}, Tuple{F,Union{Tuple, AbstractArray},Vararg{Any,N} where N}} where F&lt;:Function"><code>CrimsonSkyline.prior</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function prior(f :: F, addresses :: Union{AbstractArray, Tuple}, params...; nsamples :: Int = 1) where F &lt;: Function</code></pre><p>Given a generative function <code>f</code>, an array-like of addresses, and a collection of parameters to pass to <code>f</code>, runs <code>nsamples</code> evaluations of the <code>f</code>, collecting the values from the <code>addresses</code> and returning a <code>Dict</code> mapping addresses to values. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.propose-Tuple{Trace,Any,Any}" href="#CrimsonSkyline.propose-Tuple{Trace,Any,Any}"><code>CrimsonSkyline.propose</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">propose(t :: Trace, a, d)</code></pre><p>Propose a value for the address <code>a</code> in trace <code>t</code> from the distribution <code>d</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any,Array{CrimsonSkyline.Interpretation,1}}" href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any,Array{CrimsonSkyline.Interpretation,1}}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, d, params, ii :: Array{Interpretation, 1}; pa = ())</code></pre><p>Sequentially apply sample statements with interpretations as given in <code>ii</code>. This is  used to depth-first traverse the interpretation graph.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any,CrimsonSkyline.Blocked}" href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any,CrimsonSkyline.Blocked}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, d, params, i :: Blocked; pa = ())</code></pre><p>Samples from <code>d</code> passing the optional arguments <code>params</code>, deletes the node stored at address <code>a</code> from trace <code>t</code>, and returns the sampled value. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any,Deterministic}" href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any,Deterministic}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, f, v, i :: Deterministic; pa = ())</code></pre><p>Creates a deterministic node mapping the tuple of data <code>v</code> through function <code>f</code>,  storing the value in trace <code>t</code> at address <code>a</code>.</p><ol><li>Infers input type from <code>v</code></li><li>Maps tuple of data <code>v</code> through function <code>f</code>, yielding <code>r = f(v...)</code></li><li>Creates a deterministic node and stores it in <code>t</code> at address <code>a</code></li><li>Optionally adds nodes corresponding to the addresses in <code>pa</code> as parent nodes</li><li>Returns <code>r</code></li></ol></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any,Nonstandard}" href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any,Nonstandard}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, d, params, i :: Nonstandard; pa = ())</code></pre><p>Samples from distribution <code>d</code> into trace <code>t</code> at address <code>a</code>.</p><ol><li>Samples a value from <code>d</code> passing the optional arguments <code>params</code></li><li>Creates a sample node</li><li>Adds the sample node to trace <code>t</code> at value <code>a</code></li><li>Optionally adds nodes corresponding to the addresses in <code>pa</code> as parent nodes</li><li>Returns the sampled value</li></ol></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any,Replayed}" href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any,Replayed}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, d, params, i :: Replayed; pa = ())</code></pre><p>Replays the sampled node through the trace. </p><ol><li>If <code>a</code> is not in <code>t</code>&#39;s address set, calls <code>sample(t, a, d, NONSTANDARD; pa = pa)</code>. </li><li>Creates a sample node that copies the value from the last node stored in the trace at address <code>a</code>. </li><li>Adds the sample node to trace <code>t</code> at value <code>a</code></li><li>Optionally adds nodes corresponding to the addresses in <code>pa</code> as parent nodes</li><li>Resets the node&#39;s interpretation to the original interpretation</li></ol></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any,Standard}" href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any,Standard}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, d, s, i :: Standard; pa = ())</code></pre><p>Scores an observed value <code>s</code> against the distribution <code>d</code>, storing the value in trace <code>t</code> at  address <code>a</code> and optionally adds nodes corresponding to the addresses in <code>pa</code> as parent nodes.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any}" href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, d, params; pa = ())</code></pre><p>If <code>a</code> is in the set of trace addresses, calls <code>sample</code> using <code>t[a]</code>&#39;s interpretation.  Otherwise, calls <code>sample</code> using nonstandard interpretation. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace,Any,Any,Array{CrimsonSkyline.Interpretation,1}}" href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Array{CrimsonSkyline.Interpretation,1}}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, d, ii :: Array{Interpretation, 1}; pa = ())</code></pre><p>Sequentially apply sample statements with interpretations as given in <code>ii</code>. This is  used to depth-first traverse the interpretation graph.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace,Any,Any,CrimsonSkyline.Blocked}" href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any,CrimsonSkyline.Blocked}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, d, i :: Blocked; pa = ())</code></pre><p>Samples from <code>d</code>, deletes the node stored at address <code>a</code> from trace <code>t</code>, and returns the  sampled value. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace,Any,Any,Nonstandard}" href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Nonstandard}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, d, i :: Nonstandard; pa = ())</code></pre><p>Samples from distribution <code>d</code> into trace <code>t</code> at address <code>a</code>.</p><ol><li>Samples a value from <code>d</code></li><li>Creates a sample node</li><li>Adds the sample node to trace <code>t</code> at value <code>a</code></li><li>Optionally adds nodes corresponding to the addresses in <code>pa</code> as parent nodes</li><li>Returns the sampled value</li></ol></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace,Any,Any,Replayed}" href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Replayed}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, d, i :: Replayed; pa = ())</code></pre><p>Replays the sampled node through the trace. </p><ol><li>If <code>a</code> is not in <code>t</code>&#39;s address set, calls <code>sample(t, a, d, NONSTANDARD; pa = pa)</code>. </li><li>Creates a sample node that copies the value from the last node stored in the trace at address <code>a</code>. </li><li>Adds the sample node to trace <code>t</code> at value <code>a</code></li><li>Optionally adds nodes corresponding to the addresses in <code>pa</code> as parent nodes</li><li>Resets the node&#39;s interpretation to the original interpretation</li></ol></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace,Any,Any,Standard}" href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Standard}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, d, i :: Standard; pa = ())</code></pre><p>Scores an observed value against the distribution <code>d</code>, storing the value in trace <code>t</code> at  address <code>a</code> and optionally adds nodes corresponding to the addresses in <code>pa</code> as parent nodes.</p><p>This method is used by the <code>condition</code> effect. It will probably not be used by most  users.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Tuple{Trace,Any,Any}" href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any}"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, d; pa = ())</code></pre><p>If <code>a</code> is in the set of trace addresses, calls <code>sample</code> using <code>t[a]</code>&#39;s interpretation.  Otherwise, calls <code>sample</code> using nonstandard interpretation. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.trace-Tuple{}" href="#CrimsonSkyline.trace-Tuple{}"><code>CrimsonSkyline.trace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">trace()</code></pre><p>This is the recommended way to construct a new trace.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.transform-Union{Tuple{F}, Tuple{Trace,Any,F,Any}} where F&lt;:Function" href="#CrimsonSkyline.transform-Union{Tuple{F}, Tuple{Trace,Any,F,Any}} where F&lt;:Function"><code>CrimsonSkyline.transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function transform(t :: Trace, a, f :: F, v; pa = ()) where F &lt;: Function</code></pre><p>Alias for <code>sample(t, a, f, v, DETERMINISTIC; pa = pa)</code>.</p></div></section></article><h2 id="io"><a class="docs-heading-anchor" href="#io">io</a><a id="io-1"></a><a class="docs-heading-anchor-permalink" href="#io" title="Permalink"></a></h2><p>Saving and loading traces is possible using the <code>save</code> and <code>load</code> functions. This functionality depends on <code>JuliaDB</code>. Example usage (<code>fn</code> is a stochastic function):</p><pre><code class="language-none">t = trace()
data = randn(2)
fn(t, data)
fname = joinpath(@__DIR__, &quot;out&quot;, &quot;my_file.jdb&quot;)
f = save(t, fname)
identical_t = load(f)</code></pre><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.load-Tuple{Any}" href="#CrimsonSkyline.load-Tuple{Any}"><code>CrimsonSkyline.load</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function load(f) :: Trace</code></pre><p>Loads a serialized juliadb table from file <code>f</code> and converts it into a trace.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.save-Tuple{Trace,Any}" href="#CrimsonSkyline.save-Tuple{Trace,Any}"><code>CrimsonSkyline.save</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function save(t :: Trace, f)</code></pre><p>Saves a trace to disk as a serialized juliadb table at the filepath <code>f</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.to_table-Tuple{Trace}" href="#CrimsonSkyline.to_table-Tuple{Trace}"><code>CrimsonSkyline.to_table</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function to_table(t :: Trace)</code></pre><p>Turns a trace into a juliadb table. Does not store parent / child relationships.</p></div></section></article><h2 id="effects"><a class="docs-heading-anchor" href="#effects">effects</a><a id="effects-1"></a><a class="docs-heading-anchor-permalink" href="#effects" title="Permalink"></a></h2><p>A library of functions that change the interpretation of some or all nodes in a trace.</p><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.block-Union{Tuple{F}, Tuple{F,Trace,Any}} where F&lt;:Function" href="#CrimsonSkyline.block-Union{Tuple{F}, Tuple{F,Trace,Any}} where F&lt;:Function"><code>CrimsonSkyline.block</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function block(f :: F, t :: Trace, addresses) where F &lt;: Function</code></pre><p>Given a stochastic function <code>f</code>, a trace <code>t</code>, and an iterable of addresses, converts traced randomness into untraced randomness. </p><p>Returns a tuple <code>(t_new, g)</code>, where <code>t_new</code> is a trace and <code>g</code> is a function. The function signature of <code>g</code> is the same as that of <code>f</code> with the first argument removed; that is, if <code>f(t :: Trace, params...)</code>, then <code>g(params...)</code>. Computation is delayed, so each of  the latent nodes in <code>t_new</code> has <code>interpretation = BLOCKED</code>. Calling <code>g(params...)</code> executes the  computation and each latent node in <code>t_new</code> with an address in <code>addresses</code> is removed.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.block-Union{Tuple{F}, Tuple{F,Trace}} where F&lt;:Function" href="#CrimsonSkyline.block-Union{Tuple{F}, Tuple{F,Trace}} where F&lt;:Function"><code>CrimsonSkyline.block</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">block(f :: F, t :: Trace) where F &lt;: Function</code></pre><p>Converts all traced randomness into untraced randomness.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.condition-Union{Tuple{F}, Tuple{F,Dict}} where F&lt;:Function" href="#CrimsonSkyline.condition-Union{Tuple{F}, Tuple{F,Dict}} where F&lt;:Function"><code>CrimsonSkyline.condition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function condition(f :: F, evidence :: Dict) where F &lt;: Function</code></pre><p>Condition a trace modified by <code>f</code> on <code>evidence</code>, which maps addresses to observed  evidence associated with that address. Returns a function with call signature  identical to that of <code>f</code> and return signature <code>(t :: Trace, rtype)</code> where <code>rtype</code> is the return type of <code>f</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.replace-Tuple{Trace,Dict}" href="#CrimsonSkyline.replace-Tuple{Trace,Dict}"><code>CrimsonSkyline.replace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function replace(t :: Trace, r :: Dict)</code></pre><p>Given a mapping <code>r</code> from addresses to distribution-like (currently <code>Distributions</code> or <code>Array{Any, 1}</code>s), replaces the current distributions at that set of addresses with this set of distributions. Returns the modified trace.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.replace-Union{Tuple{F}, Tuple{F,Dict}} where F&lt;:Function" href="#CrimsonSkyline.replace-Union{Tuple{F}, Tuple{F,Dict}} where F&lt;:Function"><code>CrimsonSkyline.replace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function replace(f :: F, r :: Dict) where F &lt;: Function</code></pre><p>Given a mapping <code>r</code> from addresses to distribution-like (currently <code>Distributions</code> or <code>Array{Any, 1}</code>s), replaces the current distributions at that set of addresses with this set of distributions. Returns a function <code>g</code> that has return signature  <code>(t :: Trace, rval)</code> where <code>rval</code> is a return value of <code>f</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.replay-Union{Tuple{F}, Tuple{F,Trace}} where F&lt;:Function" href="#CrimsonSkyline.replay-Union{Tuple{F}, Tuple{F,Trace}} where F&lt;:Function"><code>CrimsonSkyline.replay</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function replay(f :: F, t :: Trace) where F &lt;: Function</code></pre><p>Given a stochastic function <code>f</code> and a trace <code>t</code>, makes <code>sample</code> calls behave as though  they had sampled the values in <code>t</code> at the corresponding addresses. </p><p>Returns a tuple <code>(t_new, g)</code>, where <code>t_new</code> is a trace and <code>g</code> is a function. The function signature of <code>g</code> is the same as that of <code>f</code> with the first argument removed; that is, if <code>f(t :: Trace, params...)</code>, then <code>g(params...)</code>. Computation is delayed, so each of the latent nodes in <code>t_new</code> has <code>interpretation = REPLAYED</code>. Calling <code>g(params...)</code> executes the computation and each latent node in <code>t_new</code> reverts to  its original interpretation. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.rewrite-Union{Tuple{F}, Tuple{F,Trace,Dict}} where F&lt;:Function" href="#CrimsonSkyline.rewrite-Union{Tuple{F}, Tuple{F,Trace,Dict}} where F&lt;:Function"><code>CrimsonSkyline.rewrite</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function rewrite(f :: F, t :: Trace, r :: Dict) where F &lt;: Function</code></pre><p>Rewrites the history of the trace to make it appear as if the values in the trace were sampled at the addresses in the keys of <code>r</code> were sampled from the  corresponding distributions in the values of <code>r</code>. Returns a function with  call signature <code>g(params...)</code> that returns <code>(t :: Trace, rval)</code>, where <code>rval</code>  is the return type of <code>f</code>. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.update-Union{Tuple{I}, Tuple{F}, Tuple{F,SamplingResults{I}}} where I&lt;:CrimsonSkyline.InferenceType where F&lt;:Function" href="#CrimsonSkyline.update-Union{Tuple{I}, Tuple{F}, Tuple{F,SamplingResults{I}}} where I&lt;:CrimsonSkyline.InferenceType where F&lt;:Function"><code>CrimsonSkyline.update</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function update(f :: F, r :: SamplingResults{I}) where {F &lt;: Function, I &lt;: InferenceType}</code></pre><p><strong>EXPERIMENTAL</strong>: Given a stochastic function <code>f</code> and a <code>SamplingResults</code> <code>r</code>, update the prior  predictive to the posterior predictive by jointly replacing all latent sample sites with the joint empirical  posterior. Returns a stochastic function <code>g</code> with the same call signature as <code>f</code>. This function will modify in  place the trace passed into it as the first argument.</p></div></section></article><h2 id="graph"><a class="docs-heading-anchor" href="#graph">graph</a><a id="graph-1"></a><a class="docs-heading-anchor-permalink" href="#graph" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.Factor" href="#CrimsonSkyline.Factor"><code>CrimsonSkyline.Factor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Factor 
    info :: OrderedDict{Any, OrderedDict}
    node_to_factor :: OrderedDict
    factor_to_node :: OrderedDict
end</code></pre><p>A representation of a factor graph. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.GraphIR" href="#CrimsonSkyline.GraphIR"><code>CrimsonSkyline.GraphIR</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct GraphIR 
    info :: OrderedDict{Any, OrderedDict}
    graph :: OrderedDict
end</code></pre><p>An intermediate representation of a single trace as a directed acyclic graph (DAG) that  stores node information in <code>info</code> and DAG structure in <code>graph</code>. The keys and values of <code>graph</code> are addresses, while <code>info</code> is a mapping from addresses to results from calls to <code>node_info</code>. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.factor-Tuple{GraphIR}" href="#CrimsonSkyline.factor-Tuple{GraphIR}"><code>CrimsonSkyline.factor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function factor(g :: GraphIR)</code></pre><p>Outer constructor for a factor graph from an intermediate DAG representation. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.factor-Tuple{Trace}" href="#CrimsonSkyline.factor-Tuple{Trace}"><code>CrimsonSkyline.factor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">factor(t :: Trace)</code></pre><p>Outer constructor for a factor graph from a trace. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.graph_ir-Tuple{Trace}" href="#CrimsonSkyline.graph_ir-Tuple{Trace}"><code>CrimsonSkyline.graph_ir</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function graph_ir(t :: Trace)</code></pre><p>Outer constructor for <code>GraphIR</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.node_info-Tuple{Trace,Any}" href="#CrimsonSkyline.node_info-Tuple{Trace,Any}"><code>CrimsonSkyline.node_info</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function node_info(t :: Trace, a)</code></pre><p>Returns an <code>OrderedDict</code> containing all information about the node <code>t[a]</code> required for graph-based inference algorithms.</p><p>Keys include:</p><ul><li><code>&quot;address&quot;</code>: the address of the node in the trace</li><li><code>&quot;dist&quot;</code>: the probability distribution associated with the address</li><li><code>&quot;observed&quot;</code>: whether or not the value associated with the node was observed</li><li><code>&quot;interpretation&quot;</code>: the interpretation of the node in the trace</li><li><code>&quot;data&quot;</code> (optional): if the value associated with the node was observed, the value associated   with the node. </li><li><code>&quot;pa&quot;</code>: the parents of the node in the trace. Note that it is necessary to pass parent addresses   to one of the various sample methods in order to build a nontrivial <code>GraphIR</code>.</li></ul></div></section></article><h2 id="cpt"><a class="docs-heading-anchor" href="#cpt">cpt</a><a id="cpt-1"></a><a class="docs-heading-anchor-permalink" href="#cpt" title="Permalink"></a></h2><p>Conditional probability tables (CPT) are a work in progress. Currently there are no implemented inference algorithms that operate on CPTs. </p><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.CPT" href="#CrimsonSkyline.CPT"><code>CrimsonSkyline.CPT</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct CPT{L&lt;:AbstractDict, D&lt;:AbstractArray}
    dims :: L
    axes :: Dict{Any, Int64}
    labels :: Array{Dict, 1}
    values :: D
end</code></pre><p>A representation of an arbitrary-dimensional ragged CPT. Supports <code>Base</code> methods  <code>setindex!</code> and <code>getindex</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.cpt-Tuple{L} where L&lt;:AbstractDict" href="#CrimsonSkyline.cpt-Tuple{L} where L&lt;:AbstractDict"><code>CrimsonSkyline.cpt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function cpt(dims :: L) where L &lt;: AbstractDict</code></pre><p>Outer constructor for <code>CPT</code>. Given a <code>Dict</code> that maps names of dimensions to dimension level names, constructs a CPT with equiprobable coordinates.</p><p>Example usage:</p><pre><code class="language-none">dims = Dict(&quot;cost&quot; =&gt; [&quot;high&quot;, &quot;low&quot;], &quot;revenue&quot; =&gt; [&quot;high&quot;, &quot;medium&quot;, &quot;low&quot;])
c = cpt(dims)
c[(&quot;high&quot;, &quot;low&quot;)] = 0.4
c[(&quot;high&quot;, &quot;high&quot;)] = 0.2
c[(&quot;low&quot;, &quot;low&quot;)] = 0.3
renormalize!(c)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.renormalize!-Tuple{CPT}" href="#CrimsonSkyline.renormalize!-Tuple{CPT}"><code>CrimsonSkyline.renormalize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">renormalize!(c :: CPT)</code></pre><p>Renormalizes the possibly non-normalized factor <code>c</code> to be a proper discrete joint density.</p></div></section></article><h2 id="importance"><a class="docs-heading-anchor" href="#importance">importance</a><a id="importance-1"></a><a class="docs-heading-anchor-permalink" href="#importance" title="Permalink"></a></h2><p>Importance sampling algorithms and utilities.  Currently the following importance sampling algorithms are implemented:</p><ul><li>Likelihood weighting</li><li>Generic user-defined proposal</li></ul><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.importance_sampling-Union{Tuple{F2}, Tuple{F1}, Tuple{F1,F2}} where F2&lt;:Function where F1&lt;:Function" href="#CrimsonSkyline.importance_sampling-Union{Tuple{F2}, Tuple{F1}, Tuple{F1,F2}} where F2&lt;:Function where F1&lt;:Function"><code>CrimsonSkyline.importance_sampling</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function importance_sampling(f :: F1, q :: F2; params = (), nsamples :: Int = 1) where {F1 &lt;: Function, F2 &lt;: Function}</code></pre><p>Given a stochastic function <code>f</code>, a proposal function <code>q</code>, and a tuple of <code>params</code> to pass to <code>f</code> and <code>q</code>, compute <code>nsamples</code> iterations of importance sampling. <code>q</code> must have the same input signature  as <code>f</code>. Returns a <code>SamplingResults</code> instance.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.is_step-Union{Tuple{F2}, Tuple{F1}, Tuple{F1,F2}} where F2&lt;:Function where F1&lt;:Function" href="#CrimsonSkyline.is_step-Union{Tuple{F2}, Tuple{F1}, Tuple{F1,F2}} where F2&lt;:Function where F1&lt;:Function"><code>CrimsonSkyline.is_step</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function is_step(f :: F1, q :: F2; params = ()) where {F1 &lt;: Function, F2 &lt;: Function}</code></pre><p>Perform one step of importance sampling – draw a single sample from the proposal <code>q</code>, replay  it through <code>f</code>, and record the log weight as <span>$\log W_n = \log p(x, z_n) - \log q(z_n)$</span>. Returns a tuple (log weight, rval, trace). </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.likelihood_weighting-Union{Tuple{F}, Tuple{F,Vararg{Any,N} where N}} where F&lt;:Function" href="#CrimsonSkyline.likelihood_weighting-Union{Tuple{F}, Tuple{F,Vararg{Any,N} where N}} where F&lt;:Function"><code>CrimsonSkyline.likelihood_weighting</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function likelihood_weighting(f :: F, params...; nsamples :: Int = 1) where F &lt;: Function</code></pre><p>Given a stochastic function f and arguments to the function <code>params...</code>, executes <code>nsamples</code> iterations of importance sampling by using the prior as a proposal distribution. The importance weights are given by <span>$\log W_n = \ell(t_n)$</span>. Returns an <code>SamplingResults</code> instance. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.likelihood_weighting_results-Tuple{}" href="#CrimsonSkyline.likelihood_weighting_results-Tuple{}"><code>CrimsonSkyline.likelihood_weighting_results</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">likelihood_weighting_results()</code></pre><p>Outer constructor for <code>SamplingResults</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.log_evidence-Union{Tuple{SamplingResults{I}}, Tuple{I}} where I&lt;:CrimsonSkyline.Importance" href="#CrimsonSkyline.log_evidence-Union{Tuple{SamplingResults{I}}, Tuple{I}} where I&lt;:CrimsonSkyline.Importance"><code>CrimsonSkyline.log_evidence</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function log_evidence(r :: SamplingResults{LikelihoodWeighting})</code></pre><p>Computes the log evidence (log partition function), </p><p><span>$\log Z \equiv \log p(x) \approx -\log N_{\text{samples}} + \log \sum_{n=1}^{N_{\text{samples}}} W_n.$</span></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.lw_step-Union{Tuple{F}, Tuple{F,Vararg{Any,N} where N}} where F&lt;:Function" href="#CrimsonSkyline.lw_step-Union{Tuple{F}, Tuple{F,Vararg{Any,N} where N}} where F&lt;:Function"><code>CrimsonSkyline.lw_step</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function lw_step(f :: F, params...) where F &lt;: Function</code></pre><p>Perform one step of likelihood weighting – draw a single proposal from the prior and compute  the log weight as equal to the likelihood. Returns a tuple (log weight, rval, trace).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.normalized_weights-Union{Tuple{SamplingResults{I}}, Tuple{I}} where I&lt;:CrimsonSkyline.Importance" href="#CrimsonSkyline.normalized_weights-Union{Tuple{SamplingResults{I}}, Tuple{I}} where I&lt;:CrimsonSkyline.Importance"><code>CrimsonSkyline.normalized_weights</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function normalized_weights(r :: SamplingResults{LikelihoodWeighting})</code></pre><p>Computes the normalized weights <span>$w_n$</span> from unnormalized weights <span>$W_n$</span>:</p><p><span>$w_n = W_n / p(x) = \exp\{\ell(t_n) - \log Z\}.$</span></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Union{Tuple{I}, Tuple{SamplingResults{I},Any,Int64}} where I&lt;:CrimsonSkyline.Importance" href="#CrimsonSkyline.sample-Union{Tuple{I}, Tuple{SamplingResults{I},Any,Int64}} where I&lt;:CrimsonSkyline.Importance"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(r :: SamplingResults{LikelihoodWeighting}, k, n :: Int)</code></pre><p>Draws <code>n</code> samples from the empirical marginal posterior at address <code>k</code>.</p></div></section></article><h2 id="metropolis"><a class="docs-heading-anchor" href="#metropolis">metropolis</a><a id="metropolis-1"></a><a class="docs-heading-anchor-permalink" href="#metropolis" title="Permalink"></a></h2><p>Metropolis algorithm and utilities. Currently the following algorithms are implemented for both  FOPPL and HOPPL programs:</p><ul><li>Independent prior proposal</li><li>Arbitrary single- or multi-site proposal</li></ul><p>Here are two examples of inference using the arbitrary MH step interface. Consider the following generative function:</p><pre><code class="language-none">function normal_model(t :: Trace, data :: Vector{Float64})
    loc = sample(t, :loc, Normal(0.0, 10.0))
    scale = sample(t, :scale, LogNormal())
    for i in 1:length(data)
        observe(t, (:obs, i), Normal(loc, scale), data[i])
    end
end</code></pre><p>To learn an approximate posterior for <code>:loc</code> and <code>:scale</code>, we will introduce two proposal kernels:</p><pre><code class="language-none">loc_proposal(old_t :: Trace, new_t :: Trace, data) = propose(new_t, :loc, Normal(old_t[:loc].value, 0.25))
scale_proposal(old_t :: Trace, new_t :: Trace, data) = propose(new_t, :scale, truncated(Normal(old_t[:scale].value, 0.25), 0.0, Inf))</code></pre><p>Note that while <code>loc_proposal</code> is symmetric, <code>scale_proposal</code> is not. To perform inference, we pass these kernels to <code>mh_step</code> in  a loop after first drawing a random trace:</p><pre><code class="language-none">t = trace()
normal_model(t, data)
for i in 1:niter
    t = mh_step(t, normal_model, loc_proposal; params = (data,))
    t = mh_step(t, normal_model, scale_proposal; params = (data,))
end</code></pre><p>In this case, inference was fairly successful:</p><pre><code class="language-none">[ Info: True loc = 4.0
[ Info: True std = 1.0
[ Info: inferred E[loc] = 4.022688081613082
[ Info: inferred E[scale] = 0.9696559373495869
[ Info: approximate p(x) = sum_z p(x|z) = -138.63530736205144</code></pre><p>As a less trivial (but still contrived!) inference example, we can infer the posterior distribution of a latent discrete random variable in an open-universe model: </p><pre><code class="language-none">function random_sum_model(t :: Trace, data)
    n = sample(t, :n, Geometric(0.1))
    loc = 0.0
    for i in 1:(n + 1)
        loc += sample(t, (:loc, i), Normal())
    end
    obs = Array{Float64, 1}()
    for j in 1:length(data)
        o = observe(t, (:data, j), Normal(loc, 1.0), data[j])
        push!(obs, o)
    end
    obs
end</code></pre><p>(N.B.: we write the model is this form for pedagogic reasons; there is a far more efficient way to express the latent structure  of this model, namely <span>$n \sim \text{Geometric}(0.1)$</span>, <span>$\text{loc} \sim \text{Normal}(0, n)$</span>.) We are interested in learning the posterior distribution of <code>:n</code>. We introduce two proposal distributions, one for the latent discrete rv and another generic proposal for the location increments:</p><pre><code class="language-none">function random_n_proposal(old_trace, new_trace, params...)
    old_n = float(old_trace[:n].value)
    if old_n &gt; 0
        propose(new_trace, :n, Poisson(old_n))
    else
        propose(new_trace, :n, Poisson(1.0))
    end
end

gen_loc_proposal(old_trace, new_trace, ix, params...) = propose(new_trace, (:loc, ix), Normal(old_trace[(:loc, ix)].value, 0.25))</code></pre><p>We again conduct inference by simply applying proposals within a loop. This time, the number of location increment proposals we need to  construct is dependent on the sampled values of the latent random variable. We can either create these proposals on the fly as they&#39;re  needed or create what is nearly guaranteed to be enough of them before any inference is performed, e.g.,  <code>loc_proposals = [(o, n, params...) -&gt; gen_loc_proposal(o, n, i, params...) for i in 1:100]</code>. Now that we have what we need, we can conduct inference:</p><pre><code class="language-none">t = trace()
random_sum_model(t, data)
...
for i in 1:niter
    t = mh_step(t, random_sum_model, random_n_proposal; params=(data,))
    for j in 1:(t[:n].value + 1)
        t = mh_step(t, random_sum_model, loc_proposals[j]; params=(data,))
    end
    push!(ns, t[:n].value)
end</code></pre><p>Our inference results look promising:</p><pre><code class="language-none">[ Info: True :n = 9
[ Info: Posterior E[:n] = 7.581604598850287</code></pre><p>For more examples, check back soon.</p><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.accept-Tuple{Trace,Trace,Float64}" href="#CrimsonSkyline.accept-Tuple{Trace,Trace,Float64}"><code>CrimsonSkyline.accept</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function accept(t :: Trace, new_t :: Trace, log_a :: Float64)</code></pre><p>Stochastic function that either returns <code>new_t</code> if accepted or returns <code>t</code> if not accepted.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.copy_common!-Tuple{Trace,Trace}" href="#CrimsonSkyline.copy_common!-Tuple{Trace,Trace}"><code>CrimsonSkyline.copy_common!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function copy_common!(old_t :: Trace, new_t :: Trace)</code></pre><p>Copies nodes from <code>old_t</code> into <code>new_t</code> for all addresses in the intersection of their address sets. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.log_acceptance_ratio-Tuple{Trace,Trace,CrimsonSkyline.Prior}" href="#CrimsonSkyline.log_acceptance_ratio-Tuple{Trace,Trace,CrimsonSkyline.Prior}"><code>CrimsonSkyline.log_acceptance_ratio</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function log_acceptance_ratio(t :: Trace, t_proposed :: Trace, p :: Prior)</code></pre><p>Computes the log acceptance ratio of a Metropolis step when using the independent prior proposal  algorithm:</p><p><span>$\log \alpha = \ell(t_{\text{proposed}}) - \ell(t_{\text{original}})$</span></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.loglatent-Tuple{Trace}" href="#CrimsonSkyline.loglatent-Tuple{Trace}"><code>CrimsonSkyline.loglatent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function loglatent(t :: Trace)</code></pre><p>Computes the joint log probability of all latent variables in a trace, <span>$\log p(t) - \ell(t)$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.logprob-Tuple{Trace,Trace}" href="#CrimsonSkyline.logprob-Tuple{Trace,Trace}"><code>CrimsonSkyline.logprob</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function logprob(t0 :: Trace, t1 :: Trace)</code></pre><p>Computes the proposal log probability <span>$q(t_1 | t_0)$</span>.</p><p>This expression has two parts: log probability that is generated at the proposed site(s), and  log probability that is generated at the sites that are present in <code>t1</code> but not in <code>t0</code>. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.mh-Tuple{F} where F&lt;:Function" href="#CrimsonSkyline.mh-Tuple{F} where F&lt;:Function"><code>CrimsonSkyline.mh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function mh(f :: F; params = (), burn = 100, thin = 10, num_iterations = 10000) where F &lt;: Function</code></pre><p>Generic Metropolis algorithm using draws from the prior.</p><p>Args:</p><ul><li><code>f</code>: stochastic function. Must have call signature <code>f(t :: Trace, params...)</code></li><li><code>params</code>: addditional arguments to pass to <code>f</code> and each of the proposal kernels.</li><li><code>burn</code>: number of samples to discard at beginning of markov chain</li><li><code>thin</code>: keep only every <code>thin</code>-th draw. E.g., if <code>thin = 100</code>, only every 100-th trace will be kept.</li><li><code>num_iterations</code>: total number of steps to take in the markov chain</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.mh-Union{Tuple{A}, Tuple{F}, Tuple{F,A}} where A&lt;:AbstractArray where F&lt;:Function" href="#CrimsonSkyline.mh-Union{Tuple{A}, Tuple{F}, Tuple{F,A}} where A&lt;:AbstractArray where F&lt;:Function"><code>CrimsonSkyline.mh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function mh(f :: F, qs :: A; params = (), burn = 100, thin = 10, num_iterations = 10000, inverse_verbosity = 100) where {F &lt;: Function, A &lt;: AbstractArray}</code></pre><p>Generic Metropolis algorithm using user-defined proposal kernels.</p><p>Args:</p><ul><li><code>f</code>: stochastic function. Must have call signature <code>f(t :: Trace, params...)</code></li><li><code>qs</code>: array-like of proposal kernels. Proposal kernels are applied sequentially in the order that they appear in this array.   Proposal kernels must have the signature <code>q(old_t :: Trace, new_t :: Trace, params...)</code> where it must take in at least the same number of arguments   in <code>params</code> as <code>f</code>.</li><li><code>params</code>: addditional arguments to pass to <code>f</code> and each of the proposal kernels.</li><li><code>burn</code>: number of samples to discard at beginning of markov chain</li><li><code>thin</code>: keep only every <code>thin</code>-th draw. E.g., if <code>thin = 100</code>, only every 100-th trace will be kept.</li><li><code>num_iterations</code>: total number of steps to take in the markov chain</li><li><code>inverse_verbosity</code>: every <code>inverse_verbosity</code> iterations, a stattus report will be logged.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.mh_step-Union{Tuple{F2}, Tuple{F1}, Tuple{Trace,F1,F2}} where F2&lt;:Function where F1&lt;:Function" href="#CrimsonSkyline.mh_step-Union{Tuple{F2}, Tuple{F1}, Tuple{Trace,F1,F2}} where F2&lt;:Function where F1&lt;:Function"><code>CrimsonSkyline.mh_step</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function mh_step(t :: Trace, f :: F1, q :: F2; params = ()) where {F1 &lt;: Function, F2 &lt;: Function}</code></pre><p>A generic Metropolis step using an arbitrary proposal kernel. </p><p>Given a trace <code>t</code>, a stochastic function <code>f</code> with signature <code>f(t :: Trace, params...)</code> a stochastic function  <code>q</code> with signature <code>q(old_trace :: Trace, new_trace :: Trace, params...)</code>, generates a proposal from <code>q</code> and  accepts based on the log acceptance probability:</p><p><span>$\log \alpha = \log p(t_{\text{new}}) - \log q(t_{\text{new}}|t_{\text{old}}) - [\log p(t_{\text{old}}) - \log q(t_{\text{old}} | t_{\text{new}})].$</span></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.mh_step-Union{Tuple{F}, Tuple{Trace,F}} where F&lt;:Function" href="#CrimsonSkyline.mh_step-Union{Tuple{F}, Tuple{Trace,F}} where F&lt;:Function"><code>CrimsonSkyline.mh_step</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function mh_step(t :: Trace, f :: F; params = ()) where F &lt;: Function</code></pre><p>An independent prior sample Metropolis step.</p><p>Given a trace <code>t</code> and stochatic function <code>f</code> depending on <code>params...</code>, generates proposals  from prior draws and accepts based on the likelihood ratio.</p></div></section></article><h2 id="results"><a class="docs-heading-anchor" href="#results">results</a><a id="results-1"></a><a class="docs-heading-anchor-permalink" href="#results" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.SamplingResults" href="#CrimsonSkyline.SamplingResults"><code>CrimsonSkyline.SamplingResults</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct SamplingResults{I&lt;:InferenceType}
    interpretation :: I
    log_weights :: Array{Float64, 1}
    return_values :: Array{Any, 1}
    traces :: Array{Trace, 1}
end</code></pre><p>Wrapper for results of sampling. Implements the following methods  from <code>Base</code>: <code>getindex</code>, <code>length</code>, <code>keys</code>. Intepretation of log weights is dependent on <code>I</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.aic-Union{Tuple{SamplingResults{I}}, Tuple{I}} where I&lt;:CrimsonSkyline.InferenceType" href="#CrimsonSkyline.aic-Union{Tuple{SamplingResults{I}}, Tuple{I}} where I&lt;:CrimsonSkyline.InferenceType"><code>CrimsonSkyline.aic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function aic(r :: SamplingResults{I}) where I &lt;: InferenceType</code></pre><p>Computes an empirical estimate of the Akaike Information Criterion from a <code>SamplingResults</code>. The formula is </p><p class="math-container">\[\text{AIC}(r)/2 = \min_{t \in \text{traces}(r)}|\text{params}(t)| - \hat\ell(t),\]</p><p>where <span>$|\text{params}(t)|$</span> is the number of non-observed and non-deterministic sample nodes and <span>$\hat\ell(t)$</span> is the empirical maximum likelihood.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.sample-Union{Tuple{I}, Tuple{Trace,Any,SamplingResults{I}}} where I&lt;:CrimsonSkyline.InferenceType" href="#CrimsonSkyline.sample-Union{Tuple{I}, Tuple{Trace,Any,SamplingResults{I}}} where I&lt;:CrimsonSkyline.InferenceType"><code>CrimsonSkyline.sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function sample(t :: Trace, a, r :: SamplingResults{I}; pa = ()) where I &lt;: InferenceType</code></pre><p><strong>EXPERIMENTAL</strong>: treat a marginal site of a <code>SamplingResults</code> as a distribution, sampling from it into a trace using nonstandard interpretation.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Distributions.logpdf-Union{Tuple{A}, Tuple{A,Any}} where A&lt;:AbstractArray" href="#Distributions.logpdf-Union{Tuple{A}, Tuple{A,Any}} where A&lt;:AbstractArray"><code>Distributions.logpdf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function Distributions.logpdf(r :: A, v) where A &lt;: AbstractArray</code></pre><p>Interprets an array of objects as a delta distribution over those objects. If <code>v</code> is in the support set,  returns <span>$-log |r|$</span>. Otherwise, returns <span>$-\infty$</span>. </p></div></section></article><h2 id="fusion"><a class="docs-heading-anchor" href="#fusion">fusion</a><a id="fusion-1"></a><a class="docs-heading-anchor-permalink" href="#fusion" title="Permalink"></a></h2><p>Methods to perform semi-analytical simplification and inference. </p><h3 id="fusion/distributions"><a class="docs-heading-anchor" href="#fusion/distributions">fusion/distributions</a><a id="fusion/distributions-1"></a><a class="docs-heading-anchor-permalink" href="#fusion/distributions" title="Permalink"></a></h3><p>A collection of distributions that aren&#39;t in <code>Distributions.jl</code>. These distributions are useful in their own right, but are  also arise when fusing pairs or triples of known distributions.</p><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.CSDistribution" href="#CrimsonSkyline.CSDistribution"><code>CrimsonSkyline.CSDistribution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type CSDistribution{D} end</code></pre><p>Abstract type from which all CrimsonSkyline distributions subtype. All subtypes implement the following methods from <code>Distributions.jl</code>:  <code>rand</code> and <code>logpdf</code>. Unless otherwise specified, these subtypes do <em>not</em>  implement <code>logpdf.</code>, which may change in the future.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.Lomax" href="#CrimsonSkyline.Lomax"><code>CrimsonSkyline.Lomax</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Lomax{D} &lt;: CSDistribution{D}
    α :: D
    θ :: D 
    γ :: Gamma{D}
end</code></pre><p>A Lomax distribution, which is a power-law distribution supported on <span>$[0, \infty)$</span>. It has the pdf </p><p><span>$p(x | \alpha,\ \theta) = -(\alpha + 1) [ \log(\alpha \theta) + \log(1 + x \theta) ].$</span></p><p>Sampling from this distribution is accomplished via a gamma - exponential mixture.  A value <span>$g \sim \text{Gamma}(\alpha,\ \theta)$</span> is drawn, and then  the value <span>$e \sim \text{Exponential}(g)$</span> is returned. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="CrimsonSkyline.Lomax-Union{Tuple{D}, Tuple{D,D}} where D&lt;:Real" href="#CrimsonSkyline.Lomax-Union{Tuple{D}, Tuple{D,D}} where D&lt;:Real"><code>CrimsonSkyline.Lomax</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function Lomax(α :: D, θ :: D) where D &lt;: Real</code></pre><p>Outer constructor for Lomax struct.</p></div></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#CrimsonSkyline.CPT"><code>CrimsonSkyline.CPT</code></a></li><li><a href="#CrimsonSkyline.CSDistribution"><code>CrimsonSkyline.CSDistribution</code></a></li><li><a href="#CrimsonSkyline.Factor"><code>CrimsonSkyline.Factor</code></a></li><li><a href="#CrimsonSkyline.GraphIR"><code>CrimsonSkyline.GraphIR</code></a></li><li><a href="#CrimsonSkyline.Lomax"><code>CrimsonSkyline.Lomax</code></a></li><li><a href="#CrimsonSkyline.Lomax-Union{Tuple{D}, Tuple{D,D}} where D&lt;:Real"><code>CrimsonSkyline.Lomax</code></a></li><li><a href="#CrimsonSkyline.Node"><code>CrimsonSkyline.Node</code></a></li><li><a href="#CrimsonSkyline.SamplingResults"><code>CrimsonSkyline.SamplingResults</code></a></li><li><a href="#CrimsonSkyline.Trace"><code>CrimsonSkyline.Trace</code></a></li><li><a href="#CrimsonSkyline.accept-Tuple{Trace,Trace,Float64}"><code>CrimsonSkyline.accept</code></a></li><li><a href="#CrimsonSkyline.aic-Tuple{Trace}"><code>CrimsonSkyline.aic</code></a></li><li><a href="#CrimsonSkyline.aic-Union{Tuple{SamplingResults{I}}, Tuple{I}} where I&lt;:CrimsonSkyline.InferenceType"><code>CrimsonSkyline.aic</code></a></li><li><a href="#CrimsonSkyline.block-Union{Tuple{F}, Tuple{F,Trace}} where F&lt;:Function"><code>CrimsonSkyline.block</code></a></li><li><a href="#CrimsonSkyline.block-Union{Tuple{F}, Tuple{F,Trace,Any}} where F&lt;:Function"><code>CrimsonSkyline.block</code></a></li><li><a href="#CrimsonSkyline.condition-Union{Tuple{F}, Tuple{F,Dict}} where F&lt;:Function"><code>CrimsonSkyline.condition</code></a></li><li><a href="#CrimsonSkyline.connect_pa_ch!-Tuple{Trace,Any,Any}"><code>CrimsonSkyline.connect_pa_ch!</code></a></li><li><a href="#CrimsonSkyline.copy_common!-Tuple{Trace,Trace}"><code>CrimsonSkyline.copy_common!</code></a></li><li><a href="#CrimsonSkyline.cpt-Tuple{L} where L&lt;:AbstractDict"><code>CrimsonSkyline.cpt</code></a></li><li><a href="#CrimsonSkyline.factor-Tuple{GraphIR}"><code>CrimsonSkyline.factor</code></a></li><li><a href="#CrimsonSkyline.factor-Tuple{Trace}"><code>CrimsonSkyline.factor</code></a></li><li><a href="#CrimsonSkyline.graph_ir-Tuple{Trace}"><code>CrimsonSkyline.graph_ir</code></a></li><li><a href="#CrimsonSkyline.importance_sampling-Union{Tuple{F2}, Tuple{F1}, Tuple{F1,F2}} where F2&lt;:Function where F1&lt;:Function"><code>CrimsonSkyline.importance_sampling</code></a></li><li><a href="#CrimsonSkyline.interpret_latent!-Tuple{Trace,CrimsonSkyline.Interpretation}"><code>CrimsonSkyline.interpret_latent!</code></a></li><li><a href="#CrimsonSkyline.is_step-Union{Tuple{F2}, Tuple{F1}, Tuple{F1,F2}} where F2&lt;:Function where F1&lt;:Function"><code>CrimsonSkyline.is_step</code></a></li><li><a href="#CrimsonSkyline.likelihood_weighting-Union{Tuple{F}, Tuple{F,Vararg{Any,N} where N}} where F&lt;:Function"><code>CrimsonSkyline.likelihood_weighting</code></a></li><li><a href="#CrimsonSkyline.likelihood_weighting_results-Tuple{}"><code>CrimsonSkyline.likelihood_weighting_results</code></a></li><li><a href="#CrimsonSkyline.load-Tuple{Any}"><code>CrimsonSkyline.load</code></a></li><li><a href="#CrimsonSkyline.log_acceptance_ratio-Tuple{Trace,Trace,CrimsonSkyline.Prior}"><code>CrimsonSkyline.log_acceptance_ratio</code></a></li><li><a href="#CrimsonSkyline.log_evidence-Union{Tuple{SamplingResults{I}}, Tuple{I}} where I&lt;:CrimsonSkyline.Importance"><code>CrimsonSkyline.log_evidence</code></a></li><li><a href="#CrimsonSkyline.loglatent-Tuple{Trace}"><code>CrimsonSkyline.loglatent</code></a></li><li><a href="#CrimsonSkyline.loglikelihood-Tuple{Trace}"><code>CrimsonSkyline.loglikelihood</code></a></li><li><a href="#CrimsonSkyline.logprob-Tuple{Trace,Trace}"><code>CrimsonSkyline.logprob</code></a></li><li><a href="#CrimsonSkyline.logprob-Tuple{Trace}"><code>CrimsonSkyline.logprob</code></a></li><li><a href="#CrimsonSkyline.logprob!-Tuple{Trace}"><code>CrimsonSkyline.logprob!</code></a></li><li><a href="#CrimsonSkyline.lw_step-Union{Tuple{F}, Tuple{F,Vararg{Any,N} where N}} where F&lt;:Function"><code>CrimsonSkyline.lw_step</code></a></li><li><a href="#CrimsonSkyline.mh-Union{Tuple{A}, Tuple{F}, Tuple{F,A}} where A&lt;:AbstractArray where F&lt;:Function"><code>CrimsonSkyline.mh</code></a></li><li><a href="#CrimsonSkyline.mh-Tuple{F} where F&lt;:Function"><code>CrimsonSkyline.mh</code></a></li><li><a href="#CrimsonSkyline.mh_step-Union{Tuple{F2}, Tuple{F1}, Tuple{Trace,F1,F2}} where F2&lt;:Function where F1&lt;:Function"><code>CrimsonSkyline.mh_step</code></a></li><li><a href="#CrimsonSkyline.mh_step-Union{Tuple{F}, Tuple{Trace,F}} where F&lt;:Function"><code>CrimsonSkyline.mh_step</code></a></li><li><a href="#CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{DataType,A,D,Bool,CrimsonSkyline.Interpretation}} where D where A"><code>CrimsonSkyline.node</code></a></li><li><a href="#CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{Any,A,D,Bool,CrimsonSkyline.Interpretation}} where D where A"><code>CrimsonSkyline.node</code></a></li><li><a href="#CrimsonSkyline.node_info-Tuple{Trace,Any}"><code>CrimsonSkyline.node_info</code></a></li><li><a href="#CrimsonSkyline.normalized_weights-Union{Tuple{SamplingResults{I}}, Tuple{I}} where I&lt;:CrimsonSkyline.Importance"><code>CrimsonSkyline.normalized_weights</code></a></li><li><a href="#CrimsonSkyline.observe-Tuple{Trace,Any,Any,Any}"><code>CrimsonSkyline.observe</code></a></li><li><a href="#CrimsonSkyline.pa_from_trace-Tuple{Trace,Any}"><code>CrimsonSkyline.pa_from_trace</code></a></li><li><a href="#CrimsonSkyline.prior-Union{Tuple{F}, Tuple{F,Union{Tuple, AbstractArray},Vararg{Any,N} where N}} where F&lt;:Function"><code>CrimsonSkyline.prior</code></a></li><li><a href="#CrimsonSkyline.propose-Tuple{Trace,Any,Any}"><code>CrimsonSkyline.propose</code></a></li><li><a href="#CrimsonSkyline.renormalize!-Tuple{CPT}"><code>CrimsonSkyline.renormalize!</code></a></li><li><a href="#CrimsonSkyline.replace-Tuple{Trace,Dict}"><code>CrimsonSkyline.replace</code></a></li><li><a href="#CrimsonSkyline.replace-Union{Tuple{F}, Tuple{F,Dict}} where F&lt;:Function"><code>CrimsonSkyline.replace</code></a></li><li><a href="#CrimsonSkyline.replay-Union{Tuple{F}, Tuple{F,Trace}} where F&lt;:Function"><code>CrimsonSkyline.replay</code></a></li><li><a href="#CrimsonSkyline.rewrite-Union{Tuple{F}, Tuple{F,Trace,Dict}} where F&lt;:Function"><code>CrimsonSkyline.rewrite</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any,CrimsonSkyline.Blocked}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any,Replayed}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any,Deterministic}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any,Standard}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Array{CrimsonSkyline.Interpretation,1}}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Union{Tuple{I}, Tuple{Trace,Any,SamplingResults{I}}} where I&lt;:CrimsonSkyline.InferenceType"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Standard}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Nonstandard}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Union{Tuple{I}, Tuple{SamplingResults{I},Any,Int64}} where I&lt;:CrimsonSkyline.Importance"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any,Array{CrimsonSkyline.Interpretation,1}}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any,Nonstandard}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any,CrimsonSkyline.Blocked}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Replayed}"><code>CrimsonSkyline.sample</code></a></li><li><a href="#CrimsonSkyline.save-Tuple{Trace,Any}"><code>CrimsonSkyline.save</code></a></li><li><a href="#CrimsonSkyline.to_table-Tuple{Trace}"><code>CrimsonSkyline.to_table</code></a></li><li><a href="#CrimsonSkyline.trace-Tuple{}"><code>CrimsonSkyline.trace</code></a></li><li><a href="#CrimsonSkyline.transform-Union{Tuple{F}, Tuple{Trace,Any,F,Any}} where F&lt;:Function"><code>CrimsonSkyline.transform</code></a></li><li><a href="#CrimsonSkyline.update-Union{Tuple{I}, Tuple{F}, Tuple{F,SamplingResults{I}}} where I&lt;:CrimsonSkyline.InferenceType where F&lt;:Function"><code>CrimsonSkyline.update</code></a></li><li><a href="#Distributions.logpdf-Union{Tuple{A}, Tuple{A,Any}} where A&lt;:AbstractArray"><code>Distributions.logpdf</code></a></li></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 25 April 2021 10:28">Sunday 25 April 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
