var documenterSearchIndex = {"docs":
[{"location":"#CrimsonSkyline.jl","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"","category":"section"},{"location":"#trace","page":"CrimsonSkyline.jl","title":"trace","text":"","category":"section"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"To a large extent, Nodes have local control over the behavior of inference algorithms via their  interpretation. There are a variety of Interpretations. The type hierarchy is flat:","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"abstract type Interpretation end\nstruct Nonstandard <: Interpretation end\nstruct Standard <: Interpretation end\nstruct Replayed <: Interpretation end\nstruct Conditioned <: Interpretation end \nstruct Blocked <: Interpretation end\nstruct Deterministic <: Interpretation end\nstruct Proposed <: Interpretation end","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Modules = [CrimsonSkyline]\nPages = [\"trace.jl\"]","category":"page"},{"location":"#CrimsonSkyline.ParametricNode","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.ParametricNode","text":"mutable struct ParametricNode{A, D, T} <: Node\n    address :: A\n    dist :: D\n    value :: Maybe{T}\n    logprob :: Float64\n    logprob_sum :: Float64\n    observed :: Bool\n    pa :: Array{Node, 1}\n    ch :: Array{Node, 1}\n    interpretation :: Union{Interpretation, Vector{Interpretation}}\n    last_interpretation :: Union{Interpretation, Vector{Interpretation}}\nend\n\nA Node that can be used with arbitrary code for which rand and Distributionss.logpdf are defined.\n\n\n\n\n\n","category":"type"},{"location":"#CrimsonSkyline.SampleableNode","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.SampleableNode","text":"mutable struct SampleableNode{A, T} <: Node\n    address :: A\n    dist :: Sampleable\n    value :: Maybe{T}\n    logprob :: Float64\n    logprob_sum :: Float64\n    observed :: Bool\n    pa :: Array{Node, 1}\n    ch :: Array{Node, 1}\n    interpretation :: Union{Interpretation, Vector{Interpretation}}\n    last_interpretation :: Union{Interpretation, Vector{Interpretation}}\nend\n\nA Node that is restricted to be used with any Sampleable from Distributions.jl.\n\n\n\n\n\n","category":"type"},{"location":"#CrimsonSkyline.Trace","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.Trace","text":"abstract type Trace end\n\nBase type for all traces. Traces support the following Base methods: setindex!, getindex, keys, values, and length.\n\n\n\n\n\n","category":"type"},{"location":"#CrimsonSkyline.TypedTrace","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.TypedTrace","text":"mutable struct TypedTrace{A, T} <: Trace\n    trace :: OrderedDict{A, SampleableNode{A, T}}\n    logprob_sum :: Float64\nend\n\nTrace that can hold nodes of the specific address (A) and value (T) types.\n\n\n\n\n\n","category":"type"},{"location":"#CrimsonSkyline.UntypedTrace","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.UntypedTrace","text":"mutable struct UntypedTrace\n    trace :: OrderedDict{Any, Node}\n    logprob_sum :: Float64\nend\n\nTrace that can hold nodes with all address and value types. \n\n\n\n\n\n","category":"type"},{"location":"#CrimsonSkyline.aic-Tuple{Trace}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.aic","text":"function aic(t :: Trace)\n\nComputes the Akaike Information Criterion for a single trace (thus replacing the definition) with  \"maximum likelihood\" by one with \"likelihood\". The formula is \n\ntextAIC(t)2 = textparams(t) - ell(t)\n\nwhere textparams(t) is the number of non-observed and non-deterministic sample nodes.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.connect_pa_ch!-Tuple{Trace, Any, Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.connect_pa_ch!","text":"function connect_pa_ch!(t :: Trace, pa, a)\n\nConnects parent and child nodes. Adds child nodes to parent's ch and  parent nodes to child's pa.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.input-Tuple{Trace, Any, Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.input","text":"input(t :: Trace, a, d)\n\nTrack a model input. Used only in graph intermediate representation and factor  graph.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.interpret_latent!-Tuple{Trace, CrimsonSkyline.Interpretation}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.interpret_latent!","text":"function interpret_latent!(t :: Trace, i :: Interpretation)\n\nChanges the interpretation of all latent nodes in t to have interpretation == i\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.loglikelihood-Tuple{Trace}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.loglikelihood","text":"function loglikelihood(t :: Trace)\n\nComputes and returns the log likelihood of the observed data under the model:\n\nell(t) = \nsum_a a in textkeys(t) wedge textinterpretation(a) = textStandard \nlog p(ta)\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.logprob!-Tuple{Trace}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.logprob!","text":"function logprob!(t :: Trace)\n\nComputes the joint log probability to the trace and assigns it to t.logprob_sum.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.logprob-Tuple{Trace}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.logprob","text":"function logprob(t :: Trace)\n\nComputes and returns the joint log probability of the trace:\n\nlog p(t) = sum_a in textkeys(t)log p(ta)\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{Any, A, D, Bool, CrimsonSkyline.Interpretation}} where {A, D<:Distributions.Sampleable}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.node","text":"function node(value, address :: A, dist :: D, is_obs :: Bool, i :: Interpretation) where {A, D}\n\nOuter constructor for Node where data is passed during construction. Data type is inferred from the passed data.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{Any, A, D, Bool, CrimsonSkyline.Interpretation}} where {A, D}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.node","text":"function node(value, address :: A, dist :: D, is_obs :: Bool, i :: Interpretation) where {A, D}\n\nOuter constructor for Node where data is passed during construction. Data type is inferred from the passed data.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{DataType, A, D, Bool, CrimsonSkyline.Interpretation}} where {A, D<:Distributions.Sampleable}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.node","text":"function node(T :: DataType, address :: A, dist :: D, is_obs :: Bool, i :: Interpretation) where {A, D}\n\nOuter constructor for Node where no data is passed during construction. \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{DataType, A, D, Bool, CrimsonSkyline.Interpretation}} where {A, D}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.node","text":"function node(T :: DataType, address :: A, dist :: D, is_obs :: Bool, i :: Interpretation) where {A, D}\n\nOuter constructor for Node where no data is passed during construction. \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.observe-Tuple{Trace, Any, Any, Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.observe","text":"function observe(t :: Trace, a, d, s; pa = ())\n\nIf d is not nothing an alias for calling sample with standard interpretation.  Otherwise, an alias for calling sample with nonstandard interpretation. \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.pa_from_trace-Tuple{Trace, Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.pa_from_trace","text":"function pa_from_trace(t :: Trace, pa)\n\nCollects nodes in trace corresponding to an iterable of parent addresses pa.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.plate-Union{Tuple{F}, Tuple{Trace, F, Any, Any, Int64, Conditioned}} where F<:Function","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.plate","text":"function plate(t::Trace, op::F, a, d, s::Int64, i::Conditioned; pa = ()) where F<:Function\n\nPlate over conditioned variables.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.plate-Union{Tuple{F}, Tuple{Trace, F, Any, Any, Int64, CrimsonSkyline.Blocked}} where F<:Function","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.plate","text":"function plate(t::Trace, op::F, a, d, s::Int64, i::Blocked; pa = ()) where F<:Function\n\nPlate over blocked variables.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.plate-Union{Tuple{F}, Tuple{Trace, F, Any, Any, Int64, Nonstandard}} where F<:Function","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.plate","text":"function plate(t::Trace, op::F, a, d, s::Int64, i::Nonstandard; pa = ()) where F<:Function\n\nPlate over latent variables.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.plate-Union{Tuple{F}, Tuple{Trace, F, Any, Any, Int64, Replayed}} where F<:Function","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.plate","text":"function plate(t::Trace, op::F, a, d, s::Int64, i::Replayed; pa = ()) where F<:Function\n\nPlate over replayed variables. Note that this method assumes and does not check that the value to be replayed v satisfies length(v) == s.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.plate-Union{Tuple{F}, Tuple{Trace, F, Any, Any, Int64}} where F<:Function","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.plate","text":"function plate(t::Trace, op::F, a, d, s::Int64; pa = ()) where F<:Function\n\nSample or observe a vector of random variables at a single site instead of multiple. This can speed up inference since the number of sites in the model will no longer scale with dataset size (though numerical value computation is still linear in dataset size).\n\nExample usage: instead of\n\nvals = [sample(t, \"val $i\", Geometric()) for _ in 1:N]\n\nwe can write \n\nvals = plate(t, sample, \"val\", Geometric(), N)\n\nMathematically, this is equivalent to the product p(z) = prod_n p(z_n) and treating it as the single object p(z) instead of the N objects p(z_n).\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.plate-Union{Tuple{F}, Tuple{T}, Tuple{Trace, F, Any, Any, Vector{T}}} where {T, F<:Function}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.plate","text":"function plate(t::Trace, op::F, a, d, v::Vector{T}; pa = ()) where {T, F<:Function}\n\nPlate over observed variables, i.e., a plated component of model likelihood. v is the  vector of observations, while op is likely observe.\n\nExample usage: instead of\n\nfor (i, d) in enumerate(data)\n    observe(t, \"data $i\", Normal(loc, scale), d)\nend\n\nwe can write \n\nplate(t, observe, \"data\", Normal(loc, scale), data)\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.prior-Union{Tuple{F}, Tuple{F, Union{Tuple, AbstractArray}, Vararg{Any, N} where N}} where F<:Function","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.prior","text":"function prior(f :: F, addresses :: Union{AbstractArray, Tuple}, params...; nsamples :: Int = 1) where F <: Function\n\nGiven a generative function f, an array-like of addresses, and a collection of parameters to pass to f, runs nsamples evaluations of the f, collecting the values from the addresses and returning a Dict mapping addresses to values. \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.propose-Tuple{Trace, Any, Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.propose","text":"propose(t :: Trace, a, d)\n\nPropose a value for the address a in trace t from the distribution d.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, CrimsonSkyline.Blocked}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(t :: Trace, a, d, params, i :: Blocked; pa = ())\n\nSamples from d passing the optional arguments params, deletes the node stored at address a from trace t, and returns the sampled value. \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, Deterministic}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(t :: Trace, a, f, v, i :: Deterministic; pa = ())\n\nCreates a deterministic node mapping the tuple of data v through function f,  storing the value in trace t at address a.\n\nInfers input type from v\nMaps tuple of data v through function f, yielding r = f(v...)\nCreates a deterministic node and stores it in t at address a\nOptionally adds nodes corresponding to the addresses in pa as parent nodes\nReturns r\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, Nonstandard}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(t :: Trace, a, d, params, i :: Nonstandard; pa = ())\n\nSamples from distribution d into trace t at address a.\n\nSamples a value from d passing the optional arguments params\nCreates a sample node\nAdds the sample node to trace t at value a\nOptionally adds nodes corresponding to the addresses in pa as parent nodes\nReturns the sampled value\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, Replayed}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(t :: Trace, a, d, params, i :: Replayed; pa = ())\n\nReplays the sampled node through the trace. \n\nIf a is not in t's address set, calls sample(t, a, d, NONSTANDARD; pa = pa). \nCreates a sample node that copies the value from the last node stored in the trace at address a. \nAdds the sample node to trace t at value a\nOptionally adds nodes corresponding to the addresses in pa as parent nodes\nResets the node's interpretation to the original interpretation\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, Standard}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(t :: Trace, a, d, s, i :: Standard; pa = ())\n\nScores an observed value s against the distribution d, storing the value in trace t at  address a and optionally adds nodes corresponding to the addresses in pa as parent nodes.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, Vector{CrimsonSkyline.Interpretation}}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(t :: Trace, a, d, params, ii :: Array{Interpretation, 1}; pa = ())\n\nSequentially apply sample statements with interpretations as given in ii. This is  used to depth-first traverse the interpretation graph.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(t :: Trace, a, d, params; pa = ())\n\nIf a is in the set of trace addresses, calls sample using t[a]'s interpretation.  Otherwise, calls sample using nonstandard interpretation. \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Tuple{Trace, Any, Any, CrimsonSkyline.Blocked}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(t :: Trace, a, d, i :: Blocked; pa = ())\n\nSamples from d, deletes the node stored at address a from trace t, and returns the  sampled value. \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Nonstandard}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(t :: Trace, a, d, i :: Nonstandard; pa = ())\n\nSamples from distribution d into trace t at address a.\n\nSamples a value from d\nCreates a sample node\nAdds the sample node to trace t at value a\nOptionally adds nodes corresponding to the addresses in pa as parent nodes\nReturns the sampled value\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Replayed}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(t :: Trace, a, d, i :: Replayed; pa = ())\n\nReplays the sampled node through the trace. \n\nIf a is not in t's address set, calls sample(t, a, d, NONSTANDARD; pa = pa). \nCreates a sample node that copies the value from the last node stored in the trace at address a. \nAdds the sample node to trace t at value a\nOptionally adds nodes corresponding to the addresses in pa as parent nodes\nResets the node's interpretation to the original interpretation\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Union{Conditioned, Standard}}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(t :: Trace, a, d, i :: Union{Standard,Conditioned}; pa = ())\n\nScores an observed value against the distribution d, storing the value in trace t at  address a and optionally adds nodes corresponding to the addresses in pa as parent nodes.\n\nThis method is used by the condition effect. It will probably not be used by most  users.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Vector{CrimsonSkyline.Interpretation}}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(t :: Trace, a, d, ii :: Array{Interpretation, 1}; pa = ())\n\nSequentially apply sample statements with interpretations as given in ii. This is  used to depth-first traverse the interpretation graph.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Tuple{Trace, Any, Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(t :: Trace, a, d; pa = ())\n\nIf a is in the set of trace addresses, calls sample using t[a]'s interpretation.  Otherwise, calls sample using nonstandard interpretation. \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.trace-Tuple{Any, Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.trace","text":"trace(A, T)\n\nThis is the recommended way to construct a new typed trace. A is the address type, T is the value type.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.trace-Tuple{}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.trace","text":"trace()\n\nThis is the recommended way to construct a new trace.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.transform-Union{Tuple{F}, Tuple{Trace, Any, F, Any}} where F<:Function","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.transform","text":"function transform(t :: Trace, a, f :: F, v; pa = ()) where F <: Function\n\nAlias for sample(t, a, f, v, DETERMINISTIC; pa = pa).\n\n\n\n\n\n","category":"method"},{"location":"#io","page":"CrimsonSkyline.jl","title":"io","text":"","category":"section"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Saving and loading traces and SamplingResults is possible using the save and load functions. This functionality depends on JuliaDB. ","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Examples: ","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"# simple example model\nfunction io_model(t::Trace, dim::Int64, data::Int64)\n    z = sample(t, \"z\", Dirichlet(ones(dim)))\n    observe(t, \"x\", Categorical(z), data)\nend\n\n# saving a trace\nt = trace()\ndim = 10\ndata = 7\nio_model(t, dim, data)\ntestpath = joinpath(@__DIR__, \"TESTIO\")\ndb_file = joinpath(testpath, \"test.jdb\")\nsave(t, db_file)\n\n# loading a trace\nloaded_trace = load(db_file)\n\n# creating and saving some results\nresults = mh(io_model; params = (dim, data), burn = 0, thin = 1, num_iterations=10)\nresults_file = joinpath(testpath, \"io_model.csm\")\nsave(results, results_file)\n\n# loading saved results and use to serve model\nloaded_results = load(joinpath(testpath, \"io_model.csm\"))\nupdated_model = update(io_model, loaded_results)  # update effect, see effects.jl\nnew_t, _ = updated_model(trace(), dim, data)","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Modules = [CrimsonSkyline]\nPages = [\"io.jl\"]","category":"page"},{"location":"#CrimsonSkyline.load-Tuple{Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.load","text":"function load(f)\n\nLoad a Trace or SamplingResults object from file. The file must be saved in JuliaDB format with ending .jdb, which will be interpreted as a single saved trace, or must be a directory with ending .csm, which will be interpreted as a SamplingResults object.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.load_csm-Tuple{Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.load_csm","text":"function load_csm(f) :: SamplingResults\n\nLoads a SamplingResults from a directory. The directory contains metadata.txt, which currently stores the interpretation of the SamplingResults (i.e., what kind of  algorithm generated those results), and a file results.jdb, which is a JuliaDB table of the results.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.load_jdb-Tuple{Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.load_jdb","text":"function load_jdb(f) :: Trace\n\nLoads a serialized juliadb table from file f and converts it into a trace.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.save-Tuple{CrimsonSkyline.SamplingResults, Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.save","text":"function save(r :: SamplingResults, f)\n\nSaves a SamplingResults to disk in the directory f.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.save-Tuple{Trace, Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.save","text":"function save(t :: Trace, f)\n\nSaves a trace to disk at the filepath f.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.to_table-Tuple{Trace}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.to_table","text":"function to_table(t :: Trace)\n\nTurns a trace into a juliadb table. Does not store parent / child relationships.\n\n\n\n\n\n","category":"method"},{"location":"#effects","page":"CrimsonSkyline.jl","title":"effects","text":"","category":"section"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"A library of functions that change the interpretation of some or all nodes in a trace.","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Modules = [CrimsonSkyline]\nPages = [\"effects.jl\"]","category":"page"},{"location":"#CrimsonSkyline.block-Union{Tuple{F}, Tuple{F, Trace}} where F<:Function","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.block","text":"block(f :: F, t :: Trace) where F <: Function\n\nConverts all traced randomness into untraced randomness.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.block-Union{Tuple{T}, Tuple{F}, Tuple{F, T, Any}} where {F<:Function, T<:Trace}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.block","text":"function block(f :: F, t :: Trace, addresses) where F <: Function\n\nGiven a stochastic function f, a trace t, and an iterable of addresses, converts traced randomness into untraced randomness. \n\nReturns a tuple (t_new, g), where t_new is a trace and g is a function. The function signature of g is the same as that of f with the first argument removed; that is, if f(t :: Trace, params...), then g(params...). Computation is delayed, so each of  the latent nodes in t_new has interpretation = BLOCKED. Calling g(params...) executes the  computation and each latent node in t_new with an address in addresses is removed.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.condition-Union{Tuple{F}, Tuple{F, Dict}} where F<:Function","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.condition","text":"function condition(f :: F, evidence :: Dict) where F <: Function\n\nCondition a trace modified by f on evidence, which maps addresses to observed  evidence associated with that address. Returns a function with call signature  identical to that of f and return signature (t :: Trace, rtype) where rtype is the return type of f.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.replace-Union{Tuple{F}, Tuple{F, Dict}} where F<:Function","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.replace","text":"function replace(f :: F, r :: Dict) where F <: Function\n\nGiven a mapping r from addresses to distribution-like (currently Distributions or Array{Any, 1}s), replaces the current distributions at that set of addresses with this set of distributions. Returns a function g that has return signature  (t :: Trace, rval) where rval is a return value of f.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.replace-Union{Tuple{T}, Tuple{T, Dict}} where T<:Trace","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.replace","text":"function replace(t :: Trace, r :: Dict)\n\nGiven a mapping r from addresses to distribution-like (currently Distributions or Array{Any, 1}s), replaces the current distributions at that set of addresses with this set of distributions. Returns the modified trace.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.replay-Union{Tuple{T}, Tuple{F}, Tuple{F, T}} where {F<:Function, T<:Trace}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.replay","text":"function replay(f :: F, t :: T) where {F <: Function, T <: Trace}\n\nGiven a stochastic function f and a trace t, makes sample calls behave as though  they had sampled the values in t at the corresponding addresses. \n\nReturns a tuple (t_new, g), where t_new is a trace and g is a function. The function signature of g is the same as that of f with the first argument removed; that is, if f(t :: Trace, params...), then g(params...). Computation is delayed, so each of the latent nodes in t_new has interpretation = REPLAYED. Calling g(params...) executes the computation and each latent node in t_new reverts to  its original interpretation. \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.rewrite-Union{Tuple{T}, Tuple{F}, Tuple{F, T, Dict}} where {F<:Function, T<:Trace}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.rewrite","text":"function rewrite(f :: F, t :: Trace, r :: Dict) where F <: Function\n\nRewrites the history of the trace to make it appear as if the values in the trace were sampled at the addresses in the keys of r from the corresponding distributions in the values of r.  Returns a function with call signature g(params...) that returns (t :: Trace, rval), where rval  is the return type of f. \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.update-Union{Tuple{I}, Tuple{F}, Tuple{F, CrimsonSkyline.SamplingResults{I}}} where {F<:Function, I<:CrimsonSkyline.InferenceType}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.update","text":"function update(f :: F, r :: SamplingResults{I}) where {F <: Function, I <: InferenceType}\n\nGiven a stochastic function f and a SamplingResults r, update the prior  predictive to the posterior predictive by jointly replacing all latent sample sites with the joint empirical  posterior. Returns a stochastic function g with the same call signature as f. This function will modify in  place the trace passed into it as the first argument.\n\n\n\n\n\n","category":"method"},{"location":"#importance","page":"CrimsonSkyline.jl","title":"importance","text":"","category":"section"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Importance sampling algorithms and utilities.  Currently the following importance sampling algorithms are implemented:","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Likelihood weighting\nGeneric user-defined proposal","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Modules = [CrimsonSkyline]\nPages = [\"importance.jl\"]","category":"page"},{"location":"#CrimsonSkyline.importance_sampling-Union{Tuple{F2}, Tuple{F1}, Tuple{F1, F2, Tuple{DataType, DataType}}} where {F1<:Function, F2<:Function}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.importance_sampling","text":"function importance_sampling(f :: F1, q :: F2; params = (), nsamples :: Int = 1) where {F1 <: Function, F2 <: Function}\n\nGiven a stochastic function f, a proposal function q, and a tuple of params to pass to f and q, compute nsamples iterations of importance sampling. q must have the same input signature  as f. Returns a SamplingResults instance.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.importance_sampling-Union{Tuple{F2}, Tuple{F1}, Tuple{F1, F2}} where {F1<:Function, F2<:Function}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.importance_sampling","text":"function importance_sampling(f :: F1, q :: F2; params = (), nsamples :: Int = 1) where {F1 <: Function, F2 <: Function}\n\nGiven a stochastic function f, a proposal function q, and a tuple of params to pass to f and q, compute nsamples iterations of importance sampling. q must have the same input signature  as f. Returns a SamplingResults instance.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.is_step-Union{Tuple{F2}, Tuple{F1}, Tuple{F1, F2, Tuple{DataType, DataType}}} where {F1<:Function, F2<:Function}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.is_step","text":"function is_step(f :: F1, q :: F2, types::Tuple{DataType,DataType}; params = ()) where {F1 <: Function, F2 <: Function}\n\nPerform one step of importance sampling – draw a single sample from the proposal q, replay  it through f, and record the log weight as log W_n = log p(x z_n) - log q(z_n). Returns a tuple (log weight, rval, trace). \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.is_step-Union{Tuple{F2}, Tuple{F1}, Tuple{F1, F2}} where {F1<:Function, F2<:Function}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.is_step","text":"function is_step(f :: F1, q :: F2; params = ()) where {F1 <: Function, F2 <: Function}\n\nPerform one step of importance sampling – draw a single sample from the proposal q, replay  it through f, and record the log weight as log W_n = log p(x z_n) - log q(z_n). Returns a tuple (log weight, rval, trace). \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.likelihood_weighting-Union{Tuple{F}, Tuple{F, Tuple{DataType, DataType}, Vararg{Any, N} where N}} where F<:Function","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.likelihood_weighting","text":"function likelihood_weighting(f :: F, types::Tuple{DataType, DataType}, params...; nsamples :: Int = 1) where F <: Function\n\nGiven a stochastic function f and arguments to the function params..., executes nsamples iterations of importance sampling by using the prior as a proposal distribution. The importance weights are given by log W_n = ell(t_n). Returns an SamplingResults instance. \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.likelihood_weighting-Union{Tuple{F}, Tuple{F, Vararg{Any, N} where N}} where F<:Function","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.likelihood_weighting","text":"function likelihood_weighting(f :: F, params...; nsamples :: Int = 1) where F <: Function\n\nGiven a stochastic function f and arguments to the function params..., executes nsamples iterations of importance sampling by using the prior as a proposal distribution. The importance weights are given by log W_n = ell(t_n). Returns an SamplingResults instance. \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.likelihood_weighting_results-Tuple{}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.likelihood_weighting_results","text":"likelihood_weighting_results()\n\nOuter constructor for SamplingResults.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.log_evidence-Union{Tuple{CrimsonSkyline.SamplingResults{I}}, Tuple{I}} where I<:CrimsonSkyline.Importance","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.log_evidence","text":"function log_evidence(r :: SamplingResults{LikelihoodWeighting})\n\nComputes the log evidence (log partition function), \n\nlog Z equiv log p(x) approx -log N_textsamples + log sum_n=1^N_textsamples W_n\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.lw_step-Union{Tuple{F}, Tuple{F, Tuple{DataType, DataType}, Vararg{Any, N} where N}} where F<:Function","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.lw_step","text":"function lw_step(f :: F, types::Tuple{DataType, DataType}, params...) where F <: Function\n\nPerform one step of likelihood weighting – draw a single proposal from the prior and compute  the log weight as equal to the likelihood. Returns a tuple (log weight, rval, trace).\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.lw_step-Union{Tuple{F}, Tuple{F, Vararg{Any, N} where N}} where F<:Function","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.lw_step","text":"function lw_step(f :: F, params...) where F <: Function\n\nPerform one step of likelihood weighting – draw a single proposal from the prior and compute  the log weight as equal to the likelihood. Returns a tuple (log weight, rval, trace).\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.normalized_weights-Union{Tuple{CrimsonSkyline.SamplingResults{I}}, Tuple{I}} where I<:CrimsonSkyline.Importance","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.normalized_weights","text":"function normalized_weights(r :: SamplingResults{LikelihoodWeighting})\n\nComputes the normalized weights w_n from unnormalized weights W_n:\n\nw_n = W_n  p(x) = expell(t_n) - log Z\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Union{Tuple{I}, Tuple{CrimsonSkyline.SamplingResults{I}, Any, Int64}} where I<:CrimsonSkyline.Importance","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(r :: SamplingResults{LikelihoodWeighting}, k, n :: Int)\n\nDraws n samples from the empirical marginal posterior at address k.\n\n\n\n\n\n","category":"method"},{"location":"#metropolis","page":"CrimsonSkyline.jl","title":"metropolis","text":"","category":"section"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Metropolis algorithm and utilities. Currently the following algorithms are implemented for both  FOPPL and HOPPL programs:","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Independent prior proposal\nArbitrary single- or multi-site proposal","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Here are two examples of inference using the arbitrary MH step interface. Consider the following generative function:","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"function normal_model(t :: Trace, data :: Vector{Float64})\n    loc = sample(t, :loc, Normal(0.0, 10.0))\n    scale = sample(t, :scale, LogNormal())\n    for i in 1:length(data)\n        observe(t, (:obs, i), Normal(loc, scale), data[i])\n    end\nend","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"To learn an approximate posterior for :loc and :scale, we will introduce two proposal kernels:","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"loc_proposal(old_t :: Trace, new_t :: Trace, data) = propose(new_t, :loc, Normal(old_t[:loc].value, 0.25))\nscale_proposal(old_t :: Trace, new_t :: Trace, data) = propose(new_t, :scale, truncated(Normal(old_t[:scale].value, 0.25), 0.0, Inf))","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Note that while loc_proposal is symmetric, scale_proposal is not. To perform inference, we pass these kernels to mh_step in  a loop after first drawing a random trace:","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"t = trace()\nnormal_model(t, data)\nfor i in 1:niter\n    t = mh_step(t, normal_model, loc_proposal; params = (data,))\n    t = mh_step(t, normal_model, scale_proposal; params = (data,))\nend","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"In this case, inference was fairly successful:","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"[ Info: True loc = 4.0\n[ Info: True std = 1.0\n[ Info: inferred E[loc] = 4.022688081613082\n[ Info: inferred E[scale] = 0.9696559373495869\n[ Info: approximate p(x) = sum_z p(x|z) = -138.63530736205144","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"As a less trivial (but still contrived!) inference example, we can infer the posterior distribution of a latent discrete random variable in an open-universe model: ","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"function random_sum_model(t :: Trace, data)\n    n = sample(t, :n, Geometric(0.1))\n    loc = 0.0\n    for i in 1:(n + 1)\n        loc += sample(t, (:loc, i), Normal())\n    end\n    obs = Array{Float64, 1}()\n    for j in 1:length(data)\n        o = observe(t, (:data, j), Normal(loc, 1.0), data[j])\n        push!(obs, o)\n    end\n    obs\nend","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"(N.B.: we write the model is this form for pedagogic reasons; there is a far more efficient way to express the latent structure  of this model, namely n sim textGeometric(01), textloc sim textNormal(0 n).) We are interested in learning the posterior distribution of :n. We introduce two proposal distributions, one for the latent discrete rv and another generic proposal for the location increments:","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"function random_n_proposal(old_trace, new_trace, params...)\n    old_n = float(old_trace[:n].value)\n    if old_n > 0\n        propose(new_trace, :n, Poisson(old_n))\n    else\n        propose(new_trace, :n, Poisson(1.0))\n    end\nend\n\ngen_loc_proposal(old_trace, new_trace, ix, params...) = propose(new_trace, (:loc, ix), Normal(old_trace[(:loc, ix)].value, 0.25))","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"We again conduct inference by simply applying proposals within a loop. This time, the number of location increment proposals we need to  construct is dependent on the sampled values of the latent random variable. We can either create these proposals on the fly as they're  needed or create what is nearly guaranteed to be enough of them before any inference is performed, e.g.,  loc_proposals = [(o, n, params...) -> gen_loc_proposal(o, n, i, params...) for i in 1:100]. Now that we have what we need, we can conduct inference:","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"t = trace()\nrandom_sum_model(t, data)\n...\nfor i in 1:niter\n    t = mh_step(t, random_sum_model, random_n_proposal; params=(data,))\n    for j in 1:(t[:n].value + 1)\n        t = mh_step(t, random_sum_model, loc_proposals[j]; params=(data,))\n    end\n    push!(ns, t[:n].value)\nend","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Our inference results look promising:","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"[ Info: True :n = 9\n[ Info: Posterior E[:n] = 7.581604598850287","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"For more examples, check back soon.","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Modules = [CrimsonSkyline]\nPages = [\"metropolis.jl\"]","category":"page"},{"location":"#CrimsonSkyline.accept-Tuple{Trace, Trace, Float64}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.accept","text":"function accept(t :: Trace, new_t :: Trace, log_a :: Float64)\n\nStochastic function that either returns new_t if accepted or returns t if not accepted.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.copy_common!-Tuple{Trace, Trace}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.copy_common!","text":"function copy_common!(old_t :: Trace, new_t :: Trace)\n\nCopies nodes from old_t into new_t for all addresses in the intersection of their address sets. \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.log_acceptance_ratio-Tuple{Trace, Trace, CrimsonSkyline.Prior}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.log_acceptance_ratio","text":"function log_acceptance_ratio(t :: Trace, t_proposed :: Trace, p :: Prior)\n\nComputes the log acceptance ratio of a Metropolis step when using the independent prior proposal  algorithm:\n\nlog alpha = ell(t_textproposed) - ell(t_textoriginal)\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.loglatent-Tuple{Trace}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.loglatent","text":"function loglatent(t :: Trace)\n\nComputes the joint log probability of all latent variables in a trace, log p(t) - ell(t).\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.logprob-Tuple{Trace, Trace}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.logprob","text":"function logprob(t0 :: Trace, t1 :: Trace)\n\nComputes the proposal log probability q(t_1  t_0).\n\nThis expression has two parts: log probability that is generated at the proposed site(s), and  log probability that is generated at the sites that are present in t1 but not in t0. \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.mh-Tuple{F} where F<:Function","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.mh","text":"function mh(f :: F; params = (), burn = 100, thin = 10, num_iterations = 10000) where F <: Function\n\nGeneric Metropolis algorithm using draws from the prior.\n\nArgs:\n\nf: stochastic function. Must have call signature f(t :: Trace, params...)\nparams: addditional arguments to pass to f and each of the proposal kernels.\nburn: number of samples to discard at beginning of markov chain\nthin: keep only every thin-th draw. E.g., if thin = 100, only every 100-th trace will be kept.\nnum_iterations: total number of steps to take in the markov chain\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.mh-Union{Tuple{A}, Tuple{F}, Tuple{F, A, Tuple{DataType, DataType}}} where {F<:Function, A<:AbstractArray}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.mh","text":"function mh(f :: F, qs :: A, types::Tuple{DataType,DataType}; params = (), burn = 100, thin = 10, num_iterations = 10000, inverse_verbosity = 100) where {F <: Function, A <: AbstractArray}\n\nGeneric Metropolis algorithm using user-defined proposal kernels.\n\nArgs:\n\nf: stochastic function. Must have call signature f(t :: Trace, params...)\nqs: array-like of proposal kernels. Proposal kernels are applied sequentially in the order that they appear in this array.   Proposal kernels must have the signature q(old_t :: Trace, new_t :: Trace, params...) where it must take in at least the same number of arguments   in params as f.\nparams: addditional arguments to pass to f and each of the proposal kernels.\nburn: number of samples to discard at beginning of markov chain\nthin: keep only every thin-th draw. E.g., if thin = 100, only every 100-th trace will be kept.\nnum_iterations: total number of steps to take in the markov chain\ninverse_verbosity: every inverse_verbosity iterations, a stattus report will be logged.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.mh-Union{Tuple{A}, Tuple{F}, Tuple{F, A}} where {F<:Function, A<:AbstractArray}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.mh","text":"function mh(f :: F, qs :: A; params = (), burn = 100, thin = 10, num_iterations = 10000, inverse_verbosity = 100) where {F <: Function, A <: AbstractArray}\n\nGeneric Metropolis algorithm using user-defined proposal kernels.\n\nArgs:\n\nf: stochastic function. Must have call signature f(t :: Trace, params...)\nqs: array-like of proposal kernels. Proposal kernels are applied sequentially in the order that they appear in this array.   Proposal kernels must have the signature q(old_t :: Trace, new_t :: Trace, params...) where it must take in at least the same number of arguments   in params as f.\nparams: addditional arguments to pass to f and each of the proposal kernels.\nburn: number of samples to discard at beginning of markov chain\nthin: keep only every thin-th draw. E.g., if thin = 100, only every 100-th trace will be kept.\nnum_iterations: total number of steps to take in the markov chain\ninverse_verbosity: every inverse_verbosity iterations, a stattus report will be logged.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.mh-Union{Tuple{F}, Tuple{F, Tuple{DataType, DataType}}} where F<:Function","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.mh","text":"function mh(f :: F types::Tuple{DataType, DataType}; params = (), burn = 1000, thin = 50, num_iterations = 10000) where F <: Function\n\nGeneric Metropolis algorithm using draws from the prior.\n\nArgs:\n\nf: stochastic function. Must have call signature f(t :: Trace, params...)\nparams: addditional arguments to pass to f and each of the proposal kernels.\nburn: number of samples to discard at beginning of markov chain\nthin: keep only every thin-th draw. E.g., if thin = 100, only every 100-th trace will be kept.\nnum_iterations: total number of steps to take in the markov chain\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.mh_step-Union{Tuple{F2}, Tuple{F1}, Tuple{Trace, F1, F2, Tuple{DataType, DataType}}} where {F1<:Function, F2<:Function}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.mh_step","text":"function mh_step(t :: Trace, f :: F1, q :: F2, types::Tuple{DataType,DataType}; params = (), return_val :: Bool = false) where {F1 <: Function, F2 <: Function}\n\nA generic Metropolis step using an arbitrary proposal kernel. \n\nGiven a trace t, a stochastic function f with signature f(t :: Trace, params...) a stochastic function  q with signature q(old_trace :: Trace, new_trace :: Trace, params...), generates a proposal from q and  accepts based on the log acceptance probability:\n\nlog alpha = log p(t_textnew) - log q(t_textnewt_textold) - log p(t_textold) - log q(t_textold  t_textnew)\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.mh_step-Union{Tuple{F2}, Tuple{F1}, Tuple{Trace, F1, F2}} where {F1<:Function, F2<:Function}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.mh_step","text":"function mh_step(t :: Trace, f :: F1, q :: F2; params = ()) where {F1 <: Function, F2 <: Function}\n\nA generic Metropolis step using an arbitrary proposal kernel. \n\nGiven a trace t, a stochastic function f with signature f(t :: Trace, params...) a stochastic function  q with signature q(old_trace :: Trace, new_trace :: Trace, params...), generates a proposal from q and  accepts based on the log acceptance probability:\n\nlog alpha = log p(t_textnew) - log q(t_textnewt_textold) - log p(t_textold) - log q(t_textold  t_textnew)\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.mh_step-Union{Tuple{F}, Tuple{Trace, F, Tuple{DataType, DataType}}} where F<:Function","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.mh_step","text":"function mh_step(t :: Trace, f :: F, types::Tuple{DataType, DataType}; params = (), return_val :: Bool = false) where F <: Function\n\nAn independent prior sample Metropolis step.\n\nGiven a trace t and stochatic function f depending on params..., generates proposals  from prior draws and accepts based on the likelihood ratio.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.mh_step-Union{Tuple{F}, Tuple{Trace, F}} where F<:Function","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.mh_step","text":"function mh_step(t :: Trace, f :: F; params = (), return_val :: Bool = false) where F <: Function\n\nAn independent prior sample Metropolis step.\n\nGiven a trace t and stochatic function f depending on params..., generates proposals  from prior draws and accepts based on the likelihood ratio.\n\n\n\n\n\n","category":"method"},{"location":"#nested","page":"CrimsonSkyline.jl","title":"nested","text":"","category":"section"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Modules = [CrimsonSkyline]\nPages = [\"nested.jl\"]","category":"page"},{"location":"#CrimsonSkyline.nested-Tuple{F} where F<:Function","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.nested","text":"nested(f :: F; params = (), num_points :: Int64 = 1) where F <: Function\n\nRun nested sampling using internal rejection method.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.nested-Union{Tuple{F2}, Tuple{F1}, Tuple{F1, F2}} where {F1<:Function, F2<:Function}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.nested","text":"function nested(f :: F1, replace_fn :: F2; params = (), num_points :: Int64 = 1) where {F1 <: Function, F2 <: Function}\n\nGeneric implementation of nested sampling (Skilling, Nested sampling for general Bayesian computation, Bayesian Analysis, 2006). The number of sampling iterations is a function of num_points aka N, and the empirical entropy of the sampling distribution, given at the n-th iteration by H_n approx sum_k hat p_k log hat p_k^-1, where hat p_k = L_k w_k  Z_k, L_k is the likelihood value, w_k is the difference in prior mass, and Z_k is the current estimate of the partition function. The number of sampling iterations is equal to min_n n  0 n  NH_n. \n\nArgs:\n\nf: stochastic function. Must have signature f(t :: Trace, params...)\nreplace_fn: function that returns a tuple (new_trace :: Trace, new_log_likelihood :: Float64). The input signature of this function   must be replace_fn(f :: F, log_likelihood :: Float64, params...) where F <: Function. It must guarantee that new_log_likelihood > log_likelihood.\nparams: any parameters to pass to f\nnum_points: the number of likelihood points to keep track of\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.rejection-Union{Tuple{F}, Tuple{F, Float64, Vararg{Any, N} where N}} where F<:Function","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.rejection","text":"function rejection(f :: F, log_l :: Float64, params...) where F <: Function\n\nSamples from the prior with the hard likelihood constraint log L_k  log_l.\n\nArgs:\n\nf stochastic function. Must have signature f(t :: Trace, params...)\nlog_l: current log likelihood threshold \nparams: any additional arguments to pass to f\n\n\n\n\n\n","category":"method"},{"location":"#results","page":"CrimsonSkyline.jl","title":"results","text":"","category":"section"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Modules = [CrimsonSkyline]\nPages = [\"results.jl\"]","category":"page"},{"location":"#CrimsonSkyline.NonparametricSamplingResults","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.NonparametricSamplingResults","text":"struct NonparametricSamplingResults{I} <: SamplingResults{I}\n    interpretation :: I\n    log_weights :: Array{Float64, 1}\n    return_values :: Array{Any, 1}\n    traces :: Array{Trace, 1}\nend\n\nWrapper for results of sampling. Implements the following methods  from Base: getindex, length, keys. Intepretation of log weights is dependent on I.\n\n\n\n\n\n","category":"type"},{"location":"#CrimsonSkyline.ParametricSamplingResults","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.ParametricSamplingResults","text":"struct ParametricSamplingResults{I} <: SamplingResults{I}\n    interpretation :: I\n    log_weights :: Array{Float64, 1}\n    return_values :: Array{Any, 1}\n    traces :: Array{Trace, 1}\n    distributions :: Dict\nend\n\ndistributions maps from addresses to distributions, a mapsto pi^(a)_psi(z), where  pi^(a)_psi(z) solves\n\nmax_psi E_z sim p(zx)log pi^(a)_psi(z)\n\nThe distributions are not used to generate values but only to score sampled values; values are  still sampled from the posterior traces. Right now, the parametric approximation is very simple: values with support over the  negative orthant of  mathbb R^D are approximated by (multivariate) normal distributions, while  values with support over only the positive orthant of mathbbR^D are approximated by  (multivariate) lognormal distributions. This behavior is expected to change in the future.\n\n\n\n\n\n","category":"type"},{"location":"#CrimsonSkyline.addresses-Union{Tuple{CrimsonSkyline.SamplingResults{I}}, Tuple{I}} where I<:CrimsonSkyline.InferenceType","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.addresses","text":"function addresses(r::SamplingResults{I}) where I <: InferenceType\n\nGet all addresses associated with the SamplingResults object, A = bigcup_tin texttracesmathcal A_t\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.aic-Union{Tuple{CrimsonSkyline.SamplingResults{I}}, Tuple{I}} where I<:CrimsonSkyline.InferenceType","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.aic","text":"function aic(r :: SamplingResults{I}) where I <: InferenceType\n\nComputes an empirical estimate of the Akaike Information Criterion from a SamplingResults. The formula is \n\ntextAIC(r)2 = min_t in texttraces(r)textparams(t) - hatell(t)\n\nwhere textparams(t) is the number of non-observed and non-deterministic sample nodes and hatell(t) is the empirical maximum likelihood.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.reflate!-Union{Tuple{I}, Tuple{CrimsonSkyline.ParametricSamplingResults{I}, Dict}} where I<:CrimsonSkyline.InferenceType","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.reflate!","text":"function reflate!(r::ParametricSamplingResults{I}, mapping::Dict) where I<:InferenceType\n\nReflates the scale parameters of the distributions of r. The inferred scale parameters  approximate the true uncertainty of the posterior distribution under the critical assumption that the data generating process (DGP) remains constant. When the DGP is nonstationary, it is necessary to intervene and increase the value of the scale parameters to properly  account for uncertainty. mapping is a dict of address => value where value is either a float or a positive definite matrix depending on if the distribution associated with address is scalar- or vector-valued. \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Union{Tuple{I}, Tuple{Trace, Any, CrimsonSkyline.ParametricSamplingResults{I}}} where I<:CrimsonSkyline.InferenceType","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(t :: Trace, a, r::ParametricSamplingResults{I}; pa = ()) where I <: InferenceType\n\nTreat a marginal site of a SamplingResults as a distribution, sampling from it into a trace.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Union{Tuple{I}, Tuple{Trace, Any, NonparametricSamplingResults{I}}} where I<:CrimsonSkyline.InferenceType","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(t :: Trace, a, r :: NonparametricSamplingResults{I}; pa = ()) where I <: InferenceType\n\nTreat a marginal site of a SamplingResults as a distribution, sampling from it into a trace.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.to_parametric-Union{Tuple{NonparametricSamplingResults{I}}, Tuple{I}} where I<:CrimsonSkyline.InferenceType","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.to_parametric","text":"function to_parametric(r::NonparametricSamplingResults{I}) where I<:InferenceType\n\nConverts a nonparametric sampling results object into one that additionally contains a mapping from addresses to distributions. \n\n\n\n\n\n","category":"method"},{"location":"#Distributions.logpdf-Union{Tuple{A}, Tuple{A, Any}} where A<:AbstractArray","page":"CrimsonSkyline.jl","title":"Distributions.logpdf","text":"function Distributions.logpdf(r :: A, v) where A <: AbstractArray\n\nInterprets an array of objects as a delta distribution over those objects. If v is in the support set,  returns -log r. Otherwise, returns -infty. \n\n\n\n\n\n","category":"method"},{"location":"#Index","page":"CrimsonSkyline.jl","title":"Index","text":"","category":"section"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"","category":"page"}]
}
