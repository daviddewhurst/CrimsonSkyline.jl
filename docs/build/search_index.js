var documenterSearchIndex = {"docs":
[{"location":"#CrimsonSkyline.jl","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"","category":"section"},{"location":"#trace","page":"CrimsonSkyline.jl","title":"trace","text":"","category":"section"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"To a large extent, Nodes have local control over the behavior of inference algorithms via their  interpretation. There are a variety of Interpretations. The type hierarchy is flat:","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"abstract type Interpretation end\nstruct Nonstandard <: Interpretation end\nstruct Standard <: Interpretation end\nstruct Replayed <: Interpretation end\nstruct Conditioned <: Interpretation end \nstruct Blocked <: Interpretation end\nstruct Deterministic <: Interpretation end\nstruct Proposed <: Interpretation end","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Modules = [CrimsonSkyline]\nPages = [\"trace.jl\"]","category":"page"},{"location":"#CrimsonSkyline.Node","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.Node","text":"mutable struct Node{A, D, T, P}\n    address :: A\n    dist :: D\n    value :: Maybe{T}\n    logprob :: P\n    logprob_sum :: Float64\n    observed :: Bool\n    pa :: Array{Node, 1}\n    ch :: Array{Node, 1}\n    interpretation :: Interpretation\n    last_interpretation :: Interpretation\nend\n\n\n\n\n\n","category":"type"},{"location":"#CrimsonSkyline.Trace","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.Trace","text":"mutable struct Trace\n    trace :: OrderedDict{Any, Node}\n    logprob_sum :: Float64\nend\n\nTraces support the following Base methods: setindex!, getindex, keys, values, and length.\n\n\n\n\n\n","category":"type"},{"location":"#CrimsonSkyline.aic-Tuple{Trace}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.aic","text":"function aic(t :: Trace)\n\nComputes the Akaike Information Criterion for a single trace (thus replacing the definition) with  \"maximum likelihood\" by one with \"likelihood\". The formula is \n\ntextAIC(t)2 = textparams(t) - ell(t)\n\nwhere textparams(t) is the number of non-observed and non-deterministic sample nodes.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.connect_pa_ch!-Tuple{Trace,Any,Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.connect_pa_ch!","text":"function connect_pa_ch!(t :: Trace, pa, a)\n\nConnects parent and child nodes. Adds child nodes to parent's ch and  parent nodes to child's pa.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.interpret_latent!-Tuple{Trace,CrimsonSkyline.Interpretation}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.interpret_latent!","text":"function interpret_latent!(t :: Trace, i :: Interpretation)\n\nChanges the interpretation of all nodes in t to have interpretation == i\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.loglikelihood-Tuple{Trace}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.loglikelihood","text":"function loglikelihood(t :: Trace)\n\nComputes and returns the log likelihood of the observed data under the model:\n\nell(t) = \nsum_a a in textkeys(t) wedge textinterpretation(a) = textStandard \nlog p(ta)\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.logprob!-Tuple{Trace}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.logprob!","text":"function logprob!(t :: Trace)\n\nComputes the joint log probability to the trace and assigns it to t.logprob_sum.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.logprob-Tuple{Trace}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.logprob","text":"function logprob(t :: Trace)\n\nComputes and returns the joint log probability of the trace:\n\nlog p(t) = sum_a in textkeys(t)log p(ta)\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{Any,A,D,Bool,CrimsonSkyline.Interpretation}} where D where A","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.node","text":"function node(value, address :: A, dist :: D, is_obs :: Bool, i :: Interpretation) where {A, D}\n\nOuter constructor for Node where data is passed during construction. Data type is inferred from the passed data.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{DataType,A,D,Bool,CrimsonSkyline.Interpretation}} where D where A","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.node","text":"function node(T :: DataType, address :: A, dist :: D, is_obs :: Bool, i :: Interpretation) where {A, D}\n\nOuter constructor for Node where no data is passed during construction. \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.observe-Tuple{Trace,Any,Any,Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.observe","text":"function observe(t :: Trace, a, d, s; pa = ())\n\nIf d is not nothing an alias for calling sample with standard interpretation.  Otherwise, an alias for calling sample with nonstandard interpretation. \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.pa_from_trace-Tuple{Trace,Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.pa_from_trace","text":"function pa_from_trace(t :: Trace, pa)\n\nCollects nodes in trace corresponding to an iterable of parent addresses pa.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.prior-Union{Tuple{F}, Tuple{F,Union{Tuple, AbstractArray},Vararg{Any,N} where N}} where F<:Function","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.prior","text":"function prior(f :: F, addresses :: Union{AbstractArray, Tuple}, params...; nsamples :: Int = 1) where F <: Function\n\nGiven a generative function f, an array-like of addresses, and a collection of parameters to pass to f, runs nsamples evaluations of the f, collecting the values from the addresses and returning a Dict mapping addresses to values. \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.propose-Tuple{Trace,Any,Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.propose","text":"propose(t :: Trace, a, d)\n\nPropose a value for the address a in trace t from the distribution d.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any,Array{CrimsonSkyline.Interpretation,1}}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(t :: Trace, a, d, params, ii :: Array{Interpretation, 1}; pa = ())\n\nSequentially apply sample statements with interpretations as given in ii. This is  used to depth-first traverse the interpretation graph.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any,CrimsonSkyline.Blocked}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(t :: Trace, a, d, params, i :: Blocked; pa = ())\n\nSamples from d passing the optional arguments params, deletes the node stored at address a from trace t, and returns the sampled value. \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any,Deterministic}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(t :: Trace, a, f, v, i :: Deterministic; pa = ())\n\nCreates a deterministic node mapping the tuple of data v through function f,  storing the value in trace t at address a.\n\nInfers input type from v\nMaps tuple of data v through function f, yielding r = f(v...)\nCreates a deterministic node and stores it in t at address a\nOptionally adds nodes corresponding to the addresses in pa as parent nodes\nReturns r\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any,Nonstandard}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(t :: Trace, a, d, params, i :: Nonstandard; pa = ())\n\nSamples from distribution d into trace t at address a.\n\nSamples a value from d passing the optional arguments params\nCreates a sample node\nAdds the sample node to trace t at value a\nOptionally adds nodes corresponding to the addresses in pa as parent nodes\nReturns the sampled value\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any,Replayed}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(t :: Trace, a, d, params, i :: Replayed; pa = ())\n\nReplays the sampled node through the trace. \n\nIf a is not in t's address set, calls sample(t, a, d, NONSTANDARD; pa = pa). \nCreates a sample node that copies the value from the last node stored in the trace at address a. \nAdds the sample node to trace t at value a\nOptionally adds nodes corresponding to the addresses in pa as parent nodes\nResets the node's interpretation to the original interpretation\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any,Standard}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(t :: Trace, a, d, s, i :: Standard; pa = ())\n\nScores an observed value s against the distribution d, storing the value in trace t at  address a and optionally adds nodes corresponding to the addresses in pa as parent nodes.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(t :: Trace, a, d, params; pa = ())\n\nIf a is in the set of trace addresses, calls sample using t[a]'s interpretation.  Otherwise, calls sample using nonstandard interpretation. \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Array{CrimsonSkyline.Interpretation,1}}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(t :: Trace, a, d, ii :: Array{Interpretation, 1}; pa = ())\n\nSequentially apply sample statements with interpretations as given in ii. This is  used to depth-first traverse the interpretation graph.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Tuple{Trace,Any,Any,CrimsonSkyline.Blocked}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(t :: Trace, a, d, i :: Blocked; pa = ())\n\nSamples from d, deletes the node stored at address a from trace t, and returns the  sampled value. \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Nonstandard}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(t :: Trace, a, d, i :: Nonstandard; pa = ())\n\nSamples from distribution d into trace t at address a.\n\nSamples a value from d\nCreates a sample node\nAdds the sample node to trace t at value a\nOptionally adds nodes corresponding to the addresses in pa as parent nodes\nReturns the sampled value\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Replayed}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(t :: Trace, a, d, i :: Replayed; pa = ())\n\nReplays the sampled node through the trace. \n\nIf a is not in t's address set, calls sample(t, a, d, NONSTANDARD; pa = pa). \nCreates a sample node that copies the value from the last node stored in the trace at address a. \nAdds the sample node to trace t at value a\nOptionally adds nodes corresponding to the addresses in pa as parent nodes\nResets the node's interpretation to the original interpretation\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Tuple{Trace,Any,Any,Standard}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(t :: Trace, a, d, i :: Standard; pa = ())\n\nScores an observed value against the distribution d, storing the value in trace t at  address a and optionally adds nodes corresponding to the addresses in pa as parent nodes.\n\nThis method is used by the condition effect. It will probably not be used by most  users.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Tuple{Trace,Any,Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(t :: Trace, a, d; pa = ())\n\nIf a is in the set of trace addresses, calls sample using t[a]'s interpretation.  Otherwise, calls sample using nonstandard interpretation. \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.trace-Tuple{}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.trace","text":"trace()\n\nThis is the recommended way to construct a new trace.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.transform-Union{Tuple{F}, Tuple{Trace,Any,F,Any}} where F<:Function","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.transform","text":"function transform(t :: Trace, a, f :: F, v; pa = ()) where F <: Function\n\nAlias for sample(t, a, f, v, DETERMINISTIC; pa = pa).\n\n\n\n\n\n","category":"method"},{"location":"#io","page":"CrimsonSkyline.jl","title":"io","text":"","category":"section"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Saving and loading traces is possible using the save and load functions. This functionality depends on JuliaDB. Example usage (fn is a stochastic function):","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"t = trace()\ndata = randn(2)\nfn(t, data)\nfname = joinpath(@__DIR__, \"out\", \"my_file.jdb\")\nf = save(t, fname)\nidentical_t = load(f)","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Modules = [CrimsonSkyline]\nPages = [\"io.jl\"]","category":"page"},{"location":"#CrimsonSkyline.load-Tuple{Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.load","text":"function load(f) :: Trace\n\nLoads a serialized juliadb table from file f and converts it into a trace.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.save-Tuple{Trace,Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.save","text":"function save(t :: Trace, f)\n\nSaves a trace to disk as a serialized juliadb table at the filepath f.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.to_table-Tuple{Trace}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.to_table","text":"function to_table(t :: Trace)\n\nTurns a trace into a juliadb table. Does not store parent / child relationships.\n\n\n\n\n\n","category":"method"},{"location":"#effects","page":"CrimsonSkyline.jl","title":"effects","text":"","category":"section"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"A library of functions that change the interpretation of some or all nodes in a trace.","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Modules = [CrimsonSkyline]\nPages = [\"effects.jl\"]","category":"page"},{"location":"#CrimsonSkyline.block-Union{Tuple{F}, Tuple{F,Trace,Any}} where F<:Function","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.block","text":"function block(f :: F, t :: Trace, addresses) where F <: Function\n\nGiven a stochastic function f, a trace t, and an iterable of addresses, converts traced randomness into untraced randomness. \n\nReturns a tuple (t_new, g), where t_new is a trace and g is a function. The function signature of g is the same as that of f with the first argument removed; that is, if f(t :: Trace, params...), then g(params...). Computation is delayed, so each of  the latent nodes in t_new has interpretation = BLOCKED. Calling g(params...) executes the  computation and each latent node in t_new with an address in addresses is removed.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.block-Union{Tuple{F}, Tuple{F,Trace}} where F<:Function","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.block","text":"block(f :: F, t :: Trace) where F <: Function\n\nConverts all traced randomness into untraced randomness.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.condition-Union{Tuple{F}, Tuple{F,Dict}} where F<:Function","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.condition","text":"function condition(f :: F, evidence :: Dict) where F <: Function\n\nCondition a trace modified by f on evidence, which maps addresses to observed  evidence associated with that address. Returns a function with call signature  identical to that of f and return signature (t :: Trace, rtype) where rtype is the return type of f.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.replace-Tuple{Trace,Dict}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.replace","text":"function replace(t :: Trace, r :: Dict)\n\nGiven a mapping r from addresses to distribution-like (currently Distributions or Array{Any, 1}s), replaces the current distributions at that set of addresses with this set of distributions. Returns the modified trace.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.replace-Union{Tuple{F}, Tuple{F,Dict}} where F<:Function","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.replace","text":"function replace(f :: F, r :: Dict) where F <: Function\n\nGiven a mapping r from addresses to distribution-like (currently Distributions or Array{Any, 1}s), replaces the current distributions at that set of addresses with this set of distributions. Returns a function g that has return signature  (t :: Trace, rval) where rval is a return value of f.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.replay-Union{Tuple{F}, Tuple{F,Trace}} where F<:Function","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.replay","text":"function replay(f :: F, t :: Trace) where F <: Function\n\nGiven a stochastic function f and a trace t, makes sample calls behave as though  they had sampled the values in t at the corresponding addresses. \n\nReturns a tuple (t_new, g), where t_new is a trace and g is a function. The function signature of g is the same as that of f with the first argument removed; that is, if f(t :: Trace, params...), then g(params...). Computation is delayed, so each of the latent nodes in t_new has interpretation = REPLAYED. Calling g(params...) executes the computation and each latent node in t_new reverts to  its original interpretation. \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.rewrite-Union{Tuple{F}, Tuple{F,Trace,Dict}} where F<:Function","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.rewrite","text":"function rewrite(f :: F, t :: Trace, r :: Dict) where F <: Function\n\nRewrites the history of the trace to make it appear as if the values in the trace were sampled at the addresses in the keys of r were sampled from the  corresponding distributions in the values of r. Returns a function with  call signature g(params...) that returns (t :: Trace, rval), where rval  is the return type of f. \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.update-Union{Tuple{I}, Tuple{F}, Tuple{F,SamplingResults{I}}} where I<:CrimsonSkyline.InferenceType where F<:Function","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.update","text":"function update(f :: F, r :: SamplingResults{I}) where {F <: Function, I <: InferenceType}\n\nEXPERIMENTAL: Given a stochastic function f and a SamplingResults r, update the prior  predictive to the posterior predictive by jointly replacing all latent sample sites with the joint empirical  posterior. Returns a stochastic function g with the same call signature as f. This function will modify in  place the trace passed into it as the first argument.\n\n\n\n\n\n","category":"method"},{"location":"#graph","page":"CrimsonSkyline.jl","title":"graph","text":"","category":"section"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Modules = [CrimsonSkyline]\nPages = [\"graph.jl\"]","category":"page"},{"location":"#CrimsonSkyline.Factor","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.Factor","text":"struct Factor \n    info :: OrderedDict{Any, OrderedDict}\n    node_to_factor :: OrderedDict\n    factor_to_node :: OrderedDict\nend\n\nA representation of a factor graph. \n\n\n\n\n\n","category":"type"},{"location":"#CrimsonSkyline.GraphIR","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.GraphIR","text":"struct GraphIR \n    info :: OrderedDict{Any, OrderedDict}\n    graph :: OrderedDict\nend\n\nAn intermediate representation of a single trace as a directed acyclic graph (DAG) that  stores node information in info and DAG structure in graph. The keys and values of graph are addresses, while info is a mapping from addresses to results from calls to node_info. \n\n\n\n\n\n","category":"type"},{"location":"#CrimsonSkyline.factor-Tuple{GraphIR}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.factor","text":"function factor(g :: GraphIR)\n\nOuter constructor for a factor graph from an intermediate DAG representation. \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.factor-Tuple{Trace}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.factor","text":"factor(t :: Trace)\n\nOuter constructor for a factor graph from a trace. \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.graph_ir-Tuple{Trace}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.graph_ir","text":"function graph_ir(t :: Trace)\n\nOuter constructor for GraphIR\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.node_info-Tuple{Trace,Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.node_info","text":"function node_info(t :: Trace, a)\n\nReturns an OrderedDict containing all information about the node t[a] required for graph-based inference algorithms.\n\nKeys include:\n\n\"address\": the address of the node in the trace\n\"dist\": the probability distribution associated with the address\n\"observed\": whether or not the value associated with the node was observed\n\"interpretation\": the interpretation of the node in the trace\n\"data\" (optional): if the value associated with the node was observed, the value associated   with the node. \n\"pa\": the parents of the node in the trace. Note that it is necessary to pass parent addresses   to one of the various sample methods in order to build a nontrivial GraphIR.\n\n\n\n\n\n","category":"method"},{"location":"#cpt","page":"CrimsonSkyline.jl","title":"cpt","text":"","category":"section"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Conditional probability tables (CPT) are a work in progress. Currently there are no implemented inference algorithms that operate on CPTs. ","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Modules = [CrimsonSkyline]\nPages = [\"cpt.jl\"]","category":"page"},{"location":"#CrimsonSkyline.CPT","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.CPT","text":"struct CPT{L<:AbstractDict, D<:AbstractArray}\n    dims :: L\n    axes :: Dict{Any, Int64}\n    labels :: Array{Dict, 1}\n    values :: D\nend\n\nA representation of an arbitrary-dimensional ragged CPT. Supports Base methods  setindex! and getindex.\n\n\n\n\n\n","category":"type"},{"location":"#CrimsonSkyline.cpt-Tuple{L} where L<:AbstractDict","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.cpt","text":"function cpt(dims :: L) where L <: AbstractDict\n\nOuter constructor for CPT. Given a Dict that maps names of dimensions to dimension level names, constructs a CPT with equiprobable coordinates.\n\nExample usage:\n\ndims = Dict(\"cost\" => [\"high\", \"low\"], \"revenue\" => [\"high\", \"medium\", \"low\"])\nc = cpt(dims)\nc[(\"high\", \"low\")] = 0.4\nc[(\"high\", \"high\")] = 0.2\nc[(\"low\", \"low\")] = 0.3\nrenormalize!(c)\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.renormalize!-Tuple{CPT}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.renormalize!","text":"renormalize!(c :: CPT)\n\nRenormalizes the possibly non-normalized factor c to be a proper discrete joint density.\n\n\n\n\n\n","category":"method"},{"location":"#importance","page":"CrimsonSkyline.jl","title":"importance","text":"","category":"section"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Importance sampling algorithms and utilities.  Currently the following importance sampling algorithms are implemented:","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Likelihood weighting\nGeneric user-defined proposal","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Modules = [CrimsonSkyline]\nPages = [\"importance.jl\"]","category":"page"},{"location":"#CrimsonSkyline.importance_sampling-Union{Tuple{F2}, Tuple{F1}, Tuple{F1,F2}} where F2<:Function where F1<:Function","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.importance_sampling","text":"function importance_sampling(f :: F1, q :: F2; params = (), nsamples :: Int = 1) where {F1 <: Function, F2 <: Function}\n\nGiven a stochastic function f, a proposal function q, and a tuple of params to pass to f and q, compute nsamples iterations of importance sampling. q must have the same input signature  as f. Returns a SamplingResults instance.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.is_step-Union{Tuple{F2}, Tuple{F1}, Tuple{F1,F2}} where F2<:Function where F1<:Function","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.is_step","text":"function is_step(f :: F1, q :: F2; params = ()) where {F1 <: Function, F2 <: Function}\n\nPerform one step of importance sampling – draw a single sample from the proposal q, replay  it through f, and record the log weight as log W_n = log p(x z_n) - log q(z_n). Returns a tuple (log weight, rval, trace). \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.likelihood_weighting-Union{Tuple{F}, Tuple{F,Vararg{Any,N} where N}} where F<:Function","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.likelihood_weighting","text":"function likelihood_weighting(f :: F, params...; nsamples :: Int = 1) where F <: Function\n\nGiven a stochastic function f and arguments to the function params..., executes nsamples iterations of importance sampling by using the prior as a proposal distribution. The importance weights are given by log W_n = ell(t_n). Returns an SamplingResults instance. \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.likelihood_weighting_results-Tuple{}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.likelihood_weighting_results","text":"likelihood_weighting_results()\n\nOuter constructor for SamplingResults.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.log_evidence-Union{Tuple{SamplingResults{I}}, Tuple{I}} where I<:CrimsonSkyline.Importance","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.log_evidence","text":"function log_evidence(r :: SamplingResults{LikelihoodWeighting})\n\nComputes the log evidence (log partition function), \n\nlog Z equiv log p(x) approx -log N_textsamples + log sum_n=1^N_textsamples W_n\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.lw_step-Union{Tuple{F}, Tuple{F,Vararg{Any,N} where N}} where F<:Function","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.lw_step","text":"function lw_step(f :: F, params...) where F <: Function\n\nPerform one step of likelihood weighting – draw a single proposal from the prior and compute  the log weight as equal to the likelihood. Returns a tuple (log weight, rval, trace).\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.normalized_weights-Union{Tuple{SamplingResults{I}}, Tuple{I}} where I<:CrimsonSkyline.Importance","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.normalized_weights","text":"function normalized_weights(r :: SamplingResults{LikelihoodWeighting})\n\nComputes the normalized weights w_n from unnormalized weights W_n:\n\nw_n = W_n  p(x) = expell(t_n) - log Z\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Union{Tuple{I}, Tuple{SamplingResults{I},Any,Int64}} where I<:CrimsonSkyline.Importance","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(r :: SamplingResults{LikelihoodWeighting}, k, n :: Int)\n\nDraws n samples from the empirical marginal posterior at address k.\n\n\n\n\n\n","category":"method"},{"location":"#metropolis","page":"CrimsonSkyline.jl","title":"metropolis","text":"","category":"section"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Metropolis algorithm and utilities. Currently the following algorithms are implemented for both  FOPPL and HOPPL programs:","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Independent prior proposal\nArbitrary single- or multi-site proposal","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Here are two examples of inference using the arbitrary MH step interface. Consider the following generative function:","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"function normal_model(t :: Trace, data :: Vector{Float64})\n    loc = sample(t, :loc, Normal(0.0, 10.0))\n    scale = sample(t, :scale, LogNormal())\n    for i in 1:length(data)\n        observe(t, (:obs, i), Normal(loc, scale), data[i])\n    end\nend","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"To learn an approximate posterior for :loc and :scale, we will introduce two proposal kernels:","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"loc_proposal(old_t :: Trace, new_t :: Trace, data) = propose(new_t, :loc, Normal(old_t[:loc].value, 0.25))\nscale_proposal(old_t :: Trace, new_t :: Trace, data) = propose(new_t, :scale, truncated(Normal(old_t[:scale].value, 0.25), 0.0, Inf))","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Note that while loc_proposal is symmetric, scale_proposal is not. To perform inference, we pass these kernels to mh_step in  a loop after first drawing a random trace:","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"t = trace()\nnormal_model(t, data)\nfor i in 1:niter\n    t = mh_step(t, normal_model, loc_proposal; params = (data,))\n    t = mh_step(t, normal_model, scale_proposal; params = (data,))\nend","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"In this case, inference was fairly successful:","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"[ Info: True loc = 4.0\n[ Info: True std = 1.0\n[ Info: inferred E[loc] = 4.022688081613082\n[ Info: inferred E[scale] = 0.9696559373495869\n[ Info: approximate p(x) = sum_z p(x|z) = -138.63530736205144","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"As a less trivial (but still contrived!) inference example, we can infer the posterior distribution of a latent discrete random variable in an open-universe model: ","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"function random_sum_model(t :: Trace, data)\n    n = sample(t, :n, Geometric(0.1))\n    loc = 0.0\n    for i in 1:(n + 1)\n        loc += sample(t, (:loc, i), Normal())\n    end\n    obs = Array{Float64, 1}()\n    for j in 1:length(data)\n        o = observe(t, (:data, j), Normal(loc, 1.0), data[j])\n        push!(obs, o)\n    end\n    obs\nend","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"(N.B.: we write the model is this form for pedagogic reasons; there is a far more efficient way to express the latent structure  of this model, namely n sim textGeometric(01), textloc sim textNormal(0 n).) We are interested in learning the posterior distribution of :n. We introduce two proposal distributions, one for the latent discrete rv and another generic proposal for the location increments:","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"function random_n_proposal(old_trace, new_trace, params...)\n    old_n = float(old_trace[:n].value)\n    if old_n > 0\n        propose(new_trace, :n, Poisson(old_n))\n    else\n        propose(new_trace, :n, Poisson(1.0))\n    end\nend\n\ngen_loc_proposal(old_trace, new_trace, ix, params...) = propose(new_trace, (:loc, ix), Normal(old_trace[(:loc, ix)].value, 0.25))","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"We again conduct inference by simply applying proposals within a loop. This time, the number of location increment proposals we need to  construct is dependent on the sampled values of the latent random variable. We can either create these proposals on the fly as they're  needed or create what is nearly guaranteed to be enough of them before any inference is performed, e.g.,  loc_proposals = [(o, n, params...) -> gen_loc_proposal(o, n, i, params...) for i in 1:100]. Now that we have what we need, we can conduct inference:","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"t = trace()\nrandom_sum_model(t, data)\n...\nfor i in 1:niter\n    t = mh_step(t, random_sum_model, random_n_proposal; params=(data,))\n    for j in 1:(t[:n].value + 1)\n        t = mh_step(t, random_sum_model, loc_proposals[j]; params=(data,))\n    end\n    push!(ns, t[:n].value)\nend","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Our inference results look promising:","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"[ Info: True :n = 9\n[ Info: Posterior E[:n] = 7.581604598850287","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"For more examples, check back soon.","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Modules = [CrimsonSkyline]\nPages = [\"metropolis.jl\"]","category":"page"},{"location":"#CrimsonSkyline.accept-Tuple{Trace,Trace,Float64}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.accept","text":"function accept(t :: Trace, new_t :: Trace, log_a :: Float64)\n\nStochastic function that either returns new_t if accepted or returns t if not accepted.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.copy_common!-Tuple{Trace,Trace}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.copy_common!","text":"function copy_common!(old_t :: Trace, new_t :: Trace)\n\nCopies nodes from old_t into new_t for all addresses in the intersection of their address sets. \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.log_acceptance_ratio-Tuple{Trace,Trace,CrimsonSkyline.Prior}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.log_acceptance_ratio","text":"function log_acceptance_ratio(t :: Trace, t_proposed :: Trace, p :: Prior)\n\nComputes the log acceptance ratio of a Metropolis step when using the independent prior proposal  algorithm:\n\nlog alpha = ell(t_textproposed) - ell(t_textoriginal)\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.loglatent-Tuple{Trace}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.loglatent","text":"function loglatent(t :: Trace)\n\nComputes the joint log probability of all latent variables in a trace, log p(t) - ell(t).\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.logprob-Tuple{Trace,Trace}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.logprob","text":"function logprob(t0 :: Trace, t1 :: Trace)\n\nComputes the proposal log probability q(t_1  t_0).\n\nThis expression has two parts: log probability that is generated at the proposed site(s), and  log probability that is generated at the sites that are present in t1 but not in t0. \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.mh-Tuple{F} where F<:Function","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.mh","text":"function mh(f :: F; params = (), burn = 100, thin = 10, num_iterations = 10000) where F <: Function\n\nGeneric Metropolis algorithm using draws from the prior.\n\nArgs:\n\nf: stochastic function. Must have call signature f(t :: Trace, params...)\nparams: addditional arguments to pass to f and each of the proposal kernels.\nburn: number of samples to discard at beginning of markov chain\nthin: keep only every thin-th draw. E.g., if thin = 100, only every 100-th trace will be kept.\nnum_iterations: total number of steps to take in the markov chain\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.mh-Union{Tuple{A}, Tuple{F}, Tuple{F,A}} where A<:AbstractArray where F<:Function","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.mh","text":"function mh(f :: F, qs :: A; params = (), burn = 100, thin = 10, num_iterations = 10000, inverse_verbosity = 100) where {F <: Function, A <: AbstractArray}\n\nGeneric Metropolis algorithm using user-defined proposal kernels.\n\nArgs:\n\nf: stochastic function. Must have call signature f(t :: Trace, params...)\nqs: array-like of proposal kernels. Proposal kernels are applied sequentially in the order that they appear in this array.   Proposal kernels must have the signature q(old_t :: Trace, new_t :: Trace, params...) where it must take in at least the same number of arguments   in params as f.\nparams: addditional arguments to pass to f and each of the proposal kernels.\nburn: number of samples to discard at beginning of markov chain\nthin: keep only every thin-th draw. E.g., if thin = 100, only every 100-th trace will be kept.\nnum_iterations: total number of steps to take in the markov chain\ninverse_verbosity: every inverse_verbosity iterations, a stattus report will be logged.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.mh_step-Union{Tuple{F2}, Tuple{F1}, Tuple{Trace,F1,F2}} where F2<:Function where F1<:Function","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.mh_step","text":"function mh_step(t :: Trace, f :: F1, q :: F2; params = ()) where {F1 <: Function, F2 <: Function}\n\nA generic Metropolis step using an arbitrary proposal kernel. \n\nGiven a trace t, a stochastic function f with signature f(t :: Trace, params...) a stochastic function  q with signature q(old_trace :: Trace, new_trace :: Trace, params...), generates a proposal from q and  accepts based on the log acceptance probability:\n\nlog alpha = log p(t_textnew) - log q(t_textnewt_textold) - log p(t_textold) - log q(t_textold  t_textnew)\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.mh_step-Union{Tuple{F}, Tuple{Trace,F}} where F<:Function","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.mh_step","text":"function mh_step(t :: Trace, f :: F; params = ()) where F <: Function\n\nAn independent prior sample Metropolis step.\n\nGiven a trace t and stochatic function f depending on params..., generates proposals  from prior draws and accepts based on the likelihood ratio.\n\n\n\n\n\n","category":"method"},{"location":"#results","page":"CrimsonSkyline.jl","title":"results","text":"","category":"section"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Modules = [CrimsonSkyline]\nPages = [\"results.jl\"]","category":"page"},{"location":"#CrimsonSkyline.SamplingResults","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.SamplingResults","text":"struct SamplingResults{I<:InferenceType}\n    interpretation :: I\n    log_weights :: Array{Float64, 1}\n    return_values :: Array{Any, 1}\n    traces :: Array{Trace, 1}\nend\n\nWrapper for results of sampling. Implements the following methods  from Base: getindex, length, keys. Intepretation of log weights is dependent on I.\n\n\n\n\n\n","category":"type"},{"location":"#CrimsonSkyline.aic-Union{Tuple{SamplingResults{I}}, Tuple{I}} where I<:CrimsonSkyline.InferenceType","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.aic","text":"function aic(r :: SamplingResults{I}) where I <: InferenceType\n\nComputes an empirical estimate of the Akaike Information Criterion from a SamplingResults. The formula is \n\ntextAIC(r)2 = min_t in texttraces(r)textparams(t) - hatell(t)\n\nwhere textparams(t) is the number of non-observed and non-deterministic sample nodes and hatell(t) is the empirical maximum likelihood.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Union{Tuple{I}, Tuple{Trace,Any,SamplingResults{I}}} where I<:CrimsonSkyline.InferenceType","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(t :: Trace, a, r :: SamplingResults{I}; pa = ()) where I <: InferenceType\n\nEXPERIMENTAL: treat a marginal site of a SamplingResults as a distribution, sampling from it into a trace using nonstandard interpretation.\n\n\n\n\n\n","category":"method"},{"location":"#Distributions.logpdf-Union{Tuple{A}, Tuple{A,Any}} where A<:AbstractArray","page":"CrimsonSkyline.jl","title":"Distributions.logpdf","text":"function Distributions.logpdf(r :: A, v) where A <: AbstractArray\n\nInterprets an array of objects as a delta distribution over those objects. If v is in the support set,  returns -log r. Otherwise, returns -infty. \n\n\n\n\n\n","category":"method"},{"location":"#fusion","page":"CrimsonSkyline.jl","title":"fusion","text":"","category":"section"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Methods to perform semi-analytical simplification and inference. ","category":"page"},{"location":"#fusion/distributions","page":"CrimsonSkyline.jl","title":"fusion/distributions","text":"","category":"section"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"A collection of distributions that aren't in Distributions.jl. These distributions are useful in their own right, but are  also arise when fusing pairs or triples of known distributions.","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Modules = [CrimsonSkyline]\nPages = [\"fusion/distributions.jl\"]","category":"page"},{"location":"#CrimsonSkyline.CSDistribution","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.CSDistribution","text":"abstract type CSDistribution{D} end\n\nAbstract type from which all CrimsonSkyline distributions subtype. All subtypes implement the following methods from Distributions.jl:  rand and logpdf. Unless otherwise specified, these subtypes do not  implement logpdf., which may change in the future.\n\n\n\n\n\n","category":"type"},{"location":"#CrimsonSkyline.Lomax","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.Lomax","text":"struct Lomax{D} <: CSDistribution{D}\n    α :: D\n    θ :: D \n    γ :: Gamma{D}\nend\n\nA Lomax distribution, which is a power-law distribution supported on 0 infty). It has the pdf \n\np(x  alpha theta) = -(alpha + 1)  log(alpha theta) + log(1 + x theta) \n\nSampling from this distribution is accomplished via a gamma - exponential mixture.  A value g sim textGamma(alpha theta) is drawn, and then  the value e sim textExponential(g) is returned. \n\n\n\n\n\n","category":"type"},{"location":"#CrimsonSkyline.Lomax-Union{Tuple{D}, Tuple{D,D}} where D<:Real","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.Lomax","text":"function Lomax(α :: D, θ :: D) where D <: Real\n\nOuter constructor for Lomax struct.\n\n\n\n\n\n","category":"method"},{"location":"#Index","page":"CrimsonSkyline.jl","title":"Index","text":"","category":"section"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"","category":"page"}]
}
