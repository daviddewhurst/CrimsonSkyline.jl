var documenterSearchIndex = {"docs":
[{"location":"#CrimsonSkyline.jl","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"","category":"section"},{"location":"#trace","page":"CrimsonSkyline.jl","title":"trace","text":"","category":"section"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"To a large extent, Nodes have local control over the behavior of inference algorithms via their  interpretation. There are a variety of Interpretations.","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"abstract type Interpretation end\nstruct Nonstandard <: Interpretation end\nstruct Standard <: Interpretation end\nstruct Replayed <: Interpretation end\nstruct Conditioned <: Interpretation end \nstruct Blocked <: Interpretation end\nstruct Deterministic <: Interpretation end\nstruct Proposed <: Interpretation end","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Modules = [CrimsonSkyline]\nPages = [\"modeling/trace.jl\"]","category":"page"},{"location":"#CrimsonSkyline.ParametricNode","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.ParametricNode","text":"mutable struct ParametricNode{A, D, T} <: Node\n    address :: A\n    dist :: D\n    value :: Maybe{T}\n    logprob :: Float64\n    logprob_sum :: Float64\n    observed :: Bool\n    pa :: Array{Node, 1}\n    ch :: Array{Node, 1}\n    interpretation :: Union{Interpretation, Vector{Interpretation}}\n    last_interpretation :: Union{Interpretation, Vector{Interpretation}}\nend\n\nA Node that can be used with arbitrary code for which rand and Distributionss.logpdf are defined.\n\n\n\n\n\n","category":"type"},{"location":"#CrimsonSkyline.SampleableNode","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.SampleableNode","text":"mutable struct SampleableNode{A, T} <: Node\n    address :: A\n    dist :: Sampleable\n    value :: Maybe{T}\n    logprob :: Float64\n    logprob_sum :: Float64\n    observed :: Bool\n    pa :: Array{Node, 1}\n    ch :: Array{Node, 1}\n    interpretation :: Union{Interpretation, Vector{Interpretation}}\n    last_interpretation :: Union{Interpretation, Vector{Interpretation}}\nend\n\nA Node that is restricted to be used with any Sampleable from Distributions.jl.\n\n\n\n\n\n","category":"type"},{"location":"#CrimsonSkyline.Trace","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.Trace","text":"abstract type Trace end\n\nBase type for all traces. Traces support the following Base methods: setindex!, getindex, keys, values, and length.\n\n\n\n\n\n","category":"type"},{"location":"#CrimsonSkyline.TypedTrace","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.TypedTrace","text":"mutable struct TypedTrace{A, T} <: Trace\n    trace :: OrderedDict{A, SampleableNode{A, T}}\n    logprob_sum :: Float64\nend\n\nTrace that can hold nodes of the specific address (A) and value (T) types.\n\n\n\n\n\n","category":"type"},{"location":"#CrimsonSkyline.UntypedTrace","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.UntypedTrace","text":"mutable struct UntypedTrace\n    trace :: OrderedDict{Any, Node}\n    logprob_sum :: Float64\nend\n\nTrace that can hold nodes with all address and value types. \n\n\n\n\n\n","category":"type"},{"location":"#CrimsonSkyline.connect_pa_ch!-Tuple{Trace, Any, Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.connect_pa_ch!","text":"function connect_pa_ch!(t :: Trace, pa, a)\n\nConnects parent and child nodes. Adds child nodes to parent's ch and  parent nodes to child's pa.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.input-Tuple{Trace, Any, Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.input","text":"input(t :: Trace, a, d)\n\nTrack a model input.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.interpret_latent!-Tuple{Trace, Interpretation}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.interpret_latent!","text":"function interpret_latent!(t :: Trace, i :: Interpretation)\n\nChanges the interpretation of all latent nodes in t to have interpretation == i\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.loglikelihood-Tuple{Trace}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.loglikelihood","text":"function loglikelihood(t :: Trace)\n\nComputes and returns the log likelihood of the observed data under the model:\n\nell(t) = \nsum_a a in textkeys(t) wedge textinterpretation(a) = textStandard \nlog p(ta)\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.logprob!-Tuple{Trace}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.logprob!","text":"function logprob!(t :: Trace)\n\nComputes the joint log probability to the trace and assigns it to t.logprob_sum.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.logprob-Tuple{Trace}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.logprob","text":"function logprob(t :: Trace)\n\nComputes and returns the joint log probability of the trace:\n\nlog p(t) = sum_a in textkeys(t)log p(ta)\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{Any, A, D, Bool, Interpretation}} where {A, D<:Distributions.Sampleable}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.node","text":"function node(value, address :: A, dist :: D, is_obs :: Bool, i :: Interpretation) where {A, D}\n\nOuter constructor for Node where data is passed during construction. Data type is inferred from the passed data.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{Any, A, D, Bool, Interpretation}} where {A, D}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.node","text":"function node(value, address :: A, dist :: D, is_obs :: Bool, i :: Interpretation) where {A, D}\n\nOuter constructor for Node where data is passed during construction. Data type is inferred from the passed data.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{DataType, A, D, Bool, Interpretation}} where {A, D<:Distributions.Sampleable}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.node","text":"function node(T :: DataType, address :: A, dist :: D, is_obs :: Bool, i :: Interpretation) where {A, D}\n\nOuter constructor for Node where no data is passed during construction. \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.node-Union{Tuple{D}, Tuple{A}, Tuple{DataType, A, D, Bool, Interpretation}} where {A, D}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.node","text":"function node(T :: DataType, address :: A, dist :: D, is_obs :: Bool, i :: Interpretation) where {A, D}\n\nOuter constructor for Node where no data is passed during construction. \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.observe-Tuple{Trace, Any, Any, Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.observe","text":"function observe(t :: Trace, a, d, s; pa = ())\n\nIf d is not nothing an alias for calling sample with standard interpretation.  Otherwise, an alias for calling sample with nonstandard interpretation. \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.pa_from_trace-Tuple{Trace, Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.pa_from_trace","text":"function pa_from_trace(t :: Trace, pa)\n\nCollects nodes in trace corresponding to an iterable of parent addresses pa.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.plate-Union{Tuple{F}, Tuple{Trace, F, Any, Any, Int64, Conditioned}} where F<:Function","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.plate","text":"function plate(t::Trace, op::F, a, d, s::Int64, i::Conditioned; pa = ()) where F<:Function\n\nPlate over conditioned variables.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.plate-Union{Tuple{F}, Tuple{Trace, F, Any, Any, Int64, CrimsonSkyline.Blocked}} where F<:Function","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.plate","text":"function plate(t::Trace, op::F, a, d, s::Int64, i::Blocked; pa = ()) where F<:Function\n\nPlate over blocked variables.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.plate-Union{Tuple{F}, Tuple{Trace, F, Any, Any, Int64, Nonstandard}} where F<:Function","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.plate","text":"function plate(t::Trace, op::F, a, d, s::Int64, i::Nonstandard; pa = ()) where F<:Function\n\nPlate over latent variables.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.plate-Union{Tuple{F}, Tuple{Trace, F, Any, Any, Int64, Replayed}} where F<:Function","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.plate","text":"function plate(t::Trace, op::F, a, d, s::Int64, i::Replayed; pa = ()) where F<:Function\n\nPlate over replayed variables. Note that this method assumes and does not check that the value to be replayed v satisfies length(v) == s.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.plate-Union{Tuple{F}, Tuple{Trace, F, Any, Any, Int64}} where F<:Function","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.plate","text":"function plate(t::Trace, op::F, a, d, s::Int64; pa = ()) where F<:Function\n\nSample or observe a vector of random variables at a single site instead of multiple. This can speed up inference since the number of sites in the model will no longer scale with dataset size (though numerical value computation is still linear in dataset size).\n\nExample usage: instead of\n\nvals = [sample(t, \"val $i\", Geometric()) for i in 1:N]\n\nwe can write \n\nvals = plate(t, sample, \"val\", Geometric(), N)\n\nMathematically, this is equivalent to the product p(z) = prod_n p(z_n) and treating it as the single object p(z) instead of the N objects p(z_n).\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.plate-Union{Tuple{F}, Tuple{T}, Tuple{Trace, F, Any, Any, Vector{T}, Any}} where {T, F<:Function}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.plate","text":"function plate(t::Trace, op::F, a, d, v::Vector{T}, params; pa = ()) where {T, F<:Function}\n\nPlate over observed variables with different values but identical distribution, i.e., p(xz) = prod_n p(x_n  z_n). This is as opposed to plate(t::Trace, op::F, a, d, v::Vector{T}; pa = ()), which is equivalent to p(xz) = prod_n p(x_n  z).\n\nparams must have the same length as v. Each element of params corresponds to a vector of that  particular component of the params, i.e., z = (z_1  z_D) where each z_d has length N, the number of observed datapoints, and D is the cardinality of the parameterization of the  distribution.\n\nE.g., replace \n\nlocs = sample(t, \"locs\", MvNormal(D, 1.0))\nfor (i, (loc, d)) in enumerate(zip(locs, data))\n    observe(t, \"data $i\", Normal(loc, 1.0), d)\nend\n\nwith \n\nlocs = sample(t, \"locs\", MvNormal(D, 1.0))\nplate(t, observe, \"data\", Normal, data, (locs, ones(D)))\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.plate-Union{Tuple{F}, Tuple{T}, Tuple{Trace, F, Any, Any, Vector{T}}} where {T, F<:Function}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.plate","text":"function plate(t::Trace, op::F, a, d, v::Vector{T}; pa = ()) where {T, F<:Function}\n\nPlate over observed variables, i.e., a plated component of model likelihood. v is the  vector of observations, while op is likely observe.\n\nExample usage: instead of\n\nfor (i, d) in enumerate(data)\n    observe(t, \"data $i\", Normal(loc, scale), d)\nend\n\nwe can write \n\nplate(t, observe, \"data\", Normal(loc, scale), data)\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.propose-Tuple{Trace, Any, Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.propose","text":"propose(t :: Trace, a, d)\n\nPropose a value for the address a in trace t from the distribution d.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, CrimsonSkyline.Blocked}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(t :: Trace, a, d, params, i :: Blocked; pa = ())\n\nSamples from d passing the optional arguments params, deletes the node stored at address a from trace t, and returns the sampled value. \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, Deterministic}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(t :: Trace, a, f, v, i :: Deterministic; pa = ())\n\nCreates a deterministic node mapping the tuple of data v through function f,  storing the value in trace t at address a.\n\nMaps tuple of data v through function f, yielding r = f(v...)\nCreates a deterministic node and stores it in t at address a\nOptionally adds nodes corresponding to the addresses in pa as parent nodes\nReturns r\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, Nonstandard}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(t :: Trace, a, d, params, i :: Nonstandard; pa = ())\n\nSamples from distribution d into trace t at address a.\n\nSamples a value from d passing the optional arguments params\nCreates a sample node\nAdds the sample node to trace t at value a\nOptionally adds nodes corresponding to the addresses in pa as parent nodes\nReturns the sampled value\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, Replayed}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(t :: Trace, a, d, params, i :: Replayed; pa = ())\n\nReplays the sampled node through the trace. \n\nIf a is not in t's address set, calls sample(t, a, d, NONSTANDARD; pa = pa). \nCreates a sample node that copies the value from the last node stored in the trace at address a. \nAdds the sample node to trace t at value a\nOptionally adds nodes corresponding to the addresses in pa as parent nodes\nResets the node's interpretation to the original interpretation\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, Standard}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(t :: Trace, a, d, s, i :: Standard; pa = ())\n\nScores an observed value s against the distribution d, storing the value in trace t at  address a and optionally adds nodes corresponding to the addresses in pa as parent nodes.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any, Vector{Interpretation}}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(t :: Trace, a, d, params, ii :: Array{Interpretation, 1}; pa = ())\n\nSequentially apply sample statements with interpretations as given in ii. This is  used to depth-first traverse the interpretation graph.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(t :: Trace, a, d, params; pa = ())\n\nIf a is in the set of trace addresses, calls sample using t[a]'s interpretation.  Otherwise, calls sample using nonstandard interpretation. \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Tuple{Trace, Any, Any, CrimsonSkyline.Blocked}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(t :: Trace, a, d, i :: Blocked; pa = ())\n\nSamples from d, deletes the node stored at address a from trace t, and returns the  sampled value. \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Nonstandard}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(t :: Trace, a, d, i :: Nonstandard; pa = ())\n\nSamples from distribution d into trace t at address a.\n\nSamples a value from d\nCreates a sample node\nAdds the sample node to trace t at value a\nOptionally adds nodes corresponding to the addresses in pa as parent nodes\nReturns the sampled value\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Replayed}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(t :: Trace, a, d, i :: Replayed; pa = ())\n\nReplays the sampled node through the trace. \n\nIf a is not in t's address set, calls sample(t, a, d, NONSTANDARD; pa = pa). \nCreates a sample node that copies the value from the last node stored in the trace at address a. \nAdds the sample node to trace t at value a\nOptionally adds nodes corresponding to the addresses in pa as parent nodes\nResets the node's interpretation to the original interpretation\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Union{Conditioned, Standard}}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(t :: Trace, a, d, i :: Union{Standard,Conditioned}; pa = ())\n\nScores an observed value against the distribution d, storing the value in trace t at  address a and optionally adds nodes corresponding to the addresses in pa as parent nodes.\n\nThis method is used by the condition effect. It will probably not be used by most  users.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Tuple{Trace, Any, Any, Vector{Interpretation}}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(t :: Trace, a, d, ii :: Array{Interpretation, 1}; pa = ())\n\nSequentially apply sample statements with interpretations as given in ii. This is  used to depth-first traverse the interpretation graph.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Tuple{Trace, Any, Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(t :: Trace, a, d; pa = ())\n\nIf a is in the set of trace addresses, calls sample using t[a]'s interpretation.  Otherwise, calls sample using nonstandard interpretation. \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.trace-Tuple{Any, Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.trace","text":"trace(A, T)\n\nThis is the recommended way to construct a new typed trace. A is the address type, T is the value type.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.trace-Tuple{}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.trace","text":"trace()\n\nThis is the recommended way to construct a new trace.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.transform-Union{Tuple{F}, Tuple{Trace, Any, F, Any}} where F<:Function","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.transform","text":"function transform(t :: Trace, a, f :: F, v; pa = ()) where F <: Function\n\nAlias for sample(t, a, f, v, DETERMINISTIC; pa = pa).\n\n\n\n\n\n","category":"method"},{"location":"#field","page":"CrimsonSkyline.jl","title":"field","text":"","category":"section"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"CrimsonSkyline also includes methods for sampling from undirected models.","category":"page"},{"location":"#Using-Metropolis-Hastings","page":"CrimsonSkyline.jl","title":"Using Metropolis-Hastings","text":"","category":"section"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Here is an example (taken directly from the tests!). Suppose we have three variables a, b, and c,  with field structure a - b - c  and continuous factors  psi_ab(a b) = mathrmMvNormal(0 Sigma_ab) with Sigma_ab = beginpmatrix 10  05  05  10 endpmatrix and psi_bc(b c) = mathrmMvNormal(beginpmatrix 20  20 endpmatrix Sigma_bc) with  Sigma_bc = beginpmatrix 20  -10  -10  20 endpmatrix. We can construct the factors using two ordinary functions:","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"factor_ab(x) = logpdf(MvNormal(PDMat([1.0 0.5; 0.5 1.0])), x)\nfactor_bc(x) = logpdf(MvNormal([2.0, 2.0], PDMat([2.0 -1.0; -1.0 2.0])), x)","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Suppose that we observe the data b = 3.0.  We can instantiate the RandomField object with the factors and this evidence as follows:","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"factors = Dict([\"a\", \"b\"] => factor_ab, [\"b\", \"c\"] => factor_bc)\nevidence = Dict(\"b\" => 3.0)\nfield = RandomField(factors, evidence)","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"In general one cannot sample from random fields directly and instead must use a method  such as belief propagation or approximate inference methods.  Here we use Metropolis Hastings. We define a proposal kernel that can (a) propose new values and (b) score those values in comparison with old sampled values.  This functionality can be implemented as a function, but we will implement a struct to capture some proposal kernel state (namely, the standard deviation of a  proposal distribution).  We define the proposal kernel as follows:","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"struct FactorProposal\n    addresses :: Vector{String}\n    last :: Vector{String}\n    std :: Float64\nend\nFactorProposal(addresses) = FactorProposal(addresses, [addresses[1]], 0.5)\nfunction (fp::FactorProposal)(x::Dict)\n    new = deepcopy(x)\n    address = rand(fp.addresses)\n    new[address] = randn() * fp.std + new[address]\n    fp.last[1] = address\n    new\nend\nfunction (fp::FactorProposal)(x_prime::Dict, x::Dict)\n    address = fp.last[1]\n    logpdf(Normal(x[address], fp.std), x_prime[address]) - log(length(fp.addresses))\nend","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"This is pretty straighforward: calling fp(x) generates a proposal x_prime i.e., x sim q(x) (which in this case is just a random walk step away from the  current point) and calling fp(x_prime, x) computes the transition  probability q(x  x).  Once we have the proposal in hand, we can sample from the posterior  p(a c  b = 30) by calling mh(...) just as in the case of trace-based models:","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"addresses = [\"a\", \"c\"]\nproposal = FactorProposal(addresses)\ninitial_values = Dict(\"a\" => 0.0, \"b\" => 3.0, \"c\" => 0.0)\nsamples = mh(field, [proposal], initial_values; burn=1000, thin=100, num_iterations=11000)","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Because RandomFields aren't generative models, we have to seed the MH algorithm with an  initial value for each address. (In this case, the value used to seed \"b\" isn't used  by mh because we've posted evidence to that address; if we just wanted to sample from  p(a b c) without posting evidence, the initiaizer \"b\" => 3.0 would be used.) We can visualize the marginal posteriors p(ab=30) and p(c  b = 30) below (using the built-in plot_marginal): (Image: marginal factor a) (Image: marginal factor c)","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"In combination with a proposal kernel and MH initialization point, random fields can be used in CrimsonSkyline's trace-based PPL. There is convenience wrapper  to bundle these components together called GenerativeField. Here is an example of using it in the trace-based PPL:","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"t = trace()\nupstream_value = sample(t, \"a\", Normal())\n# to pass upstream values as parameters to the random field\n# just post them as evidence\nfield = RandomField(factors, Dict(\"a\" => upstream_value))\nproposal = FactorProposal([\"b\", \"c\"])\ninit = Dict(\"a\" => 0.0, \"b\" => 0.0, \"c\" => 0.0)\ngf = GenerativeField(field, proposal, init)\nsample(t, \"field\", gf)","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Modules = [CrimsonSkyline]\nPages = [\"modeling/field.jl\"]","category":"page"},{"location":"#CrimsonSkyline.GenerativeField","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.GenerativeField","text":"struct GenerativeField{T}\n    field::RandomField\n    proposal::T\n    val::Dict\n    ...\nend\n\nA generative field is a three-tuple of a random field field, a proposal kernel proposal, and an initialization value val used to start MH sampling. \n\n\n\n\n\n","category":"type"},{"location":"#CrimsonSkyline.RandomField","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.RandomField","text":"struct RandomField \n    names::Set{String}\n    factors::Dict{Vector{String},Function}\n    evidence::Dict{String,Any}\nend\n\nA representation of a random field by a collection of factors:  log p(x) = sum_f in mathcal F log psi_f(x_f), where  mathcal F is the set of (log) factors and x_f is the set of variables incident on that (log) factor. factors should be properly normalized log mass or density functions. There is no restriction on the state space of the variables involved as long as the factor functions can evaluate the log probability of the variables. For example, \n\nfactor_ab(x) = logpdf(MvNormal(PDMat([1.0 0.5; 0.5 1.0])), x)\nfactor_bc(x) = logpdf(MvNormal([2.0, 2.0], PDMat([2.0 -1.0; -1.0 2.0])), x)\n\nare two valid (log) factor functions – the first corresponding to the factor log psi_ab(x_ax_b) and the second corresponding to the factor log psi_bc(x_b x_c). Posting evidence is done using a dictionary mapping an address to value,  e.g., evidence = Dict(\"b\" => 3.0).\n\nCalling a random field corresponds to evaluating its log probability with the passed argument, e.g., \n\nmy_rf = RandomField(...)\nx = Dict(\"a\" => 1.0, \"b\" => -2.1)\nmy_lp = my_rf(x)  # corresponds to logprob(my_rf, x)\n\n\n\n\n\n","category":"type"},{"location":"#CrimsonSkyline.RandomField-Tuple{Dict{Vector{String}, Function}, Dict}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.RandomField","text":"function RandomField(factors::Dict{Vector{String},Function}, evidence::Dict)\n\nOuter constructor for RandomField that requires a dict of factors and allows posting evidence when the field is created (instead of manually doing so later).\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.RandomField-Tuple{Dict{Vector{String}, Function}}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.RandomField","text":"function RandomField(factors::Dict{Vector{String},Function})\n\nOuter constuctor for RandomField that requires only a dict of factors.\n\n\n\n\n\n","category":"method"},{"location":"#Base.rand-Tuple{GenerativeField}","page":"CrimsonSkyline.jl","title":"Base.rand","text":"function Distributions.rand(gf::GenerativeField; num_iterations=2500)\n\nSample from a generative fied using num_iterations of MH sampling. The value generated by MH at the end of num_iterations of sampling is returned. To customize burn-in, you can just overload this function, e.g. rand(gf::GenerativeField) = rand(gf; num_iterations=10000).\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.logprob-Tuple{RandomField, Dict}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.logprob","text":"function logprob(rf::RandomField, x::Dict)\n\nEvaluates the log probability of a set of values against the density described by the random field rf. The values x should have the format address => value.\n\n\n\n\n\n","category":"method"},{"location":"#io","page":"CrimsonSkyline.jl","title":"io","text":"","category":"section"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Saving and loading traces and SamplingResults is possible using the save and load functions. This functionality depends on JuliaDB. ","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Examples: ","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"# simple example model\nfunction io_model(t::Trace, dim::Int64, data::Int64)\n    z = sample(t, \"z\", Dirichlet(ones(dim)))\n    observe(t, \"x\", Categorical(z), data)\nend\n\n# saving a trace\nt = trace()\ndim = 10\ndata = 7\nio_model(t, dim, data)\ntestpath = joinpath(@__DIR__, \"TESTIO\")\ndb_file = joinpath(testpath, \"test.jdb\")\nsave(t, db_file)\n\n# loading a trace\nloaded_trace = load(db_file)\n\n# creating and saving some results\nresults = mh(io_model; params = (dim, data), burn = 0, thin = 1, num_iterations=10)\nresults_file = joinpath(testpath, \"io_model.csm\")\nsave(results, results_file)\n\n# loading saved results and use to serve model\nloaded_results = load(joinpath(testpath, \"io_model.csm\"))\nupdated_model = update(io_model, loaded_results)  # update effect, see effects.jl\nnew_t, _ = updated_model(trace(), dim, data)","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Modules = [CrimsonSkyline]\nPages = [\"representation/io.jl\"]","category":"page"},{"location":"#CrimsonSkyline.load-Tuple{Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.load","text":"function load(f)\n\nLoad a Trace or SamplingResults object from file. The file must be saved in JuliaDB format with ending .jdb, which will be interpreted as a single saved trace, or must be a directory with ending .csm, which will be interpreted as a SamplingResults object.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.load_csm-Tuple{Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.load_csm","text":"function load_csm(f) :: SamplingResults\n\nLoads a SamplingResults from a directory. The directory contains metadata.txt, which currently stores the interpretation of the SamplingResults (i.e., what kind of  algorithm generated those results), and a file results.jdb, which is a JuliaDB table of the results.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.load_jdb-Tuple{Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.load_jdb","text":"function load_jdb(f) :: Trace\n\nLoads a serialized juliadb table from file f and converts it into a trace.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.save-Tuple{CrimsonSkyline.SamplingResults, Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.save","text":"function save(r :: SamplingResults, f)\n\nSaves a SamplingResults to disk in the directory f.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.save-Tuple{Trace, Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.save","text":"function save(t :: Trace, f)\n\nSaves a trace to disk at the filepath f.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.to_table-Tuple{Trace}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.to_table","text":"function to_table(t :: Trace)\n\nTurns a trace into a juliadb table. Does not store parent / child relationships.\n\n\n\n\n\n","category":"method"},{"location":"#effects","page":"CrimsonSkyline.jl","title":"effects","text":"","category":"section"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"A library of functions that change the interpretation of some or all nodes in a trace.","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Modules = [CrimsonSkyline]\nPages = [\"modeling/effects.jl\"]","category":"page"},{"location":"#CrimsonSkyline.block-Tuple{Any, Trace}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.block","text":"block(f :: F, t :: Trace) where F <: Function\n\nConverts all traced randomness into untraced randomness.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.block-Union{Tuple{T}, Tuple{Any, T, Any}} where T<:Trace","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.block","text":"function block(f, t :: T, addresses) where T <: Trace\n\nGiven a stochastic function f, a trace t, and an iterable of addresses, converts traced randomness into untraced randomness. \n\nReturns a tuple (t_new, g), where t_new is a trace and g is a function. The function signature of g is the same as that of f with the first argument removed; that is, if f(t :: Trace, params...), then g(params...). Computation is delayed, so each of  the latent nodes in t_new has interpretation = BLOCKED. Calling g(params...) executes the  computation and each latent node in t_new with an address in addresses is removed.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.condition-Tuple{Any, Dict}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.condition","text":"function condition(f, evidence :: Dict)\n\nCondition a trace modified by f on evidence, which maps addresses to observed  evidence associated with that address. Returns a function with call signature  identical to that of f and return signature (t :: Trace, rtype) where rtype is the return type of f.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.replace-Tuple{Any, Dict}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.replace","text":"function replace(f, r :: Dict)\n\nGiven a mapping r from addresses to distribution-like (currently Distributions or Array{Any, 1}s), replaces the current distributions at that set of addresses with this set of distributions. Returns a function g that has return signature  (t :: Trace, rval) where rval is a return value of f.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.replace-Union{Tuple{T}, Tuple{T, Dict}} where T<:Trace","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.replace","text":"function replace(t :: Trace, r :: Dict)\n\nGiven a mapping r from addresses to distribution-like (currently Distributions or Array{Any, 1}s), replaces the current distributions at that set of addresses with this set of distributions. Returns the modified trace.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.replay-Union{Tuple{T}, Tuple{Any, T}} where T<:Trace","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.replay","text":"function replay(f, t :: T) where T <: Trace\n\nGiven a stochastic function f and a trace t, makes sample calls behave as though  they had sampled the values in t at the corresponding addresses. \n\nReturns a tuple (t_new, g), where t_new is a trace and g is a function. The function signature of g is the same as that of f with the first argument removed; that is, if f(t :: Trace, params...), then g(params...). Computation is delayed, so each of the latent nodes in t_new has interpretation = REPLAYED. Calling g(params...) executes the computation and each latent node in t_new reverts to  its original interpretation. \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.rewrite-Union{Tuple{T}, Tuple{Any, T, Dict}} where T<:Trace","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.rewrite","text":"function rewrite(f, t :: T, r :: Dict) where T <: Trace\n\nRewrites the history of the trace to make it appear as if the values in the trace were sampled at the addresses in the keys of r from the corresponding distributions in the values of r.  Returns a function with call signature g(params...) that returns (t :: Trace, rval), where rval  is the return type of f. \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.update-Union{Tuple{I}, Tuple{Any, CrimsonSkyline.SamplingResults{I}}} where I<:CrimsonSkyline.InferenceType","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.update","text":"function update(f, r :: SamplingResults{I}) where I <: InferenceType\n\nGiven a stochastic function f and a SamplingResults r, update the prior  predictive to the posterior predictive by jointly replacing all latent sample sites with the joint empirical  posterior. Returns a stochastic function g with the same call signature as f. This function will modify in  place the trace passed into it as the first argument.\n\n\n\n\n\n","category":"method"},{"location":"#basic-sampling-methods","page":"CrimsonSkyline.jl","title":"basic sampling methods","text":"","category":"section"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Simple samplers such as forward and rejection sampling can be done \"by hand\", but convenience methods are implemented to facilitate postprocessing of results.","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Modules = [CrimsonSkyline]\nPages = [\"inference/forward.jl\",\"inference/rejection.jl\"]","category":"page"},{"location":"#CrimsonSkyline.forward_sampling-Tuple{Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.forward_sampling","text":"function forward_sampling(f; params = (), num_iterations = 1)\n\nDraws samples from the model's joint density. Equivalent to calling f in a loop num_iterations times, but results are collected in a  NonparametricSamplingResults for easier postprocessing.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.rejection-Tuple{Any, Float64, Vararg{Any, N} where N}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.rejection","text":"function rejection(f, log_l :: Float64, params...)\n\nSamples from the prior with the hard likelihood constraint log L_k  log_l.\n\nArgs:\n\nf stochastic function. Must have signature f(t :: Trace, params...)\nlog_l: current log likelihood threshold \nparams: any additional arguments to pass to f\n\n\n\n\n\n","category":"method"},{"location":"#importance","page":"CrimsonSkyline.jl","title":"importance","text":"","category":"section"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Importance sampling algorithms and utilities.  Currently the following importance sampling algorithms are implemented:","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Likelihood weighting\nGeneric user-defined proposal","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Modules = [CrimsonSkyline]\nPages = [\"inference/importance.jl\"]","category":"page"},{"location":"#CrimsonSkyline.importance_sampling-Tuple{Any, Any, Tuple{DataType, DataType}}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.importance_sampling","text":"function importance_sampling(f, q, types::Tuple{DataType,DataType}; params = (), nsamples :: Int = 1)\n\nGiven a stochastic function f, a proposal function q, and a tuple of params to pass to f and q, compute nsamples iterations of importance sampling. q must have the same input signature  as f. Returns a SamplingResults instance.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.importance_sampling-Tuple{Any, Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.importance_sampling","text":"function importance_sampling(f, q; params = (), nsamples :: Int = 1)\n\nGiven a stochastic function f, a proposal function q, and a tuple of params to pass to f and q, compute nsamples iterations of importance sampling. q must have the same input signature  as f. Returns a SamplingResults instance.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.is_step-Tuple{Any, Any, Tuple{DataType, DataType}}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.is_step","text":"function is_step(f, q, types::Tuple{DataType,DataType}; params = ())\n\nPerform one step of importance sampling – draw a single sample from the proposal q, replay  it through f, and record the log weight as log W_n = log p(x z_n) - log q(z_n). Returns a tuple (log weight, rval, trace). \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.is_step-Tuple{Any, Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.is_step","text":"function is_step(f, q; params = ())\n\nPerform one step of importance sampling – draw a single sample from the proposal q, replay  it through f, and record the log weight as log W_n = log p(x z_n) - log q(z_n). Returns a tuple (log weight, rval, trace). \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.likelihood_weighting-Tuple{Any, Tuple{DataType, DataType}, Vararg{Any, N} where N}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.likelihood_weighting","text":"function likelihood_weighting(f, types::Tuple{DataType, DataType}, params...; nsamples :: Int = 1)\n\nGiven a stochastic function f and arguments to the function params..., executes nsamples iterations of importance sampling by using the prior as a proposal distribution. The importance weights are given by log W_n = ell(t_n). Returns an SamplingResults instance. \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.likelihood_weighting-Tuple{Any, Vararg{Any, N} where N}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.likelihood_weighting","text":"function likelihood_weighting(f, params...; nsamples :: Int = 1)\n\nGiven a stochastic function f and arguments to the function params..., executes nsamples iterations of importance sampling by using the prior as a proposal distribution. The importance weights are given by log W_n = ell(t_n). Returns an SamplingResults instance. \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.likelihood_weighting_results-Tuple{}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.likelihood_weighting_results","text":"likelihood_weighting_results()\n\nOuter constructor for SamplingResults.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.log_evidence-Union{Tuple{CrimsonSkyline.SamplingResults{I}}, Tuple{I}} where I<:CrimsonSkyline.Importance","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.log_evidence","text":"function log_evidence(r :: SamplingResults{LikelihoodWeighting})\n\nComputes the log evidence (log partition function), \n\nlog Z equiv log p(x) approx -log N_textsamples + log sum_n=1^N_textsamples W_n\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.lw_step-Tuple{Any, Tuple{DataType, DataType}, Vararg{Any, N} where N}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.lw_step","text":"function lw_step(f, types::Tuple{DataType, DataType}, params...)\n\nPerform one step of likelihood weighting – draw a single proposal from the prior and compute  the log weight as equal to the likelihood. Returns a tuple (log weight, rval, trace).\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.lw_step-Tuple{Any, Vararg{Any, N} where N}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.lw_step","text":"function lw_step(f, params...)\n\nPerform one step of likelihood weighting – draw a single proposal from the prior and compute  the log weight as equal to the likelihood. Returns a tuple (log weight, rval, trace).\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.normalized_weights-Union{Tuple{CrimsonSkyline.SamplingResults{I}}, Tuple{I}} where I<:CrimsonSkyline.Importance","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.normalized_weights","text":"function normalized_weights(r :: SamplingResults{LikelihoodWeighting})\n\nComputes the normalized weights w_n from unnormalized weights W_n:\n\nw_n = W_n  p(x) = expell(t_n) - log Z\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Union{Tuple{I}, Tuple{CrimsonSkyline.SamplingResults{I}, Any, Int64}} where I<:CrimsonSkyline.Importance","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(r :: SamplingResults{LikelihoodWeighting}, k, n :: Int)\n\nDraws n samples from the empirical marginal posterior at address k.\n\n\n\n\n\n","category":"method"},{"location":"#metropolis","page":"CrimsonSkyline.jl","title":"metropolis","text":"","category":"section"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Metropolis algorithm and utilities. Currently the following algorithms are implemented for both  FOPPL and HOPPL programs:","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Independent prior proposal\nArbitrary single- or multi-site proposal","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Here are two examples of inference using the arbitrary MH step interface. Consider the following generative function:","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"function normal_model(t :: Trace, data :: Vector{Float64})\n    loc = sample(t, :loc, Normal(0.0, 10.0))\n    scale = sample(t, :scale, LogNormal())\n    for i in 1:length(data)\n        observe(t, (:obs, i), Normal(loc, scale), data[i])\n    end\nend","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"To learn an approximate posterior for :loc and :scale, we will introduce two proposal kernels:","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"loc_proposal(old_t :: Trace, new_t :: Trace, data) = propose(new_t, :loc, Normal(old_t[:loc].value, 0.25))\nscale_proposal(old_t :: Trace, new_t :: Trace, data) = propose(new_t, :scale, truncated(Normal(old_t[:scale].value, 0.25), 0.0, Inf))","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Note that while loc_proposal is symmetric, scale_proposal is not. To perform inference, we pass these kernels to mh_step in  a loop after first drawing a random trace:","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"t = trace()\nnormal_model(t, data)\nfor i in 1:niter\n    t = mh_step(t, normal_model, loc_proposal; params = (data,))\n    t = mh_step(t, normal_model, scale_proposal; params = (data,))\nend","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"In this case, inference was fairly successful:","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"[ Info: True loc = 4.0\n[ Info: True std = 1.0\n[ Info: inferred E[loc] = 4.022688081613082\n[ Info: inferred E[scale] = 0.9696559373495869\n[ Info: approximate p(x) = sum_z p(x|z) = -138.63530736205144","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"As a less trivial (but still contrived!) inference example, we can infer the posterior distribution of a latent discrete random variable in an open-universe model: ","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"function random_sum_model(t :: Trace, data)\n    n = sample(t, :n, Geometric(0.1))\n    loc = 0.0\n    for i in 1:(n + 1)\n        loc += sample(t, (:loc, i), Normal())\n    end\n    obs = Array{Float64, 1}()\n    for j in 1:length(data)\n        o = observe(t, (:data, j), Normal(loc, 1.0), data[j])\n        push!(obs, o)\n    end\n    obs\nend","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"(N.B.: we write the model is this form for pedagogic reasons; there is a far more efficient way to express the latent structure  of this model, namely n sim textGeometric(01), textloc sim textNormal(0 n).) We are interested in learning the posterior distribution of :n. We introduce two proposal distributions, one for the latent discrete rv and another generic proposal for the location increments:","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"function random_n_proposal(old_trace, new_trace, params...)\n    old_n = float(old_trace[:n].value)\n    if old_n > 0\n        propose(new_trace, :n, Poisson(old_n))\n    else\n        propose(new_trace, :n, Poisson(1.0))\n    end\nend\n\ngen_loc_proposal(old_trace, new_trace, ix, params...) = propose(new_trace, (:loc, ix), Normal(old_trace[(:loc, ix)].value, 0.25))","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"We again conduct inference by simply applying proposals within a loop. This time, the number of location increment proposals we need to  construct is dependent on the sampled values of the latent random variable. We can either create these proposals on the fly as they're  needed or create what is nearly guaranteed to be enough of them before any inference is performed, e.g.,  loc_proposals = [(o, n, params...) -> gen_loc_proposal(o, n, i, params...) for i in 1:100]. Now that we have what we need, we can conduct inference:","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"t = trace()\nrandom_sum_model(t, data)\n...\nfor i in 1:niter\n    t = mh_step(t, random_sum_model, random_n_proposal; params=(data,))\n    for j in 1:(t[:n].value + 1)\n        t = mh_step(t, random_sum_model, loc_proposals[j]; params=(data,))\n    end\n    push!(ns, t[:n].value)\nend","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Our inference results look promising:","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"[ Info: True :n = 9\n[ Info: Posterior E[:n] = 7.581604598850287","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"For more examples, check back soon.","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Modules = [CrimsonSkyline]\nPages = [\"inference/metropolis.jl\"]","category":"page"},{"location":"#CrimsonSkyline.accept-Tuple{Trace, Trace, Float64}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.accept","text":"function accept(t :: Trace, new_t :: Trace, log_a :: Float64)\n\nStochastic function that either returns new_t if accepted or returns t if not accepted.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.copy_common!-Tuple{Trace, Trace}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.copy_common!","text":"function copy_common!(old_t :: Trace, new_t :: Trace)\n\nCopies nodes from old_t into new_t for all addresses in the intersection of their address sets. \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.log_acceptance_ratio-Tuple{Trace, Trace, CrimsonSkyline.Prior}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.log_acceptance_ratio","text":"function log_acceptance_ratio(t :: Trace, t_proposed :: Trace, p :: Prior)\n\nComputes the log acceptance ratio of a Metropolis step when using the independent prior proposal  algorithm:\n\nlog alpha = ell(t_textproposed) - ell(t_textoriginal)\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.loglatent-Tuple{Trace}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.loglatent","text":"function loglatent(t :: Trace)\n\nComputes the joint log probability of all latent variables in a trace, log p(t) - ell(t).\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.logprob-Tuple{Trace, Trace}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.logprob","text":"function logprob(t0 :: Trace, t1 :: Trace)\n\nComputes the proposal log probability q(t_1  t_0).\n\nThis expression has two parts: log probability that is generated at the proposed site(s), and  log probability that is generated at the sites that are present in t1 but not in t0. \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.mh-Tuple{Any, Tuple{DataType, DataType}}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.mh","text":"function mh(f, types::Tuple{DataType, DataType}; params = (), burn = 1000, thin = 50, num_iterations = 10000)\n\nGeneric Metropolis algorithm using draws from the prior.\n\nArgs:\n\nf: stochastic function. Must have call signature f(t :: Trace, params...)\nparams: addditional arguments to pass to f and each of the proposal kernels.\nburn: number of samples to discard at beginning of markov chain\nthin: keep only every thin-th draw. E.g., if thin = 100, only every 100-th trace will be kept.\nnum_iterations: total number of steps to take in the markov chain\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.mh-Tuple{Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.mh","text":"function mh(f; params = (), burn = 1000, thin = 50, num_iterations = 10000)\n\nGeneric Metropolis algorithm using draws from the prior.\n\nArgs:\n\nf: stochastic function. Must have call signature f(t :: Trace, params...)\nparams: addditional arguments to pass to f and each of the proposal kernels.\nburn: number of samples to discard at beginning of markov chain\nthin: keep only every thin-th draw. E.g., if thin = 100, only every 100-th trace will be kept.\nnum_iterations: total number of steps to take in the markov chain\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.mh-Union{Tuple{A}, Tuple{Any, A, Any}} where A<:AbstractArray","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.mh","text":"function mh(f, qs :: A, addresses; params = (), burn = 100, thin = 10, num_iterations = 10000, inverse_verbosity = 100) where A <: AbstractArray\n\nGeneric Metropolis algorithm using user-defined proposal kernels, returning only a requested subset of  addresses. \n\nArgs:\n\nf: stochastic function. Must have call signature f(t :: Trace, params...)\nqs: array-like of proposal kernels. Proposal kernels are applied sequentially in the order that they appear in this array.   Proposal kernels must have the signature q(old_t :: Trace, new_t :: Trace, params...) where it must take in at least the same number of arguments   in params as f.\naddresses: only values sampled at these addresses will be saved in the values field of the   BareResults struct returned.\nparams: addditional arguments to pass to f and each of the proposal kernels.\nburn: number of samples to discard at beginning of markov chain\nthin: keep only every thin-th draw. E.g., if thin = 100, only every 100-th trace will be kept.\nnum_iterations: total number of steps to take in the markov chain\ninverse_verbosity: every inverse_verbosity iterations, a stattus report will be logged.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.mh-Union{Tuple{A}, Tuple{Any, A, Tuple{DataType, DataType}}} where A<:AbstractArray","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.mh","text":"function mh(f, qs :: A, types::Tuple{DataType,DataType}; params = (), burn = 100, thin = 10, num_iterations = 10000, inverse_verbosity = 100) where A <: AbstractArray\n\nGeneric Metropolis algorithm using user-defined proposal kernels.\n\nArgs:\n\nf: stochastic function. Must have call signature f(t :: Trace, params...)\nqs: array-like of proposal kernels. Proposal kernels are applied sequentially in the order that they appear in this array.   Proposal kernels must have the signature q(old_t :: Trace, new_t :: Trace, params...) where it must take in at least the same number of arguments   in params as f.\nparams: addditional arguments to pass to f and each of the proposal kernels.\nburn: number of samples to discard at beginning of markov chain\nthin: keep only every thin-th draw. E.g., if thin = 100, only every 100-th trace will be kept.\nnum_iterations: total number of steps to take in the markov chain\ninverse_verbosity: every inverse_verbosity iterations, a stattus report will be logged.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.mh-Union{Tuple{A}, Tuple{Any, A}} where A<:AbstractArray","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.mh","text":"function mh(f, qs :: A; params = (), burn = 100, thin = 10, num_iterations = 10000, inverse_verbosity = 100) where A <: AbstractArray\n\nGeneric Metropolis algorithm using user-defined proposal kernels.\n\nArgs:\n\nf: stochastic function. Must have call signature f(t :: Trace, params...)\nqs: array-like of proposal kernels. Proposal kernels are applied sequentially in the order that they appear in this array.   Proposal kernels must have the signature q(old_t :: Trace, new_t :: Trace, params...) where it must take in at least the same number of arguments   in params as f.\nparams: addditional arguments to pass to f and each of the proposal kernels.\nburn: number of samples to discard at beginning of markov chain\nthin: keep only every thin-th draw. E.g., if thin = 100, only every 100-th trace will be kept.\nnum_iterations: total number of steps to take in the markov chain\ninverse_verbosity: every inverse_verbosity iterations, a stattus report will be logged.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.mh-Union{Tuple{T}, Tuple{RandomField, Vector{T}, Any}} where T","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.mh","text":"function mh(rf::RandomField, qs::Vector{T}, val; burn=1000, thin=100, num_iterations=11000) where T\n\nMetropolis Hastings algorithm for sampling from a random field using arbitrary proposal kernels.\n\nArgs: \n\nrf: the random field from which to sample\nqs: vector of proposal kernel callables; see documentation of mh_step for specification of proposal kernels\nval: initial guess with which to initialize MH, must be a dict with format address => value.\nburn: number of samples to discard at beginning of markov chain\nthin: keep only every thin-th draw. E.g., if thin = 100, only every 100-th trace will be kept.\nnum_iterations: total number of steps to take in the markov chain\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.mh_step-Tuple{RandomField, Any, Any, Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.mh_step","text":"function mh_step(rf::RandomField, q, x, log_prob_rf_x)\n\nA Metropolis step to sample from a random field using an arbitrary proposal kernel.\n\nArgs:\n\nrf: a RandomField from which to sample\nq: a proposal kernel. This must be a callable that satisfies the following   requirements:\nq(x) returns a new value x_prime that is generated using the input parameters   x, i.e., x sim q(xx). For example, q(x) = rand(Normal(x, 0.25))\nq(x_prime, x) scores (computes the log probability of) x_prime against x, i.e.,   computes log q(x  x)\nx: a dict with format address => value, the current sampled value.\nlog_prob_rf_x: the log probability of x under the random field.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.mh_step-Tuple{Trace, Any, Any, Tuple{DataType, DataType}}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.mh_step","text":"function mh_step(t :: Trace, f, q, types::Tuple{DataType,DataType}; params = (), return_val :: Bool = false)\n\nA generic Metropolis step using an arbitrary proposal kernel. \n\nGiven a trace t, a stochastic function f with signature f(t :: Trace, params...) a stochastic function  q with signature q(old_trace :: Trace, new_trace :: Trace, params...), generates a proposal from q and  accepts based on the log acceptance probability:\n\nlog alpha = log p(t_textnew) - log q(t_textnewt_textold) - log p(t_textold) - log q(t_textold  t_textnew)\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.mh_step-Tuple{Trace, Any, Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.mh_step","text":"function mh_step(t :: Trace, f, q; params = (), return_val :: Bool = false)\n\nA generic Metropolis step using an arbitrary proposal kernel. \n\nGiven a trace t, a stochastic function f with signature f(t :: Trace, params...) a stochastic function  q with signature q(old_trace :: Trace, new_trace :: Trace, params...), generates a proposal from q and  accepts based on the log acceptance probability:\n\nlog alpha = log p(t_textnew) - log q(t_textnewt_textold) - log p(t_textold) - log q(t_textold  t_textnew)\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.mh_step-Tuple{Trace, Any, Tuple{DataType, DataType}}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.mh_step","text":"function mh_step(t :: Trace, f, types::Tuple{DataType, DataType}; params = (), return_val :: Bool = false)\n\nAn independent prior sample Metropolis step.\n\nGiven a trace t and stochastic function f depending on params..., generates proposals  from prior draws and accepts based on the likelihood ratio.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.mh_step-Tuple{Trace, Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.mh_step","text":"function mh_step(t :: Trace, f; params = (), return_val :: Bool = false)\n\nAn independent prior sample Metropolis step.\n\nGiven a trace t and stochatic function f depending on params..., generates proposals  from prior draws and accepts based on the likelihood ratio.\n\n\n\n\n\n","category":"method"},{"location":"#nested","page":"CrimsonSkyline.jl","title":"nested","text":"","category":"section"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Modules = [CrimsonSkyline]\nPages = [\"inference/nested.jl\"]","category":"page"},{"location":"#CrimsonSkyline.nested-Tuple{Any, Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.nested","text":"function nested(f, replace_fn; params = (), num_points :: Int64 = 1)\n\nGeneric implementation of nested sampling (Skilling, Nested sampling for general Bayesian computation, Bayesian Analysis, 2006). The number of sampling iterations is a function of num_points aka N, and the empirical entropy of the sampling distribution, given at the n-th iteration by H_n approx sum_k hat p_k log hat p_k^-1, where hat p_k = L_k w_k  Z_k, L_k is the likelihood value, w_k is the difference in prior mass, and Z_k is the current estimate of the partition function. The number of sampling iterations is equal to min_n n  0 n  NH_n. \n\nArgs:\n\nf: stochastic function. Must have signature f(t :: Trace, params...)\nreplace_fn: function that returns a tuple (new_trace :: Trace, new_log_likelihood :: Float64). The input signature of this function   must be replace_fn(f :: F, log_likelihood :: Float64, params...) where F <: Function. It must guarantee that new_log_likelihood > log_likelihood.\nparams: any parameters to pass to f\nnum_points: the number of likelihood points to keep track of\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.nested-Tuple{Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.nested","text":"nested(f; params = (), num_points :: Int64 = 1)\n\nRun nested sampling using internal rejection method.\n\n\n\n\n\n","category":"method"},{"location":"#results","page":"CrimsonSkyline.jl","title":"results","text":"","category":"section"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Modules = [CrimsonSkyline]\nPages = [\"representation/results.jl\"]","category":"page"},{"location":"#CrimsonSkyline.NonparametricSamplingResults","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.NonparametricSamplingResults","text":"struct NonparametricSamplingResults{I} <: SamplingResults{I}\n    interpretation :: I\n    log_weights :: Array{Float64, 1}\n    return_values :: Array{Any, 1}\n    traces :: Array{Trace, 1}\nend\n\nWrapper for results of sampling. Implements the following methods  from Base: getindex, length, keys. Intepretation of log weights is dependent on I.\n\n\n\n\n\n","category":"type"},{"location":"#CrimsonSkyline.ParametricSamplingResults","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.ParametricSamplingResults","text":"struct ParametricSamplingResults{I} <: SamplingResults{I}\n    interpretation :: I\n    log_weights :: Array{Float64, 1}\n    return_values :: Array{Any, 1}\n    traces :: Array{Trace, 1}\n    distributions :: Dict\nend\n\ndistributions maps from addresses to distributions, a mapsto pi^(a)_psi(z), where  pi^(a)_psi(z) solves\n\nmax_psi E_z sim p(zx)log pi^(a)_psi(z)\n\nThe distributions are not used to generate values but only to score sampled values; values are  still sampled from the posterior traces. Right now, the parametric approximation is very simple: values with support over the  negative orthant of  mathbb R^D are approximated by (multivariate) normal distributions, while  values with support over only the positive orthant of mathbbR^D are approximated by  (multivariate) lognormal distributions. This behavior is expected to change in the future.\n\n\n\n\n\n","category":"type"},{"location":"#CrimsonSkyline.addresses-Union{Tuple{NonparametricSamplingResults{I}}, Tuple{I}} where I<:CrimsonSkyline.InferenceType","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.addresses","text":"function addresses(r::NonparametricSamplingResults{I}) where I <: InferenceType\n\nGet all addresses associated with the SamplingResults object, A = bigcup_tin texttracesmathcal A_t\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.addresses-Union{Tuple{ParametricSamplingResults{I}}, Tuple{I}} where I<:CrimsonSkyline.InferenceType","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.addresses","text":"function addresses(r::ParametricSamplingResults{I}) where I <: InferenceType\n\nGet all addresses associated with the SamplingResults object, A = bigcup_tin texttracesmathcal A_t\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Union{Tuple{I}, Tuple{Trace, Any, NonparametricSamplingResults{I}}} where I<:CrimsonSkyline.InferenceType","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(t :: Trace, a, r :: NonparametricSamplingResults{I}; pa = ()) where I <: InferenceType\n\nTreat a marginal site of a SamplingResults as a distribution, sampling from it into a trace.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.sample-Union{Tuple{I}, Tuple{Trace, Any, ParametricSamplingResults{I}}} where I<:CrimsonSkyline.InferenceType","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.sample","text":"function sample(t :: Trace, a, r::ParametricSamplingResults{I}; pa = ()) where I <: InferenceType\n\nTreat a marginal site of a SamplingResults as a distribution, sampling from it into a trace.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.to_parametric-Union{Tuple{NonparametricSamplingResults{I}}, Tuple{I}} where I<:CrimsonSkyline.InferenceType","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.to_parametric","text":"function to_parametric(r::NonparametricSamplingResults{I}) where I<:InferenceType\n\nConverts a nonparametric sampling results object into one that additionally contains a mapping from addresses to distributions. \n\n\n\n\n\n","category":"method"},{"location":"#Distributions.logpdf-Union{Tuple{A}, Tuple{A, Any}} where A<:AbstractArray","page":"CrimsonSkyline.jl","title":"Distributions.logpdf","text":"function Distributions.logpdf(r :: A, v) where A <: AbstractArray\n\nInterprets an array of objects as a delta distribution over those objects. If v is in the support set,  returns -log r. Otherwise, returns -infty. \n\n\n\n\n\n","category":"method"},{"location":"#statistics","page":"CrimsonSkyline.jl","title":"statistics","text":"","category":"section"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Modules = [CrimsonSkyline]\nPages = [\"representation/statistics.jl\"]","category":"page"},{"location":"#CrimsonSkyline.aic-Tuple{Trace}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.aic","text":"function aic(t :: Trace)\n\nComputes the Akaike Information Criterion for a single trace (thus replacing the definition) with  \"maximum likelihood\" by one with \"likelihood\". The formula is \n\ntextAIC(t)2 = textparams(t) - ell(t)\n\nwhere textparams(t) is the sum of the dimensionalities of non-observed  and non-deterministic sample nodes.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.aic-Union{Tuple{CrimsonSkyline.SamplingResults{I}}, Tuple{I}} where I<:CrimsonSkyline.InferenceType","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.aic","text":"function aic(r :: SamplingResults{I}) where I <: InferenceType\n\nComputes an empirical estimate of the Akaike Information Criterion from a SamplingResults. The formula is \n\ntextAIC(r)2 = min_t in texttraces(r)textparams(t) - hatell(t)\n\nwhere textparams(t) is the sum of the dimensionalities of non-observed  and non-deterministic sample nodes and hatell(t) is the empirical maximum likelihood.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.hpdi-Union{Tuple{T}, Tuple{I}, Tuple{CrimsonSkyline.SamplingResults{I}, Float64, AbstractArray{T, N} where N}} where {I<:CrimsonSkyline.InferenceType, T}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.hpdi","text":"function hpdi(r::SamplingResults{I}, pct::Float64, addresses::AbstractArray{T}) where {I <: InferenceType, T}\n\nComputes the highest posterior density interval(s) for a univariate variable. Does not check that the  data corresponding to each address in addresses is actually univariate; if in doubt, use hpds instead.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.hpds-Union{Tuple{I}, Tuple{CrimsonSkyline.SamplingResults{I}, Float64}} where I<:CrimsonSkyline.InferenceType","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.hpds","text":"function hpds(r::SamplingResults{I}, pct::Float64) where I <: InferenceType\n\nComputes the highest posterior density set (HPDS) of the SamplingResults object. Let mathcal T be the set of traces. The 100times Q -percentile HPDS is defined as the  set that satisfies sum_t in mathrmHPDS p(t) = Q and, for all t in mathrmHPDS, p(t)  p(s) for every s in mathcal T  - mathrmHPDS. It is possible to compute the HPDS using the full joint density p(t) equiv p(x z), where x is the  set of observed rvs and z is the set of latent rvs, since p(zx) propto p(x z). \n\npct should be a float in (0.0, 1.0). E.g., pct = 0.95 returns the 95% HPDS.\n\n\n\n\n\n","category":"method"},{"location":"#kernel","page":"CrimsonSkyline.jl","title":"kernel","text":"","category":"section"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"There are methods to automatically generate proposal kernels.","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Modules = [CrimsonSkyline]\nPages = [\"inference/kernel.jl\"]","category":"page"},{"location":"#CrimsonSkyline.make_kernel-Union{Tuple{D}, Tuple{N}, Tuple{Any, N, D}} where {N<:Node, D<:Distributions.Distribution{Distributions.Multivariate, Distributions.Continuous}}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.make_kernel","text":"function make_kernel(f, node::N, d::D) where {N<:Node, D<:ContinuousMultivariateDistribution}\n\nCreates a single site proposal kernel for node that has an associated continuous multivariate distribution.  Assumes that this site is unconstrained in mathbbR^N; using this method will result in inference runtime errors if the site is constrained. The resulting proposal kernel is a multivariate normal, z  z sim mathrmMultivariateNormal(z 1  sqrtD) where D is the dimensionality of the site. \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.make_kernel-Union{Tuple{D}, Tuple{N}, Tuple{Any, N, D}} where {N<:Node, D<:Distributions.Distribution{Distributions.Univariate, Distributions.Continuous}}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.make_kernel","text":"function make_kernel(f, node::N, d::D) where {N<:Node, D<:ContinuousUnivariateDistribution}\n\nCreates a single site proposal kernel for node that has an associated continuous univariate distribution. The resulting proposal kernel is a normal distribution, z  z sim mathrmNormal(z (05 sigma)^2) where sigma is the standard deviation of the node's distribution.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.make_kernel-Union{Tuple{D}, Tuple{N}, Tuple{Any, N, D}} where {N<:Node, D<:Distributions.Distribution{Distributions.Univariate, Distributions.Discrete}}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.make_kernel","text":"function make_kernel(f, node::N, d::D) where {N<:Node, D<:DiscreteUnivariateDistribution}\n\nCreates a single site proposal kernel for node that has an associated discrete univariate distribution. This method assumes that the distribution is defined over some subset of the integers; a support that does not meet  this criteria may result in runtime inference errors. The resulting proposal kernel is a discrete nonparametric  distribution, z  z sim mathrmDiscreteNonParametric(z - 1 z z + 1) if z is not on the boundary of  the distribution's support; or z  z sim mathrmDiscreteNonParametric(z pm 1 z) if z is on the  boundary of the distribution's support, with the sign depending on the left or right of the support.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.make_kernel-Union{Tuple{N}, Tuple{Any, N, Any}} where N<:Node","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.make_kernel","text":"function make_kernel(f, node::N, d) where {N<:Node}\n\nCreate a single site proposal kernel for an arbitrary site. This method draws from the prior site distribution and is therefore inefficient (both computationally and statistically). \n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.make_kernels-Tuple{Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.make_kernels","text":"function make_kernels(f; params = ())\n\nCreate a vector of single-site proposal functions for the stochastic function f.  This method assumes static model structure and generates a proposal kernel for each model site. The tuple of params are any necessary parameters needed to execute f.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.make_kernels-Union{Tuple{T}, Tuple{Any, Trace, Vector{T}}} where T","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.make_kernels","text":"function make_kernels(f, t::Trace, addresses::Vector{T}; params = (), include::Bool=true) where T\n\nCreate a vector of single-site proposal functions for the stochastic function f.  This method assumes static model structure and generates a proposal either for each site in addresses (include = true) or for each site not in addresses (include = false). The tuple of params are any necessary parameters needed to execute f.\n\n\n\n\n\n","category":"method"},{"location":"#inference","page":"CrimsonSkyline.jl","title":"inference","text":"","category":"section"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"There is a high-level uniform interface to built-in inference algorithms.","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Modules = [CrimsonSkyline]\nPages = [\"inference/inference.jl\"]","category":"page"},{"location":"#CrimsonSkyline.inference-Tuple{Any, CrimsonSkyline.Nested}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.inference","text":"function inference(f, method::Nested; params = (), inference_params = Dict())\n\nNo additional arguments.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.inference-Tuple{Any, Forward}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.inference","text":"function inference(f, method::Forward; params = (), inference_params = Dict())\n\nNo additional arguments.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.inference-Tuple{Any, ImportanceSampling}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.inference","text":"function inference(f, method::ImportanceSampling; params = (), inference_params = Dict())\n\nAdditional arguments: inference_params[\"kernel\"] = q  where q is a proposal kernel for importance sampling\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.inference-Tuple{Any, LikelihoodWeighting}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.inference","text":"function inference(f, method::LikelihoodWeighting; params = (), inference_params = Dict())\n\nNo additional arguments.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.inference-Tuple{Any, Metropolis}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.inference","text":"function inference(f, method::Metropolis; params = (), inference_params = Dict())\n\nAdditional arguments: inference_params[\"kernels\"]  which is a vector of >= 1 proposal kernels. If this is not passed, this method uses  ancestor MH sampling.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.inference-Tuple{Any}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.inference","text":"inference(f; params = (), inference_params = Dict())\n\nDo inference on the stochastic function f, passing as arguments to the inference algorithm  the tuple of params and any additional arguments to the inference algorithm in inference_params. To specify a particular inference algorithm pass an InferenceType as the second argument to the function, i.e.,  inference(f, i::InferenceType; params = (), inference_params = Dict()). All methods accept inference_params[\"num_iterations\"]::Int64 as the number of iterations of inference to perform; the interpretation of that is inference algorithm-dependent. This default method performs inference using LikelihoodWeighting().\n\n\n\n\n\n","category":"method"},{"location":"#db","page":"CrimsonSkyline.jl","title":"db","text":"","category":"section"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"To facilitate high-level probabilistic reasoning, it is possible to treat stochastic functions as database tables  and query them using a dialect of SQL (SQLite).","category":"page"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"Modules = [CrimsonSkyline]\nPages = [\"representation/db.jl\"]","category":"page"},{"location":"#CrimsonSkyline.SQLModel","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.SQLModel","text":"struct SQLModel{F} <: TabularModel{F}\n    f::F\n    db::SQLite.DB\nend\n\nA representation of the model f as a SQL table.\n\n\n\n\n\n","category":"type"},{"location":"#CrimsonSkyline.SQLModel-Tuple{F} where F","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.SQLModel","text":"function SQLModel(f::F; params = (), num_iterations = 100, method::InferenceType = FORWARD, inference_params = Dict(), name = nothing) where F\n\nCreate a representation of the model f as a database table which can be queried using SQL (SQLite, specifically). This method works by first conducting inference on the model (including forward sampling if the user just wants to query the prior),  and then collecting sampled values in a table. The resulting table is titled <name>_results and includes a column for each address (titled a) that occurs in the union of all sampled traces and a corresponding column for each address's log probability (titled a_logprob).\n\nThis methood does work with open-universe structured models; traces (rows in the table) that do not include address a have a  NULL in columns a and a_logprob in that row.\n\nparams: additional parameters to pass to the model during inference\nnum_iterations: number of iterations of inference to complete; the meaning is dependent on the inference algorithm used\nmethod: an InferenceType, defaults to Forward() for forward sampling.\ninference_params: a dict of parameters to pass to the inference method. \nname: a name to use instead of the model's name, which is used by default.\n\n\n\n\n\n","category":"method"},{"location":"#CrimsonSkyline.query-Tuple{SQLModel, String}","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.query","text":"function query(sqm::SQLModel, q::String)\n\nExecute the SQLite query q against the SQLModel and return results as a DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"#Index","page":"CrimsonSkyline.jl","title":"Index","text":"","category":"section"},{"location":"","page":"CrimsonSkyline.jl","title":"CrimsonSkyline.jl","text":"","category":"page"}]
}
